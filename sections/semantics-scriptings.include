<section>

<!--

    Scripting

  This source produces section 4.12: Scripting
  https://w3c.github.io/html/semantics-scripting.html

  It covers:
  - Introduction to scripts and the following elements
  - script
  - noscript
  - template
  - canvas
  - custom elements

-->

<h3 id="semantics-scripting">Scripting</h3>

  Scripts allow authors to add interactivity to their documents.

  Authors are encouraged to use declarative alternatives to scripting where possible, as
  declarative mechanisms are often more maintainable, and many users disable scripting.

  <div class="example">
    For example, instead of using script to show or hide a section to show more details, the
    <{details}> element could be used.
  </div>

  Authors are also encouraged to make their applications degrade gracefully in the absence of
  scripting support.

  <div class="example">
    For example, if an author provides a link in a table header to dynamically resort the table,
    the link could also be made to function without scripts by requesting the sorted table from the
    server.
  </div>

<h4 id="the-script-element">The <dfn element><code>script</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Script-supporting element</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>Where <a>metadata content</a> is expected.</dd>
    <dd>Where <a>phrasing content</a> is expected.</dd>
    <dd>Where <a>script-supporting elements</a> are expected.</dd>
    <dt><a>Content model</a>:</dt>
    <dd>
      If there is no <{script/src}> attribute, depends on the value of the
      <{script/type}> attribute, but must match <a>script content restrictions</a>.
    </dd>
    <dd>
      If there <em>is</em> a <{script/src}> attribute, the element must be either empty or
      contain only <a>script documentation</a> that also matches
      <a>script content restrictions</a>.
    </dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><{script/src}> - Address of the resource</dd>
    <dd><{script/type}> - Type of embedded resource</dd>
    <dd><{script/async}> - Execute script <a>in parallel</a></dd>
    <dd><{script/defer}> - Defer script execution</dd>
    <dd><{script/crossorigin}> - How the element handles crossorigin requests</dd>
    <dd><{script/integrity}> -  Integrity metadata used in <em>Subresource Integrity</em> checks [[!SRI]]</dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd>None</dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd>None</dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl">
        interface HTMLScriptElement : HTMLElement {
          attribute DOMString src;
          attribute DOMString type;
          attribute DOMString charset;
          attribute boolean async;
          attribute boolean defer;
          attribute DOMString? crossOrigin;
          attribute DOMString text;
          attribute DOMString nonce;
        };
      </pre>
    </dd>
  </dl>

  The <{script}> element allows authors to include dynamic script and data blocks in
  their documents. The element does not <a>represent</a> content for the user.

  The <dfn element-attr for="script"><code>type</code></dfn> attribute allows customization of the
  type of script represented:

  * Omitting the attribute, or setting it to a <a>JavaScript MIME type</a>, means that the script
     is a <a>classic script</a>, to be interpreted according to the JavaScript
     <a for="ecma">Script</a> top-level production. Classic scripts are affected by the
     <{script/charset}>, <{script/async}>, and <{script/defer}> attributes. Authors should omit
     the attribute, instead of redundantly giving a <a>JavaScript MIME type</a>.
  * Setting the attribute to an <a>ASCII case-insensitive</a> match for the string
     "<code>module</code>" means that the script is a <a>module script</a>, to be interpreted
     according to the JavaScript <a>Module</a> top-level production. Module scripts are
     not affected by the <{script/charset}> and <{script/defer}> attributes.
  * Setting the attribute to any other value means that the script is a
     <dfn lt="data block|data blocks">data block</dfn>, which is not processed. None of the
     <{script}> attributes (except <{script/type}> itself) have any effect on <a>data blocks</a>.
     Authors must use a <a>valid MIME type</a> that is not a <a>JavaScript MIME type</a> to denote
     <a>data blocks</a>.

  <p class="note">
    The requirement that <a>data blocks</a> must be denoted using a <a>valid MIME type</a> is in
    place to avoid potential future collisions. If this specification ever adds additional types
    of [=concept/script=], they will be triggered by setting the <{script/type}> attribute to
    something which is not a MIME type, like how the "<code>module</code>" value denotes
    <a>module scripts</a>. By using a valid MIME type now, you ensure that your data block
    will not ever be reinterpreted as a different script type, even in future user agents.
  </p>

  <a>Classic scripts</a> and <a>module scripts</a> may either be embedded inline or may be imported
  from an external file using the <dfn element-attr for="script"><code>src</code></dfn> attribute,
  which if specified gives the [=url/URL=] of the external script resource to use.
  If <{script/src}> is specified, it must be a
  <a>valid non-empty URL potentially surrounded by spaces</a>. The contents of inline
  <{script}> elements, or the external script resource, must conform with the requirements
  of the JavaScript specification's <a for="ecma">Script</a> or <a>Module</a> productions,
  for <a>classic scripts</a> and <a>module scripts</a> respectively. [[ECMA-262]]

  When used to include <a>data blocks</a>, the data must be embedded inline, the format of the data
  must be given using the <{script/type}> attribute, and the contents of the <{script}> element
  must conform to the requirements defined for the format used. The <{script/src}>,
  <{script/charset}>, <{script/async}>, <{script/defer}>, <{script/crossorigin}>, and
  <{script/integrity}> attributes must not be specified.

  The <dfn element-attr for="script"><code>async</code></dfn> and
  <dfn element-attr for="script"><code>defer</code></dfn> attributes are <a>boolean attributes</a>
  that indicate how a script should be loaded and executed.
  They have no effect, and must not be used, on <{script}> elements that do not have a
  <{script/src}> attribute specified. <a>Classic scripts</a> may specify either or both of
  <{script/defer}> and <{script/async}>; <a>module scripts</a> may specify <{script/async}>.

  There are several possible modes that can be selected using these attributes, and depending
  on the script's <{script/type}>.

  If a <{script/defer}> attribute is present, then a classic script will be fetched
  <a>in parallel</a> to parsing, and only evaluated when parsing is complete. The attribute has
  no effect on module scripts or data blocks.

  If the <{script/async}> attribute is present, then a classic or module script will be fetched
  <a>in parallel</a> to parsing. A module script will be evaluated as soon as it is available,
  (potentially before parsing completes), as will a classic script unless a <{script/defer}>
  attribute is present.

  If neither attribute is present, the script is fetched and evaluated immediately, blocking
  parsing until these are both complete.

  <!--This is summarized in the following schematic diagram:

  <img src="images/asyncdefer.svg" style="width: 80%; min-width: 690px;"
  alt="With &lt;script>, parsing is interrupted by fetching and execution.
  With &lt;script defer>, fetching is parallel to parsing and execution takes place after all parsing has finished.
  And with &lt;script async>, fetching is parallel to parsing but once it finishes parsing is interrupted to execute the script.
  The story for &lt;script type=&quot;module&quot;> is similar to &lt;script defer>, but the dependencies will be fetched as well,
  and the story for &lt;script type=&quot;module&quot; async> is similar to &lt;script async> with the extra dependency fetching." /-->

  <p class="note">
    The exact processing details for these attributes are, for mostly historical
    reasons, somewhat non-trivial, involving a number of aspects of HTML. The implementation
    requirements are therefore by necessity scattered throughout the specification. The algorithms
    below (in this section) describe the core of this processing, but these algorithms reference
    and are referenced by the parsing rules for <{script}> [=start tag|start=] and
    [=end tag|end=] tags in HTML, <a>in foreign content</a>, and in XML, the rules for the
    {{Document/write()|document.write()}} method, the handling of
    <a for="concept">scripting</a>, etc.
  </p>

  The <{script/defer}> attribute may be specified even if the <{script/async}> attribute is
  specified, to cause legacy Web browsers that only support <{script/defer}> (and not
  <{script/async}>) to fall back to the <{script/defer}> behavior instead of the blocking behavior
  that is the default.

  The <dfn element-attr for="script"><code>crossorigin</code></dfn> attribute is a
  <a>CORS settings attribute</a>. For <a>classic scripts</a>, it controls whether error information
  will be exposed, when the script is obtained from other <a for="concept">origins</a>. For
  <a>module scripts</a>, it controls the <a>credentials mode</a> used for cross-origin requests.

  <p class="note">
    Unlike <a>classic scripts</a>, <a>module scripts</a> require the use of the
    <a>CORS protocol</a> for cross-origin fetching.
  </p>

  Changing the <{script/src}>, <{script/type}>, <{script/charset}>, <{script/async}>,
  <{script/defer}>, <{script/crossorigin}>, and <{script/integrity}> attributes dynamically has no
  direct effect; these attributes are only used at specific times described below.

  The IDL attributes
  <dfn attribute for="HTMLScriptElement"><code>src</code></dfn>,
  <dfn attribute for="HTMLScriptElement"><code>type</code></dfn>,
  <dfn attribute for="HTMLScriptElement"><code>defer</code></dfn>, and
  <dfn attribute for="HTMLScriptElement"><code>integrity</code></dfn>, must each <a>reflect</a> the
  respective content attributes of the same name.

  The <dfn attribute for="HTMLScriptElement"><code>crossOrigin</code></dfn> IDL attribute must
  <a>reflect</a> the <{script/crossorigin}> content attribute, limited to only known values.

  The <dfn attribute for="HTMLScriptElement"><code>async</code></dfn> IDL attribute controls
  whether the element will execute <a>in parallel</a> or not. If the element's "[=non-blocking=]"
  flag is set, then, on getting, the {{HTMLScriptElement/async}} IDL attribute must return true,
  and on setting, the "[=non-blocking=]" flag must first be unset, and then the content attribute
  must be removed if the IDL attribute's new value is false, and must be set to the empty string
  if the IDL attribute's new value is true. If the element's "[=non-blocking=]" flag is
  <em>not</em> set, the IDL attribute must <a>reflect</a> the <{script/async}> content attribute.

  <dl class="domintro">
    <dt><var>script</var> . {{HTMLScriptElement/text}} [ = <var>value</var> ]</dt>
    <dd>
      Returns the <a>child text content</a> of the element.

      Can be set, to replace the element's children with the given value.
    </dd>
  </dl>

  The IDL attribute <dfn attribute for="HTMLScriptElement"><code>text</code></dfn> must return the
  <a>child text content</a> of the <{script}> element. On setting, it must act the same way as the
  {{Node/textContent}} IDL attribute.

  <p class="note">
    When inserted using the {{Document/write()|document.write()}} method, <{script}> elements
    execute (typically blocking further script execution or HTML parsing), but when inserted using
    <code>innerHTML</code> and <code>outerHTML</code> attributes, they do not execute at all.
  </p>

  <div class="example">
    In this example, two <{script}> elements are used. One embeds an external
    <a>classic script</a>, and the other includes some data as a <a>data block</a>.

    <xmp highlight="html">
      <script src="game-engine.js"></script>
      <script type="text/x-game-map">
      ........U.........e
      o............A....e
      .....A.....AAA....e
      .A..AAA...AAAAA...e
      </script>
    </xmp>

    The data in this case might be used by the script to generate the map of a video game. The
    data doesn't have to be used that way, though; maybe the map data is actually embedded in other
    parts of the page's markup, and the data block here is just used by the site's search engine to
    help users who are looking for particular features in their game maps.
  </div>

  <div class="example">
    The following sample shows how a <{script}> element can be used to define a function that is
    then used by other parts of the document, as part of a <a>classic script</a>. It also shows how
    a <{script}> element can be used to invoke script while the document is being parsed, in this
    case to initialize the form's output.

    <xmp highlight="html">
      <script>
        function calculate(form) {
          var price = 52000;
          if (form.elements.brakes.checked)
            price += 1000;
          if (form.elements.radio.checked)
            price += 2500;
          if (form.elements.turbo.checked)
            price += 5000;
          if (form.elements.sticker.checked)
            price += 250;
          form.elements.result.value = price;
        }
      </script>
      <form name="pricecalc" onsubmit="return false" onchange="calculate(this)">
        <fieldset>
          <legend>Work out the price of your car</legend>
          <p>Base cost: £52000.</p>
          <p>Select additional options:</p>
          <ul>
            <li><label><input type="checkbox" name="brakes"> Ceramic brakes (£1000)</label></li>
            <li><label><input type="checkbox" name="radio"> Satellite radio (£2500)</label></li>
            <li><label><input type="checkbox" name="turbo"> Turbo charger (£5000)</label></li>
            <li><label><input type="checkbox" name="sticker"> "XZ" sticker (£250)</label></li>
          </ul>
          <p>Total: £<output name="result"></output></p>
        </fieldset>
        <script>
          calculate(document.forms.pricecalc);
        </script>
      </form>
    </xmp>
  </div>

  <div class="example">
    The following sample shows how a <{script}> element can be used to include an external
    <a>module script</a>.

    <xmp highlight="html">
      <script type="module" src="app.js"></script>
    </xmp>

    This module, and all its dependencies (expressed through JavaScript `import` statements in the
    source file), will be fetched. Once the entire resulting module tree has been imported, and the
    document has finished parsing, the contents of `app.js` will be evaluated.
  </div>

  <div class="example">
    The following sample shows how a <{script}> element can be used to write an inline
    <a>module script</a> that performs a number of substitutions on the document's text, in order
    to make for a more interesting reading experience (e.g. on a news site): [[XKCD-1288]]

    <xmp highlight="html">
      <script type="module">
       import { walkAllTextNodeDescendants } from "./dom-utils.js";

       const substitutions = new Map([
         ["witnesses", "these dudes I know"]
         ["allegedly", "kinda probably"]
         ["new study", "Tumblr post"]
         ["rebuild", "avenge"]
         ["space", "spaaace"]
         ["Google glass", "Virtual Boy"]
         ["smartphone", "Pokédex"]
         ["electric", "atomic"]
         ["Senator", "Elf-Lord"]
         ["car", "cat"]
         ["election", "eating contest"]
         ["Congressional leaders", "river spirits"]
         ["homeland security", "Homestar Runner"]
         ["could not be reached for comment", "is guilty and everyone knows it"]
       ]);

       function substitute(textNode) {
         for (const [before, after] of substitutions.entries()) {
           textNode.data = textNode.data.replace(new RegExp('\\b${before}\\b', "ig"), after);
         }
       }

       walkAllTextNodeDescendants(document.body, substitute);
      </script>
    </xmp>

    Some notable features gained by using a <a>module script</a> include the ability to import
    functions from other JavaScript modules, strict mode by default, and how top-level declarations
    do not introduce new properties onto the <a>global object</a>. Also note that no matter where
    this <{script}> element appears in the document, it will not be evaluated until both document
    parsing has complete and its dependency (`dom-utils.js`) has been fetched and evaluated.
  </div>

  <h5 id="script-processing-model">Processing model</h5>

  A <{script}> element has several associated pieces of state.

  The first is a flag indicating whether or not the script block has been
  "<dfn>already started</dfn>". Initially, <{script}> elements must have this flag unset
  (script blocks, when created, are not "already started"). The <a>cloning steps</a> for
  <{script}> elements must set the "already started" flag on the copy if it is set on the
  element being cloned.

  The second is a flag indicating whether the element was "<dfn>parser-inserted</dfn>".
  Initially, <{script}> elements must have this flag unset. It is set by the <a>HTML parser</a>
  and the <a>XML parser</a> on <{script}> elements they insert and affects the processing of those
  elements.

  The third is a flag indicating whether the element will "<dfn>non-blocking</dfn>". Initially,
  <{script}> elements must have this flag set. It is unset by the <a>HTML parser</a>
  and the <a>XML parser</a> on <{script}> elements they insert. In addition, whenever
  a <{script}> element whose "[=non-blocking=]" flag is set has an <{script/async}> content
  attribute added, the element's "[=non-blocking=]" flag must be unset.

  The fourth is a flag indicating whether or not the script block is
  "<dfn>ready to be parser-executed</dfn>". Initially, <{script}> elements must have this flag
  unset (script blocks, when created, are not "ready to be parser-executed"). This flag is used
  only for elements that are also "[=parser-inserted=]", to let the parser know when to execute
  the script.

  The fifth is <dfn>the script's type</dfn>, which is either "<code>classic</code>" or
  "<code>module</code>". It is determined when the script is <a>prepared</a>, based on the
  <{script/type}> attribute of the element at that time. Initially, <{script}> elements must have
  this flag unset.

  The sixth is a flag indicating whether or not the script is <dfn>from an external file</dfn>. It
  is determined when the script is <a>prepared</a>, based on the <{script/src}> attribute of the
  element at that time.

  Finally, a <{script}> element has <dfn>the script's script</dfn>, which is a
  <{script}> resulting from <a>preparing</a> the element. This is set asynchronously after the
  <a>classic script</a> or module tree is fetched. Once it is set, either to a <{script}> in the
  case of success or to null in the case of failure, the fetching algorithms will note that
  <dfn>the script is ready</dfn>, which can trigger other actions. The user agent must
  <a>delay the load event</a> of the element's <a>node document</a> until
  <a>the script is ready</a>.

  When a <{script}> element that is not marked as being "[=parser-inserted=]" experiences one of
  the events listed in the following list, the user agent must <a>immediately</a> <a>prepare</a>
  the <{script}> element:

  * The <{script}> element gets <a for="document">inserted into a document</a>, at the time the
     node is inserted according to the DOM, after any other <{script}> elements inserted at the
     same time that are earlier in the <code>Document</code> in <a>tree order</a>.
  * The <{script}> element is <a>in a <code>Document</code></a> and a node or document fragment is
     <a>inserted</a> into the <{script}> element, after any <{script}> elements <a>inserted</a> at
     that time.
  * The <{script}> element is <a>in a <code>Document</code></a> and has a <code>src</code>
     attribute set where previously the element had no such attribute.

  To <dfn lt="prepare a script|preparing|prepared">prepare a script</dfn>, the user agent must act
  as follows:

  1. If the <{script}> element is marked as having "[=already started=]", then the user agent
      must abort these steps at this point. The script is not executed.
  2. If the element has its "[=parser-inserted=]" flag set, then set
      <var>was-parser-inserted</var> to true and unset the element's "[=parser-inserted=]" flag.
      Otherwise, set <var>was-parser-inserted</var> to false.

      <p class="note">
        This is done so that if parser-inserted <{script}> elements fail to run when the parser
        tries to run them, e.g., because they are empty or specify an unsupported scripting
        language, another script can later mutate them and cause them to run again.
      </p>
  3. If <var>was-parser-inserted</var> is true and the element does not have an <{script/async}>
      attribute, then set the element's "[=non-blocking=]" flag to true.

      <p class="note">
        This is done so that if a parser-inserted <{script}> element fails to run when
        the parser tries to run it, but it is later executed after a script dynamically
        updates it, it will execute in a non-blocking fashion even if the <{script/async}>
        attribute isn't set.
      </p>
  4. If the element has no <{script/src}> attribute, and its child nodes, if any, consist only of
      comment nodes and empty {{Text}} nodes, then abort these steps at this point. The script is
      not executed.
  5. If the element is not <a>in a <code>Document</code></a>, then the user agent must abort these
      steps at this point. The script is not executed.
  6. If either:

      * the <{script}> element has a <{script/type}> attribute and its value is the empty string, or
      * the <{script}> element has no <{script/type}> attribute but it has a <{script/language}>
         attribute and <em>that</em> attribute's value is the empty string, or
      * the <{script}> element has neither a <{script/type}> attribute nor a <{script/language}>
         attribute, then

      ...let <var>the script block's type string</var> for this <{script}> element be
      "`text/javascript`".

      Otherwise, if the <{script}> element has a <{script/type}> attribute, let
      <var>the script block's type string</var> for this <{script}> element be the value of that
      attribute after <a>stripping leading and trailing white space</a>.

      Otherwise, the element has a non-empty <{script/language}> attribute; let
      <var>the script block's type string</var> for this <{script}> element be the
      concatenation of the string "<code>text/</code>" followed by the value of the
      <{script/language}> attribute.

      <p class="note">
        The <{script/language}> attribute is never conforming, and is always ignored
        if there is a <{script/type}> attribute present.
      </p>

      Determine <a>the script's type</a> as follows:

      * If <var>the script block's type string</var> is an <a>ASCII case-insensitive</a> match for
         any <a>JavaScript MIME type</a>, <a>the script's type</a> is "<code>classic</code>".
      * If <var>the script block's type string</var> is an <a>ASCII case-insensitive</a> match for
         the string "<code>module</code>", <a>the script's type</a> is "<code>module</code>".
      * If neither of the above conditions are true, then abort these steps at this point.
         No script is executed.
  7. If <var>was-parser-inserted</var> is true, then flag the element as "[=parser-inserted=]"
      again, and set the element's "[=non-blocking=]" flag to false.
  8. The user agent must set the element's "[=already started=]" flag.
  9. If the element is flagged as "[=parser-inserted=]", but the element's <a>node document</a>
      is not the {{Document}} of the parser that created the element, then abort these steps.
  10. If <a>scripting is disabled</a> for the <{script}> element, then abort these steps at this
       point. The script is not executed.

       <p class="note">
         The definition of <a>scripting is disabled</a> means that, amongst others,
         the following scripts will not execute: scripts in {{XMLHttpRequest}}'s
         {{XMLHttpRequest/responseXML}} documents, scripts in {{DOMParser}}-created documents,
         scripts in documents created by <code>XSLTProcessor</code>'s
         <code>transformToDocument</code> feature, and scripts that are first inserted by a
         script into a {{Document}} that was created using the
         {{DOMImplementation/createDocument()}} API. [[!XHR]] [[!DOM-PARSING]] [[XSLTP]] [[!DOM]]
       </p>
  11. If the <{script}> element does not have a <{script/src}> content attribute, and the
       <a>Should element's inline behavior be blocked by Content Security Policy?</a> algorithm
       returns "<code>Blocked</code>" when executed upon the <{script}> element,
       "<code>script</code>", and the <{script}> element's <a>child text content</a>, then
       abort these steps. The script is not executed. [[CSP3]]
  12. If the <{script}> element has an <{script/event}> attribute and a <{script/for}> attribute,
       and <a>the script's type</a> is "<code>classic</code>", then run these substeps:

       1. Let <var>for</var> be the value of the <{script/for}> attribute.
       2. Let <var>event</var> be the value of the <{script/event}> attribute.
       3. <a>Strip leading and trailing white space</a> from <var>event</var> and <var>for</var>.
       4. If <var>for</var> is not an <a>ASCII case-insensitive</a> match for the string
           "<code>window</code>", then the user agent must abort these steps at this point.
           The script is not executed.
       5. If <var>event</var> is not an <a>ASCII case-insensitive</a> match for either the string
           "<code>onload</code>" or the string "`onload()`", then the user agent must abort these
           steps at this point. The script is not executed.
  13. If the <{script}> element has a <{script/charset}> attribute, then let <var>encoding</var> be
       the result of <a>getting an encoding</a> from the value of the <{script/charset}> attribute.

       If the <{script}> element does not have a <{script/charset}> attribute, or if
       <a>getting an encoding</a> failed, let <var>encoding</var> be the same as
       <a lt="encoding">the encoding of the document itself</a>.

       <p class="note">
         If <a>the script's type</a> is "<code>module</code>", this encoding will be ignored.
       </p>
  14. Let <var>CORS setting</var> be the current state of the element's <{script/crossorigin}>
       content attribute.
  15. Let <var>cryptographic nonce</var> be the element's
       <a href="#cryptographicnonce">[[<span>CryptographicNonce</span>]]</a> internal slot's value.
  16. If the <{script}> element has an <{script/integrity}> attribute, then let
      <var>integrity metadata</var> be that attribute's value.
      Otherwise, let <var>integrity metadata</var> be the empty string.
  17. Let <var>parser metadata</var> be "<code>parser-inserted</code>" if the <{script}> element
       has been flagged as "[=parser-inserted=]", and "`not parser-inserted`" otherwise.
  18. Let options be a set of <a>script fetch options</a> whose
       <a>cryptographic nonce metadata</a> is cryptographic nonce, <a>integrity metadata</a>
       is integrity metadata, <a>parser metadata</a> is <var>parser metadata</var>,
       <a>credentials mode</a> is module script credentials mode, and <a>referrer policy</a>
       is the empty string.
  19. Let <var>settings</var> be the element's <a>node document</a>'s {{Window}} object's
       <a>environment settings object</a>.
  20. If the element has a <{script/src}> content attribute, run these substeps:

       1. Let <var>src</var> be the value of the element's <{script/src}> attribute.
       2. If <var>src</var> is the empty string, <a>queue a task</a> to <a>fire a simple event</a>
           named <code>error</code> at the element, and abort these steps.
       3. Set the element's <a>from an external file</a> flag.
       4. <a>Parse</a> <var>src</var> relative to the element's <a>node document</a>.
       5. If the previous step failed, <a>queue a task</a> to <a>fire a simple event</a> named
           <code>error</code> at the element, and abort these steps.

           Otherwise, let <var>url</var> be the <a>resulting URL record</a>.
       6. Switch on <a>the script's type</a>:
           <dl class="switch">
             <dt>`"classic"`</dt>
             <dd><a>Fetch a classic script</a> given <var>url</var>, <var>settings object</var>,
             <var>options</var>, <var ignore=''>classic script CORS setting</var>, and
             <var>encoding</var>.

             <dt><code>"module"</code></dt>
             <dd>
               <a>Fetch a module script tree</a> given <var>url</var>,
               <var>settings object</var>, "<code>script</code>", and <var>options</var>.
             </dd>
           </dl>
           When the chosen algorithm asynchronously completes, set <a>the script's script</a> to
           the result. At that time, <a>the script is ready</a>.

           For performance reasons, user agents may start fetching the classic script or
           module tree (as defined above) as soon as the <{script/src}> attribute is set,
           instead, in the hope that the element will be
           <a for="document">inserted into the document</a> (and that the
           <{script/crossorigin}> attribute won't change value in the meantime). Either way, once
           the element is <a for="document">inserted into the document</a>, the load must have
           started as described in this step. If the UA performs such prefetching, but the element
           is never inserted in the document, or the <{script/src}> attribute is dynamically
           changed, or the <{script/crossorigin}> attribute is dynamically changed, then the user
           agent will not execute the script so obtained, and the fetching process will have been
           effectively wasted.
  21. If the element does not have a <{script/src}> content attribute, run these substeps:

       1. Let <var>source text</var> be the <{script}> element's <a>child text content</a>.
       2. Let <var>base URL</var> be the <{script}> element's <a>node document</a>'s
           <a>document base URL</a>.
       3. Switch on <a>the script's type</a>:
           <dl class="switch">
             <dt>`"classic"`</dt>
             <dd>
                  1. Let <var>script</var> be the result of <a>creating a classic script</a> using
                      <var>source text</var>, <var>settings object</var>, <var>base URL</var> and
                      <var>options</var>.
                  2. Set <a>the script's script</a> to <var>script</var>.
                  3. <a>The script is ready</a>.
             </dd>

             <dt><code>"module"</code></dt>
             <dd>
                  1. Let <var>script</var> be the result of <a>creating a module script</a> using
                      <var>source text</var>, <var>settings object</var>, <var>base URL</var>, and
                      <var>options</var>.
                  2. If this returns null, set <a>the script's script</a> to null and abort these
                      substeps; <a>the script is ready</a>.
                  3. <a>Fetch the descendants</a> of and instantiate script, given the destination
                      "<var>script</var>". When this asynchronously completes,
                      set <a>the script's script</a> to the result. At that time,
                      <a>the script is ready</a>.
             </dd>
           </dl>
  22. Then, follow the first of the following options that describes the situation:
       <dl class="switch">
         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td>`"classic"`
               <td>yes
               <td>yes
               <td>no
               <td>element flagged as "[=parser-inserted=]"
             </tr>
             <tr>
               <td><code>"module"</code>
               <td>yes or no
               <td>n/a
               <td>no
               <td>element flagged as "[=parser-inserted=]"
             </tr>
           </tbody>
         </table>
         Add the element to the end of the <dfn>list of scripts that will execute when the
         document has finished parsing</dfn> associated with the {{Document}} of the parser that
         created the element.

         When the <a>the script is ready</a>, set the element's "[=ready to be parser-executed=]"
         flag. The parser will handle executing the script.</dd>

         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td>`"classic"`
               <td>yes
               <td>no
               <td>no
               <td>element flagged as "[=parser-inserted=]"
             </tr>
           </tbody>
         </table>
         The element is the <a>pending parsing-blocking script</a> of the {{Document}} of the
         parser that created the element. (There can only be one such script per {{Document}} at a
         time.)

         When <a>the script is ready</a>, set the element's "[=ready to be parser-executed=]"
         flag. The parser will handle executing the script.
         </dd>

         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td>`"classic"`
               <td>yes
               <td>yes or no
               <td>no
               <td>"[=non-blocking=]" flag not set on element
             </tr>
             <tr>
               <td><code>"module"</code>
               <td>yes or no
               <td>n/a
               <td>no
               <td>"[=non-blocking=]" flag not set on element
             </tr>
           </tbody>
         </table>
         Add the element to the end of the <dfn>list of scripts that will execute in order
         as soon as possible</dfn> associated with the <a>node document</a> of the <{script}>
         element at the time the <a>prepare a script</a> algorithm started.

         When <a>the script is ready</a>, run the following steps:

         1. If the element is not now the first element in the
             <a>list of scripts that will execute in order as soon as possible</a> to which it was
             added above, then mark the element as ready but abort these steps without executing the
             script yet.
         2. <var>Execution</var>: <a>Execute the script block</a> corresponding to the first script
             element in this <a>list of scripts that will execute in order as soon as possible</a>.
         3. Remove the first element from this
             <a>list of scripts that will execute in order as soon as possible</a>.
         4. If this <a>list of scripts that will execute in order as soon as possible</a> is still
             not empty and the first entry has already been marked as ready, then jump back to the
             step labeled <var>Execution</var>.

         </dd>

         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td>`"classic"`
               <td>yes
               <td>yes or no
               <td>yes or no
               <td>n/a
             </tr>
             <tr>
               <td><code>"module"</code>
               <td>yes or no
               <td>n/a
               <td>yes or no
               <td>n/a
             </tr>
           </tbody>
         </table>
         The element must be added to the
         <dfn>set of scripts that will execute as soon as possible</dfn> of the <a>node document</a>
         of the <{script}> element at the time the <a>prepare a script</a> algorithm started.

         When <a>the script is ready</a>, <a>execute the script block</a> and then remove the
         element from the <a>set of scripts that will execute as soon as possible</a>.</dd>

         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td><code>"classic"</code> or <code>"module"</code>
               <td>no
               <td>yes or no
               <td>yes or no
               <td>All of the following:

                    * element flagged as "[=parser-inserted=]"
                    * an <a>XML parser</a> or an <a>HTML parser</a> whose
                        <a>script nesting level</a> is not greater than one created the <{script}>
                    * the {{Document}} of the <a>XML parser</a> or <a>HTML parser</a> that created
                        the <{script}> <a>has a style sheet that is blocking scripts</a>
             </tr>
           </tbody>
         </table>
         The element is the <a>pending parsing-blocking script</a> of the {{Document}} of the
         parser that created the element. (There can only be one such script per {{Document}} at a
         time.)

         Set the element's "[=ready to be parser-executed=]" flag. The parser will handle
         executing the script.</dd>

         <dt>Otherwise</dt>
         <dd><a>Immediately</a> <a>execute the script block</a>, even if other scripts are already
         executing.</dd>
       </dl>

  The <dfn>pending parsing-blocking script</dfn> of a {{Document}} is used by the {{Document}}'s
  parser(s).

  <p class="note">
    If a <{script}> element that blocks a parser gets moved to another {{Document}} before it
    would normally have stopped blocking that parser, it nonetheless continues blocking that
    parser until the condition that causes it to be blocking the parser no longer applies
    (e.g., if the script is a <a>pending parsing-blocking script</a> because there was
    <a>a style sheet that is blocking scripts</a> when it was parsed, but then the script is
    moved to another {{Document}} before the style sheet loads, the script still blocks the
    parser until the style sheets are all loaded, at which time the script executes and the
    parser is unblocked).
  </p>

  When the user agent is required to
  <dfn lt="execute a script block|execute|execute the script block">execute a script block</dfn>,
  it must run the following steps:

  1. If the element is flagged as "[=parser-inserted=]", but the element's <a>node document</a>
      is not the {{Document}} of the parser that created the element, then abort these steps.
  2. If <a>the script's script</a> is null, <a>fire a simple event</a> named <code>error</code>
      at the element, and abort these steps.
  3. If the script is <a>from an external file</a>, or <a>the script's type</a> is
      "<code>module</code>", then increment the <a>ignore-destructive-writes counter</a> of the
      <{script}> element's <a>node document</a>. Let <var>neutralized doc</var> be that
      {{Document}}.
  4. Let <var>old script element</var> be the value to which the <{script}> element's
      <a>node document</a>'s {{Document/currentScript}} object was most recently set.
  5. Switch on <a>the script's type</a>:
      <dl class="switch">
        <dt>`"classic"`</dt>
        <dd>
             1. Set the <{script}> element's <a>node document</a>'s {{Document/currentScript}}
                 attribute to the <{script}> element.

                 <p class="note">
                   This does not use the <a>in a document</a> check, as the <{script}> element
                   could have been removed from the document prior to execution, and in that
                   scenario {{Document/currentScript}} still needs to point to it.
                 </p>
             2. <a>Run the classic script</a> given by <a>the script's script</a>.
        </dd>

        <dt><code>"module"</code></dt>
        <dd>
             1. Set the <{script}> element's <a>node document</a>'s {{Document/currentScript}}
                 attribute to null.
             2. <a>Run the module script</a> given by <a>the script's script</a>.
        </dd>
  6. Set the <{script}> element's <a>node document</a>'s {{Document/currentScript}} object to
      <var>old script element</var>.
  7. Decrement the <a>ignore-destructive-writes counter</a> of <var>neutralized doc</var>, if it
      was incremented in the earlier step.
  8. If <a>the script's type</a> is "<code>classic</code>" and the script is
      <a>from an external file</a>, <a>fire a simple event</a> named <code>load</code>
      at the <{script}> element.

      Otherwise <a>queue a task</a> to <a>fire a simple event</a> named <code>load</code> at the
      <{script}> element.

<h5 id="scripting-languages">Scripting languages</h5>

  A <dfn>JavaScript MIME type</dfn> is a <a>MIME type</a> string that is one of the
  following and refers to JavaScript: [[!ECMA-262]]

  <ul class="brief">
    <li><code>application/ecmascript</code></li>
    <li><code>application/javascript</code></li>
    <li><code>application/x-ecmascript</code></li>
    <li><code>application/x-javascript</code></li>
    <li><code>text/ecmascript</code></li>
    <li><code>text/javascript</code></li>
    <li><code>text/javascript1.0</code></li>
    <li><code>text/javascript1.1</code></li>
    <li><code>text/javascript1.2</code></li>
    <li><code>text/javascript1.3</code></li>
    <li><code>text/javascript1.4</code></li>
    <li><code>text/javascript1.5</code></li>
    <li><code>text/jscript</code></li>
    <li><code>text/livescript</code></li>
    <li><code>text/x-ecmascript</code></li>
    <li><code>text/x-javascript</code></li>
  </ul>

  User agents must recognize all <a>JavaScript MIME types</a>.

  User agents may support other <a>MIME types</a> for other languages, but must not support other
  <a>MIME types</a> for the languages in the list above. User agents are not required to support
  JavaScript. The processing model for languages other than JavaScript is outside the scope of this
  specification.

  The following <a>MIME types</a> (with or without parameters) must not be interpreted as scripting
  languages:

  * `text/plain`
  * `text/xml`
  * `application/octet-stream`
  * `application/xml`

  <p class="note">
    These types are explicitly listed here because they are poorly-defined types that
    are nonetheless likely to be used as formats for data blocks, and it would be problematic
    if they were suddenly to be interpreted as script by a user agent.
  </p>

  When examining types to determine if they represent supported languages, user agents must not
  ignore MIME parameters. Types are to be compared including all parameters.

  <p class="note">
    For example, types that include the <code>charset</code> parameter will not be
    recognized as referencing any of the scripting languages listed above.
  </p>

<h5 id="restrictions-for-contents-of-script-elements"><dfn lt="script content restrictions">Restrictions for contents of <{script}> elements</dfn></h5>

  <p class="note">
    The easiest and safest way to avoid the rather strange restrictions described in
    this section is to always escape "`&lt;!--`" as "`&lt;\!--`", "`&lt;script`" as
    "`&lt;\script`", and "`&lt;/script`" as "`&lt;\/script`" when these sequences appear in
    literals in scripts (e.g., in strings, regular expressions, or comments), and to avoid writing
    code that uses such constructs in expressions. Doing so avoids the pitfalls that the
    restrictions in this section are prone to triggering: namely, that, for historical reasons,
    parsing of <{script}> blocks in HTML is a strange and exotic practice that acts counter
    intuitively in the face of these sequences.
  </p>

  The {{Node/textContent}} of a <{script}> element must match the <code>script</code> production in
  the following ABNF, the character set for which is Unicode. [[!ABNF]]

  <pre data-highlight="abnf">
    script        = outer *( comment-open inner comment-close outer )

    outer         = &lt; any string that doesn't contain a substring that matches not-in-outer &gt;
    not-in-outer  = comment-open
    inner         = &lt; any string that doesn't contain a substring that matches not-in-inner &gt;
    not-in-inner  = comment-close / script-open

    comment-open  = "&lt;!--"
    comment-close = "--&gt;"
    script-open   = "&lt;" s c r i p t tag-end

    s             =  %x0053 ; U+0053 LATIN CAPITAL LETTER S
    s             =/ %x0073 ; U+0073 LATIN SMALL LETTER S
    c             =  %x0043 ; U+0043 LATIN CAPITAL LETTER C
    c             =/ %x0063 ; U+0063 LATIN SMALL LETTER C
    r             =  %x0052 ; U+0052 LATIN CAPITAL LETTER R
    r             =/ %x0072 ; U+0072 LATIN SMALL LETTER R
    i             =  %x0049 ; U+0049 LATIN CAPITAL LETTER I
    i             =/ %x0069 ; U+0069 LATIN SMALL LETTER I
    p             =  %x0050 ; U+0050 LATIN CAPITAL LETTER P
    p             =/ %x0070 ; U+0070 LATIN SMALL LETTER P
    t             =  %x0054 ; U+0054 LATIN CAPITAL LETTER T
    t             =/ %x0074 ; U+0074 LATIN SMALL LETTER T

    tag-end       =  %x0009 ; U+0009 CHARACTER TABULATION (tab)
    tag-end       =/ %x000A ; U+000A LINE FEED (LF)
    tag-end       =/ %x000C ; U+000C FORM FEED (FF)
    tag-end       =/ %x0020 ; U+0020 SPACE
    tag-end       =/ %x002F ; U+002F SOLIDUS (/)
    tag-end       =/ %x003E ; U+003E GREATER-THAN SIGN (&gt;)
  </pre>

  When a <{script}> element contains <a>script documentation</a>, there are further restrictions on
  the contents of the element, as described in the section below.

  <div class="example">
    The following script illustrates this issue. Suppose you have a script that contains a string,
    as in:

    <xmp highlight="javascript">
      var example = 'Consider this string: <!-- <script>';
      console.log(example);
    </xmp>

    If one were to put this string directly in a <{script}> block, it would violate the
    restrictions above:

    <xmp highlight="html">
      <script>
        var example = 'Consider this string: <!-- <script>';
        console.log(example);
      </script>;
    </xmp>

    The bigger problem, though, and the reason why it would violate those restrictions, is that
    actually the script would get parsed weirdly:
    <em>the script block above is not terminated</em>. That is, what looks like a
    "<code>&lt;/script></code>" end tag in this snippet is actually still part of the <{script}>
    block. The  script doesn't execute (since it's not terminated); if it somehow were to execute,
    as it might  if the markup looked as follows, it would fail because the script is not valid
    JavaScript:

    <xmp highlight="html">
      <script>
        var example = 'Consider this string: <!-- <script>';
        console.log(example);
      </script>
      <!-- despite appearances, this is actually part of the script still! -->
      <script>
        ... // this is the same script block still...
      </script>
    </xmp>

    What is going on here is that for legacy reasons, "<code>&lt;!--</code>" and
    "<code>&lt;script</code>" strings in <{script}> elements in HTML need to be balanced in
    order for the parser to consider closing the block.

    By escaping the problematic strings as mentioned at the top of this section, the problem is
    avoided entirely:

    <xmp highlight="html">
      <script>
        var example = 'Consider this string: <\!-- <\script>';
        console.log(example);
      </script>
      <!-- this is just a comment between script blocks -->
      <script>
        ... // this is a new script block
      </script>
    </xmp>

    It is possible for these sequences to naturally occur in script expressions, as in the
    following examples:

    <xmp highlight="javascript">
      if (x<!--y) { ... }
      if ( player<script ) { ... }
    </xmp>

    In such cases the characters cannot be escaped, but the expressions can be rewritten so that
    the sequences don't occur, as in:

    <xmp highlight="javascript">
      if (x < !--y) { ... }
      if (!--y > x) { ... }
      if (!(--y) > x) { ... }
      if (player < script) { ... }
      if (script > player) { ... }
    </xmp>

    Doing this also avoids a different pitfall as well: for related historical reasons, the string
    "<code>&lt;!--</code>" in <a>classic scripts</a> is actually treated as a line comment start, just like
    "`//`".

  </div>

<h5 id="inline-documentation-for-external-scripts"><dfn lt="script documentation">Inline documentation for external scripts</dfn></h5>

  If a <{script}> element's <{script/src}> attribute is specified, then the contents of the
  <{script}> element, if any, must be such that the value of the {{HTMLScriptElement/text}} IDL
  attribute, which is derived from the element's contents, matches the <code>documentation</code>
  production in the following ABNF, the character set for which is Unicode. [[!ABNF]]

  <pre data-highlight="abnf">
    documentation = *( *( space / tab / comment ) [ line-comment ] newline )
    comment       = slash star *( not-star / star not-slash ) 1*star slash
    line-comment  = slash slash *not-newline

    ; characters
    tab           = %x0009 ; U+0009 CHARACTER TABULATION (tab)
    newline       = %x000A ; U+000A LINE FEED (LF)
    space         = %x0020 ; U+0020 SPACE
    star          = %x002A ; U+002A ASTERISK (*)
    slash         = %x002F ; U+002F SOLIDUS (/)
    not-newline   = %x0000-0009 / %x000B-10FFFF
                    ; a Unicode character other than U+000A LINE FEED (LF)
    not-star      = %x0000-0029 / %x002B-10FFFF
                    ; a Unicode character other than U+002A ASTERISK (*)
    not-slash     = %x0000-002E / %x0030-10FFFF
                    ; a Unicode character other than U+002F SOLIDUS (/)
  </pre>

  <p class="note">
    This corresponds to putting the contents of the element in JavaScript comments.
  </p>

  <p class="note">
    This requirement is in addition to the earlier restrictions on the syntax of
    contents of <{script}> elements.
  </p>

  <div class="example">
    This allows authors to include documentation, such as license information or API information,
    inside their documents while still referring to external script files. The syntax is
    constrained so that authors don't accidentally include what looks like valid script while
    also providing a <{script/src}> attribute.

    <xmp highlight="html">
      <script src="cool-effects.js">
        // create new instances using:
        //    var e = new Effect();
        // start the effect using .play, stop using .stop:
        //    e.play();
        //    e.stop();
      </script>
    </xmp>
  </div>

<h5 id="interaction-of-script-elements-and-xslt">Interaction of <{script}> elements and XSLT</h5>

  <em>This section is non-normative.</em>

  This specification does not define how XSLT interacts with the <{script}> element.
  However, in the absence of another specification actually defining this, here are some guidelines
  for implementors, based on existing implementations:

  * When an XSLT transformation program is triggered by an `&lt;?xml-stylesheet?&gt;` processing
     instruction and the browser implements a direct-to-DOM transformation, <{script}> elements
     created by the XSLT processor need to be marked "[=parser-inserted=]" and run in document
     order (modulo scripts marked <{script/defer}> or <{script/async}>), <a>immediately</a>, as the
     transformation is occurring.
  * The <code>XSLTProcessor.transformToDocument()</code> method [[XSLTP]] adds elements to a
     {{Document}} that is not in a <a>browsing context</a>, and, accordingly, any <{script}>
     elements they create need to have their "[=already started=]" flag set in the
     <a>prepare a script</a> algorithm and never get executed (<a>scripting is disabled</a>). Such
     <{script}> elements still need to be marked "[=parser-inserted=]", though, such that their
     {{HTMLScriptElement/async}} IDL attribute will return false in the absence of an
     <{script/async}> content attribute.
  * The <code>XSLTProcessor.transformToFragment()</code> method needs to create a fragment that is
     equivalent to one built manually by creating the elements using
     {{Document/createElementNS()|document.createElementNS()}}. For instance, it needs to create
     <{script}> elements that aren't "[=parser-inserted=]" and that don't have their
     "[=already started=]" flag set, so that they will execute when the fragment is
     <a for="document">inserted into a document</a>.

  The main distinction between the first two cases and the last case is that the first two
  operate on {{Document}}s and the last operates on a fragment.

<h4 id="the-noscript-element">The <dfn element><code>noscript</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>
      In a <{head}> element of an <a>HTML document</a>, if there are no ancestor
      <{noscript}> elements.
    </dd>
    <dd>
      Where <a>phrasing content</a> is expected in <a>HTML documents</a>, if there are no ancestor
      <{noscript}> elements.
    </dd>
    <dt><a>Content model</a>:</dt>
    <dd>
      When <a>scripting is disabled</a>, in a <{head}> element: in any order, zero or more
      <{link}> elements, zero or more <{style}> elements, and zero or more <{meta}> elements.
    </dd>
    <dd>
      When <a>scripting is disabled</a>, not in a <{head}> element: <a>transparent</a>,
      but there must be no <{noscript}> element descendants.
    </dd>
    <dd>Otherwise: text that conforms to the requirements given in the prose.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd>None</dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd>None</dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>Uses {{HTMLElement}}.</dd>
  </dl>

  The <{noscript}> element <a>represents</a> nothing if <a>scripting is enabled</a>, and
  <a>represents</a> its children if <a>scripting is disabled</a>. It is used to present different
  markup to user agents that support scripting and those that don't support scripting, by affecting
  how the document is parsed.

  When used in <a>HTML documents</a>, the allowed content model is as follows:

  : In a <{head}> element, if <a>scripting is disabled</a> for the <{noscript}> element
  :: The <{noscript}> element must contain only <{link}>, <{style}>, and <{meta}> elements.

  : In a <{head}> element, if <a>scripting is enabled</a> for the <{noscript}> element
  :: The <{noscript}> element must contain only text, except that invoking the
      <a>HTML fragment parsing algorithm</a> with the <{noscript}> element as the <a>context</a>
      element and the text contents as the <var>input</var> must result in a list of nodes that
      consists only of <{link}>, <{style}>, and <{meta}> elements that would be conforming if they
      were children of the <{noscript}> element, and no [=parse errors=].

  : Outside of <{head}> elements, if <a>scripting is disabled</a> for the <{noscript}> element
  :: The <{noscript}> element's content model is <a>transparent</a>, with the additional restriction
      that a <{noscript}> element must not have a <{noscript}> element as an ancestor (that is,
      <{noscript}> can't be nested).

  : Outside of <{head}> elements, if <a>scripting is enabled</a> for the <{noscript}> element
  :: The <{noscript}> element must contain only text, except that the text must be such that
      running the following algorithm results in a
      <a lt="conforming document">conforming document</a> with no <{noscript}> elements and no
      <{script}> elements, and such that no step in the algorithm throws an exception or causes
      an <a>HTML parser</a> to flag a [=parse error=]:

      1. Remove every <{script}> element from the document.
      2. Make a list of every <{noscript}> element in the document. For every <{noscript}> element
          in that list, perform the following steps:

          1. Let <var>s</var> be the <a>child text content</a> of the <{noscript}> element.
          2. Set the <code>outerHTML</code> attribute of the <{noscript}> element to the value of
              <var>s</var>. (This, as a side-effect, causes the <{noscript}> element to be removed
              from the document.) [[!DOM-PARSING]]

  <p class="note">
    All these contortions are required because, for historical reasons, the
    <{noscript}> element is handled differently by the <a>HTML parser</a> based on
    whether [=scripting flag|scripting was enabled or not=] when the parser was invoked.
  </p>

  The <{noscript}> element must not be used in <a>XML documents</a>.

  <p class="note">
    The <{noscript}> element is only effective in <a href="#syntax">the HTML syntax</a>, it has no
    effect in <a href="#xhtml">the XHTML syntax</a>. This is because the way it works is by
    essentially "turning off" the parser when scripts are enabled, so that the contents of the
    element are treated as pure text and not as real elements. XML does not define a mechanism
    by which to do this.
  </p>

  The <{noscript}> element has no other requirements. In particular, children of the <{noscript}>
  element are not exempt from [[#forms-form-submission]], scripting, and so forth, even when
  <a>scripting is enabled</a> for the element.

  <div class="example">
    In the following example, a <{noscript}> element is used to provide fallback for a script.

    <xmp highlight="html">
      <form action="calcSquare.php">
        <p>
          <label for="x">Number</label>:
          <input id="x" name="x" type="number">
        </p>
        <script>
          var x = document.getElementById('x');
          var output = document.createElement('p');
          output.textContent = 'Type a number; it will be squared right then!';
          x.form.appendChild(output);
          x.form.onsubmit = function() {
            return false;
          }
          x.oninput = function() {
            var v = x.valueAsNumber;
            output.textContent = v + ' squared is ' + v * v;
          };
        </script>
        <noscript>
          <input type="submit" value="Calculate Square">
        </noscript>
      </form>
    </xmp>

    When script is disabled, a button appears to do the calculation on the server side. When
    script is enabled, the value is computed on-the-fly instead.

    The <{noscript}> element is a blunt instrument. Sometimes, scripts might be enabled, but
    for some reason the page's script might fail. For this reason, it's generally better to avoid
    using <{noscript}>, and to instead design the script to change the page from being a
    scriptless page to a scripted page on the fly, as in the next example:

    <xmp highlight="html">
      <form action="calcSquare.php">
        <p>
          <label for="x">Number</label>:
          <input id="x" name="x" type="number">
        </p>
        <input id="submit" type=submit value="Calculate Square">
        <script>
          var x = document.getElementById('x');
          var output = document.createElement('p');
          output.textContent = 'Type a number; it will be squared right then!';
          x.form.appendChild(output);
          x.form.onsubmit = function() {
            return false;
          }
          x.oninput = function() {
            var v = x.valueAsNumber;
            output.textContent = v + ' squared is ' + v * v;
          };
          var submit = document.getElementById('submit');
          submit.parentNode.removeChild(submit);
        </script>
      </form>
    </xmp>

    The above technique is also useful in XHTML, since <{noscript}> is not supported in
    <a href="#xhtml">the XHTML syntax</a>.
  </div>

<h4 id="the-template-element">The <dfn element><code>template</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Script-supporting element</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>Where <a>metadata content</a> is expected.</dd>
    <dd>Where <a>phrasing content</a> is expected.</dd>
    <dd>Where <a>script-supporting elements</a> are expected.</dd>
    <dd>As a child of a <{colgroup}> element that doesn't have a <code>span</code> attribute.</dd>
    <dt><a>Content model</a>:</dt>
    <dd><a>Nothing</a> (for clarification, <a href="#template-example">see example</a>).</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible.</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd>None</dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd>None</dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl">
        [Exposed=Window,
         HTMLConstructor]
        interface HTMLTemplateElement : HTMLElement {
          readonly attribute DocumentFragment content;
        };
      </pre>
    </dd>
  </dl>

  The <{template}> element is used to declare fragments of HTML that can be cloned and
  inserted in the document by script.

  In a rendering, the <{template}> element <a>represents</a> nothing.

  The <a>template contents</a> of a <{template}> element
  <a href="#template-syntax">are not children of the element itself</a>.

  <p class="note">
    It is also possible, as a result of DOM manipulation, for a <{template}> element to contain
    {{Text}} nodes and element nodes; however, having any is a violation of the <{template}>
    element's content model, since its content model is defined as <a>Nothing</a>.
  </p>

  <div class="example" id="template-example">

    For example, consider the following document:

    <xmp highlight="html">
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <title>Homework</title>
        </head>
        <body>
          <template id="template">
            <p>Smile!</p>
          </template>
          <script>
            let num = 3;
            const fragment = document.getElementById('template').content.cloneNode(true);
            while (num-- > 1) {
              fragment.firstChild.before(fragment.firstChild.cloneNode(true));
              fragment.firstChild.textContent += fragment.lastChild.textContent;
            }
            document.body.appendChild(fragment);
          </script>
        </body>
      </html>
    </xmp>

   The <{p}> element in the <{template}> is <em>not</em> a child of the <{template}> in the DOM;
   it is a child of the {{DocumentFragment}} returned by the <{template}> element's
   <code>content</code> IDL attribute.

   If the script were to call <code>appendChild()</code> on the <{template}> element, that would
   add a child to the <{template}> element (as for any other element); however, doing so is a
   violation of the <{template}> element's content model.
  </div>


  <dl class="domintro">
    <dt><var>template</var> . <code>content</code></dt>

    <dd>Returns the <a>template contents</a> (a {{DocumentFragment}}).</dd>
  </dl>

  Each <{template}> element has an associated {{DocumentFragment}} object that is its
  <dfn>template contents</dfn>. The <a>template contents</a> have
  <a href="#no-browsing-context">no conformance requirements</a>. When a <{template}> element is
  created, the user agent must run the following steps to establish the <a>template contents</a>:

  <ol>
   <li>Let <var>doc</var> be the <{template}> element's <a>node document</a>'s
   <a>appropriate template contents owner document</a>.</li>

   <li>Create a {{DocumentFragment}} object whose <a>node document</a> is <var>doc</var>
   and [=host-concept/host=] is the <{template}> element.</li>

   <li>Set the <{template}> element's <a>template contents</a> to the newly
   created {{DocumentFragment}} object.</li>
  </ol>

  A {{Document}} <var>doc</var>'s <dfn>appropriate template contents owner document</dfn> is the {{Document}} returned by the following algorithm:

  <ol>

    <li>
      If <var>doc</var> is not a {{Document}} created by this algorithm, then:

      <ol>
        <li>
          If <var>doc</var> does not yet have an
          <dfn>associated inert template document</dfn>, then:

          <ol>
            <li>Let <var>new doc</var> be a new {{Document}} (that does not have a
            <a>browsing context</a>). This is "a {{Document}} created by this algorithm"
            for the purposes of the step above.</li>

            <li>If <var>doc</var> is an <a>HTML document</a>, mark <var>new doc</var> as an
            <a>HTML document</a> also.</li>

            <li>Let <var>doc</var>'s <a>associated inert template document</a>
            be <var>new doc</var>.</li>
          </ol>

        </li>

        <li>Set <var>doc</var> to <var>doc</var>'s <a>associated inert template document</a>.</li>
      </ol>

      <p class="note">
        Each <code>Document</code> not created by this algorithm thus gets a single
        <code>Document</code> to act as its proxy for owning the <a>template contents</a> of all
        its <{template}> elements, so that they aren't in a <a>browsing context</a> and
        thus remain inert (e.g., scripts do not run). Meanwhile, <{template}> elements inside
        <code>Document</code> objects that <em>are</em> created by this algorithm just reuse
        the same <code>Document</code> owner for their contents.
      </p>
    </li>

    <li>Return <var>doc</var>.</li>

  </ol>

  The <a>adopting steps</a> (with <var>node</var> and <var>oldDocument</var> as parameters) for
  <{template}> elements are the following:

  <ol>

    <li>
      Let <var>doc</var> be <var>node</var>'s <a>node document</a>'s
      <a>appropriate template contents owner document</a>.

      <p class="note">
        <var>node</var>'s <a>node document</a> is the <code>Document</code> object
        that <var>node</var> was just adopted <em>into</em>.
      </p>
    </li>

    <li><a>Adopt</a> <var>node</var>'s
    <a>template contents</a> (a <code>DocumentFragment</code> object) into <var>doc</var>.</li>

  </ol>

  The <dfn attribute for="HTMLTemplateElement"><code>content</code></dfn> IDL attribute must return
  the <{template}> element's <a>template contents</a>.

  <hr />

  The <a>cloning steps</a> for a <code>template</code> element <var>node</var> being cloned to a
  copy <var>copy</var> must run the following steps:

  <ol>

    <li>If the <var>clone children flag</var> is not set in the calling <a lt="clone a node">clone</a> algorithm, abort these steps.</li>

    <li>Let <var>copied contents</var> be the result of <a lt="clone a node">cloning</a> all the
    children of <var>node</var>'s <a>template contents</a>, with <var>document</var> set to
    <var>copy</var>'s <a>template contents</a>'s <a>node document</a>, and with the
    <var>clone children flag</var> set.</li>

    <li>Append <var>copied contents</var> to <var>copy</var>'s <a>template contents</a>.</li>

  </ol>

  <div class="example">
    In this example, a script populates a table four-column with data from a data structure, using
    a <code>template</code> to provide the element structure instead of manually generating the
    structure from markup.

    <xmp highlight="html">
      <!DOCTYPE html>
      <html lang="en">
      <title>Cat data</title>
      <script>
        // Data is hard-coded here, but could come from the server
        var data = [
          { name: 'Pillar', color: 'Tabby',  sex: 'Female', legs: 3 },
          { name: 'Hedral', color: 'Tuxedo', sex: 'Male',   legs: 4 },
        ];
      </script>
      <table>
        <thead>
          <tr>
            <th>Name</th> <th>Color</th> <th>Sex</th> <th>Legs</th>
          </tr>
        </thead>
        <tbody>
          <template id="row">
            <tr>
              <td></td> <td></td> <td></td> <td></td>
            </tr>
          </template>
        </tbody>
      </table>
      <script>
        var template = document.querySelector('#row');
        for (var i = 0; i < data.length; i += 1) {
          var cat = data[i];
          var clone = template.content.cloneNode(true);
          var cells = clone.querySelectorAll('td');
          cells[0].textContent = cat.name;
          cells[1].textContent = cat.color;
          cells[2].textContent = cat.sex;
          cells[3].textContent = cat.legs;
          template.parentNode.appendChild(clone);
        }
      </script>
    </xmp>

    This example uses <code>cloneNode()</code> on the <code>template</code>'s contents; it could
    equivalently have used <code>document.importNode()</code>, which does the same thing. The only
    difference between these two APIs is when the <a>node document</a> is updated: with
    <code>cloneNode()</code> it is updated when the nodes are appended with
    <code>appendChild()</code>, with <code>document.importNode()</code> it is updated when the
    nodes are cloned.
  </div>

<h5 id="interaction-of-template-elements-with-xslt-and-xpath">Interaction of <{template}> elements with XSLT and XPath</h5>

  <em>This section is non-normative.</em>

  This specification does not define how XSLT and XPath interact with the <code>template</code>
  element. However, in the absence of another specification actually defining this, here are some
  guidelines for implementors, which are intended to be consistent with other processing described
  in this specification:

  <ul>

    <li>An XSLT processor based on an XML parser that acts as described
    in this specification needs to act as if <{template}> elements contain as
    descendants their <a>template contents</a> for the purposes of the transform.</li>

    <li>An XSLT processor that outputs a DOM needs to ensure that nodes that would go into a
    <{template}> element are instead placed into the element's <a>template
    contents</a>.</li>

    <li>XPath evaluation using the XPath DOM API when applied to a <code>Document</code> parsed
    using the <a>HTML parser</a> or the <a>XML parser</a> described in this specification
    needs to ignore <a>template contents</a>.

  </li></ul>

<h4 id="the-canvas-element">The <dfn element><code>canvas</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Embedded content</a>.</dd>
    <dd><a>Palpable content</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>Where <a>embedded content</a> is expected.</dd>
    <dt><a>Content model</a>:</dt>
    <dd><a>Transparent</a>.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><code>width</code> - Horizontal dimension</dd>
    <dd><code>height</code> - Vertical dimension</dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd><a href="#allowed-aria-roles-states-and-properties">Any role value</a>.</dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd><a>Global aria-* attributes</a></dd>
    <dd>Any <code>aria-*</code> attributes
    <a href="#allowed-aria-roles-states-and-properties">applicable to the allowed roles</a>.</dd>

    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl">
        typedef (CanvasRenderingContext2D or WebGLRenderingContext or WebGL2RenderingContext) RenderingContext;

        interface HTMLCanvasElement : HTMLElement {
          attribute unsigned long width;
          attribute unsigned long height;

          RenderingContext? getContext(DOMString contextId, any... arguments);
          boolean probablySupportsContext(DOMString contextId, any... arguments);

          DOMString toDataURL(optional DOMString type, any... arguments);
          void toBlob(BlobCallback _callback, optional DOMString type, any... arguments);
        };

        callback BlobCallback = void (Blob? blob);
      </pre>
    </dd>
  </dl>

  The <{canvas}> element provides scripts with a resolution-dependent bitmap canvas,
  which can be used for rendering graphs, game graphics, art, or other visual images on the fly.

  Authors should not use the <{canvas}> element in a document when a more suitable
  element is available. For example, it is inappropriate to use a <{canvas}> element to
  render a page heading: if the desired presentation of the heading is graphically intense, it
  should be marked up using appropriate elements (typically <code>h1</code>) and then styled using
  CSS and supporting technologies such as Web Components.

  When authors use the <{canvas}> element, they must also provide content that, when presented
  to the user, conveys essentially the same function or purpose as the <{canvas}>'s bitmap.
  This content may be placed as content of the <{canvas}> element. The contents of the <{canvas}>
  element, if any, are the element's  <a>fallback content</a>.

  <hr />

  In interactive visual media, if <a>scripting is enabled</a> for the <{canvas}> element, and if
  support for <{canvas}> elements has been enabled, the <{canvas}> element <a>represents</a>
  <a>embedded content</a> consisting of a dynamically created image, the element's bitmap.

  In non-interactive, static, visual media, if the <{canvas}> element has been
  previously associated with a rendering context (e.g., if the page was viewed in an interactive
  visual medium and is now being printed, or if some script that ran during the page layout process
  painted on the element), then the <{canvas}> element <a>represents</a>
  <a>embedded content</a> with the element's current bitmap and size. Otherwise, the element
  represents its <a>fallback content</a> instead.

  In non-visual media, and in visual media if <a>scripting is disabled</a> for the <{canvas}>
  element or if support for <{canvas}> elements has been disabled, the <{canvas}> element
  <a>represents</a> its <a>fallback content</a> instead.

  When a <{canvas}> element <a>represents</a> <a>embedded content</a>, the user can still focus
  descendants of the <{canvas}> element (in the <a>fallbackcontent</a>). When an element is
  <a>focused</a>, it is the target of keyboard interaction events (even though the element itself
  is not visible). This allows authors to make an interactive canvas keyboard-accessible: authors
  should have a one-to-one mapping of interactive regions to <i>focusable areas</i> in the
  <a>fallback content</a>. (Focus has no effect on mouse interaction events.) [[!UIEVENTS]]

  An element whose nearest <{canvas}> element ancestor is <a>being rendered</a>
  and <a>represents</a> <a>embedded content</a> is an element that is <dfn>being used as
  relevant canvas fallback content</dfn>.

  <hr />

  The <{canvas}> element has two attributes to control the size of the element's bitmap:
  <dfn element-attr for="canvas"><code>width</code></dfn> and
  <dfn element-attr for="canvas"><code>height</code></dfn>. These attributes, when specified,
  must have values that are <a>valid non-negative integers</a>.
  The <a>rules for parsing non-negative integers</a> must be used to obtain their numeric values.
  If an attribute is missing, or if parsing its value returns an error, then the default value
  must be used instead. The <code>width</code> attribute defaults to 300, and the
  <code>height</code> attribute defaults to 150.

  The <a>intrinsic dimensions</a> of the <{canvas}> element when it <a>represents</a>
  <a>embedded content</a> are equal to the dimensions of the element's bitmap.

  The user agent must use a square pixel density consisting of one pixel of image data per
  coordinate space unit for the bitmaps of a <code>canvas</code> and its rendering contexts.

  <p class="note">
    A <{canvas}> element can be sized arbitrarily by a style sheet, its
    bitmap is then subject to the 'object-fit' CSS property. [[!CSS3-IMAGES]]
  </p>


  <hr />

  The bitmaps of <{canvas}> elements, the bitmaps of <code>ImageBitmap</code> objects,
  as well as some of the bitmaps of rendering contexts, such as those described in the section on
  the <code>CanvasRenderingContext2D</code> object below, have an
  <dfn for="canvas">origin-clean</dfn> flag, which can be set to true or false.
  Initially, when the <{canvas}> element or <code>ImageBitmap</code> object is created,
  its bitmap's <a>origin-clean</a> flag must be set to true.

  A <code>canvas</code> bitmap can also have a hit region list, as described in the
  <code>CanvasRenderingContext2D</code> section below.

  A <{canvas}> element can have a rendering context bound to it. Initially, it does not
  have a bound rendering context. To keep track of whether it has a rendering context or not, and
  what kind of rendering context it is, a <code>canvas</code> also has a
  <dfn mode for="canvas" lt="context mode|canvas context mode">canvas context mode</dfn>,
  which is initially <dfn context for="canvas">none</dfn> but can be changed to either
  <dfn context for="canvas">2d</dfn>, <dfn context for="canvas">webgl</dfn>, <dfn context
  for="canvas">webgl2</dfn> by algorithms defined in this specification.

  When its <a mode for="canvas">canvas context mode</a> is <a context for="canvas">none</a>,
  a <{canvas}> element has no rendering context, and its bitmap must be fully transparent black
  with an <a for="css">intrinsic width</a> equal to the numeric value of the element's
  <code>width</code> attribute and an <a for="css">intrinsic height</a> equal to the numeric value
  of the element's <code>height</code> attribute, those values being interpreted in CSS pixels,
  and being updated as the attributes are set, changed, or removed.

  When a <{canvas}> element represents <a>embedded content</a>, it provides
  a <a>paint source</a> whose width is the element's <a for="css">intrinsic width</a>, whose
  height is the element's <a for="css">intrinsic height</a>, and whose appearance is the
  element's bitmap.

  Whenever the <code>width</code> and <code>height</code> content attributes are set, removed,
  changed, or redundantly set to the value they already have, if the
  <a mode for="canvas">canvas context mode</a> is <a context for="canvas">2d</a>, the user agent
  must set bitmap dimensions to the numeric values of the <code>width</code> and
  <code>height</code> content attributes.

  The <dfn attribute for="HTMLCanvasElement"><code>width</code></dfn> and
  <dfn attribute for="HTMLCanvasElement"><code>height</code></dfn> IDL attributes must
  <a>reflect</a> the respective content attributes of the same name, with the same defaults.

  <hr />

  <dl class="domintro">

    <dt><var>context</var> = <var>canvas</var> . <code>getContext</code>(<var>contextId</var> [, ... ] )</dt>

    <dd>

    Returns an object that exposes an API for drawing on the canvas. The first argument specifies
    the desired API. Subsequent arguments are handled by that API.

    Valid contexts are: "<code>2d</code>" [[!CANVAS-2D]] or "<code>webgl</code>" [[!WEBGL-1]]
    or "<code>webgl2</code>" [[!webgl-2]].

    Returns null if the given context ID is not supported or if the canvas has already
    been initialized with some other (incompatible) context type (e.g., trying to get
    a "<code>2d</code>" context after getting a "<code>webgl</code>" context).

    </dd>

    <dt><var>supported</var> = <var>canvas</var> . <code>probablySupportsContext</code>(<var>contextId</var> [, ... ] )</dt>

    <dd>

    Returns false if calling <code>getContext()</code> with the
    same arguments would definitely return null, and true otherwise.

    This return value is not a guarantee that <code>getContext()</code> will or will not return
    an object, as conditions (e.g., availability of system resources) can vary over time.

    </dd>

  </dl>

  The <dfn method for="HTMLCanvasElement"><code>getContext(<var>contextId</var>,
  <var>arguments...</var>)</code></dfn> method of the <{canvas}> element, when invoked,
  must run the steps in the cell of the following table whose column header describes the
  <{canvas}> element's <a mode for="canvas">canvas context mode</a>
  and whose row header describes the method's first argument.

<table class='data'>
   <caption>getContext() invocation steps</caption>
   <thead>
      <tr>
         <td></td>
         <th><a context for="canvas">none</a></th>
         <th><a context for="canvas">2d</a></th>
         <th><a context for="canvas">webgl</a></th>
         <th><a context for="canvas">webgl2</a></th>
      </tr>
   </thead>
   <tbody>
      <tr>
         <th>"<dfn><code>2d</code></dfn>"</th>
         <td>
            Set the <{canvas}> element's <a mode for="canvas">context mode</a> to <a context for="canvas">2d</a>, obtain a
            <code>CanvasRenderingContext2D</code> object as
            defined in the HTML Canvas 2D Context
            specification [[!CANVAS-2D]], set the obtained
            <code>CanvasRenderingContext2D</code> object's
            <a mode for="canvas">context mode</a> to
            <a context for="canvas">2d</a>, and return the
            <code>CanvasRenderingContext2D</code> object
         </td>
         <td>
            Return the same object as was return the last time the method was invoked with this same
            first argument.
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
      </tr>
      <tr>
         <th>"<dfn><code>webgl</code></dfn>", if the user agent supports the WebGL feature in its current configuration</th>
         <td>
            Follow the instructions given in the WebGL specification's <i>Context Creation</i> section to
            obtain either a <code>WebGLRenderingContext</code> or null; if the returned value is null,
            then return null and abort these steps, otherwise, set the <{canvas}> element's <a mode for="canvas">context mode</a> to <a context for="canvas">webgl</a>, set the new
            <code>WebGLRenderingContext</code> object's <a mode for="canvas">context mode</a> to <a context for="canvas">webgl</a>, and return the <code>WebGLRenderingContext</code>
            object‡ [[!WEBGL-1]]
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return the same object as was return the last time the method was invoked with this same
            first argument.
         </td>
         <td>
            Return null
         </td>
      </tr>
      <tr>
         <th>"<dfn><code>webgl2</code></dfn>", if the user agent supports the WebGL2 feature in its current configuration</th>
         <td>
            Follow the instructions given in the WebGL2 specification's <i>Context Creation</i> section to
            obtain either a <code>WebGL2RenderingContext</code> or null; if the returned value is null,
            then return null and abort these steps, otherwise, set the <{canvas}> element's <a mode for="canvas">context mode</a> to <a context for="canvas">webgl2</a>, set the new
            <code>WebGL2RenderingContext</code> object's <a mode for="canvas">context mode</a> to <a context for="canvas">webgl2</a>, and return the <code>WebGL2RenderingContext</code>
            object [[!webgl-2]]
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return the same object as was return the last time the method was invoked with this same
            first argument.
         </td>
      </tr>
      <tr>
         <th>A vendor-specific extension*</th>
         <td>
            Behave as defined for the extension.
         </td>
         <td>
            Behave as defined for the extension.
         </td>
         <td>
            Behave as defined for the extension.
         </td>
         <td>
            Behave as defined for the extension.
         </td>
      </tr>
      <tr>
         <th>An unsupported value†</th>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
      </tr>
   </tbody>
</table>

  <small>* Vendors may define experimental contexts using the syntax
  <code><var>vendorname</var>-<var>context</var></code>, for example, <code>moz-3d</code>.</small>

  <small>† For example, the "<code>webgl</code>" value in the case of a user agent having
  exhausted the graphics hardware's abilities and having no software fallback
  implementation.</small>

  <small>‡ The second (and subsequent) argument(s) to the method, if any, are ignored in all cases
  except this one. See the WebGL specification for details.</small>

  <hr />

  The <dfn method for="HTMLCanvasElement"><code>probablySupportsContext(<var>contextId</var>,
  <var>arguments...</var>)</code></dfn> method of the <{canvas}> element, when invoked, must
  return false if calling <code>getContext()</code> on the same object and with the same arguments
  would definitely return null at this time, and true otherwise.

  <hr />

  </div>

  <dl class="domintro">

    <dt><var>url</var> = <var>canvas</var> . <code>toDataURL</code>( [ <var>type</var>, ... ] )</dt>

    <dd>

    Returns a <a scheme lt="data:"><code>data:</code> URL</a> for the image in the canvas.

    The first argument, if provided, controls the type of the image to be returned (e.g., PNG or
    JPEG). The default is <code>image/png</code>; that type is also used if the given type
    isn't supported. The other arguments are specific to the type, and control the way that the
    image is generated, as given in the table below.

    When trying to use types other than "<code>image/png</code>", authors can check if the image
    was really returned in the requested format by checking to see if the returned string starts
    with one of the exact strings "<code>data:image/png,</code>" or "<code>data:image/png;</code>". If it does, the image is PNG, and thus the requested type was
    not supported. (The one exception to this is if the canvas has either no height or no width, in
    which case the result might simply be "<code>data:,</code>".)

    </dd>

    <dt><var>canvas</var> . <code>toBlob</code>(<var>callback</var> [, <var>type</var>, ... ] )</dt>

    <dd>

    Creates a <code>Blob</code> object representing a file containing the image in the canvas,
    and invokes a callback with a handle to that object.

    The second argument, if provided, controls the type of the image to be returned (e.g., PNG or
    JPEG). The default is <code>image/png</code>; that type is also used if the given type
    isn't supported. The other arguments are specific to the type, and control the way that the
    image is generated, as given in the table below.

    </dd>

  </dl>

  The <dfn method for="HTMLCanvasElement"><code>toDataURL()</code></dfn> method must run the
  following steps:

  <ol>

    <li>If the <{canvas}> element's bitmap's <a>origin-clean</a> flag is set to false, throw a
    "{{SecurityError}}" {{DOMException}} and abort these steps.</li>

    <li>If the <{canvas}> element's bitmap has no pixels (i.e., either its horizontal
    dimension or its vertical dimension is zero) then return the string "<code>data:,</code>" and abort these steps. (This is the shortest <a scheme lt="data:"><code>data:</code> URL</a>; it represents the empty string in a <code>text/plain</code> resource.)</li>

    <li>
      Let <var>file</var> be
      <a>a serialization of the <code>canvas</code> element's bitmap as a file</a>,
      using the method's arguments (if any) as the <var>arguments</var>.
    </li>

    <li>Return a <a scheme lt="data:"><code>data:</code> URL</a> representing
    <var>file</var>. [[!RFC2397]]</li>

  </ol>

  The <dfn method for="HTMLCanvasElement" title="toBlob(_callback, type, arguments)">toBlob(BlobCallback _callback, optional DOMString type, any... arguments)</dfn>
  method must run the following steps:

  <ol>

    <li>If the <{canvas}> element's bitmap's <a>origin-clean</a> flag is set to false, throw a
    "{{SecurityError}}" {{DOMException}} and abort these steps.</li>

    <li>Let <var>callback</var> be the first argument.</li>

    <li>Let <var>arguments</var> be the second and subsequent arguments to the method, if
    any.</li>

    <li>

      If the <{canvas}> element's bitmap has no pixels (i.e., either its horizontal
      dimension or its vertical dimension is zero) then let <var>result</var> be null.

      Otherwise, let <var>result</var> be a <code>Blob</code> object representing
      <a>a serialization of the <code>canvas</code> element's bitmap as a file</a>,
      using <var>arguments</var>. [[!FILEAPI]]

    </li>

    <li>Return, but continue running these steps <a>in parallel</a>.</li>

    <li>
      <a>Queue a task</a> to invoke the <code>BlobCallback</code> <var>callback</var> with
      <var>result</var> as its argument. The <a>task source</a> for this task is the
      <dfn>canvas blob serialization task source</dfn>.
    </li>

  </ol>

<h5 id="color-spaces-and-color-correction">Color spaces and color correction</h5>

  The <code>canvas</code> APIs must only perform color correction in two circumstances:

  <ul>

    <li>When rendering the actual canvas bitmap to the output device.</li>

    <li>
      When images which contain their own gamma correction and color space information are
      rendered onto a bitmap which has an existing color space. The image must be converted to
      to the bitmap's color space. (e.g., using the 2D Context's <code>drawImage()</code>
      method with a <code>HTMLImageElement</code> object).
    </li>

  </ul>

  <p class="note">
    Thus, in the 2D context, colors used to draw shapes onto the canvas will exactly
    match colors obtained through the <code>getImageData()</code> method.
  </p>

  The <code>toDataURL()</code> method must not include color space information in the resources
  they return. Where the output format allows it, the color of pixels in resources created by
  <code>toDataURL()</code> must match those returned by the <code>getImageData()</code> method.

  In user agents that support CSS, the color space used by a <{canvas}> element must
  match the color space used for processing any colors for that element in CSS.

  The gamma correction and color space information of images must be handled in such a way that
  an image rendered directly using an <{img}> element would use the same colors as one
  painted on a <{canvas}> element that is then itself rendered. Furthermore, the rendering
  of images that have no color correction information (such as those returned by the
  <code>toDataURL()</code> method) must be rendered with no color correction.

  <p class="note">
    Thus, in the 2D context, calling the <code>drawImage()</code> method to render the output
    of the <code>toDataURL()</code> method to the canvas, given the appropriate
    dimensions, has no visible effect.
  </p>

<h5 id="serializing-bitmaps-to-a-file">Serializing bitmaps to a file</h5>

  When a user agent is to create
  <dfn lt="a serialization of the canvas element's bitmap as a file|a serialization of the bitmap as a file">a serialization of the bitmap as a file</dfn>,
  optionally with some given <var>arguments</var>, and optionally with a <var>native</var> flag
  set, it must create an image file in the format given by the first value of
  <var>arguments</var>, or, if there are no <var>arguments</var>, in the PNG format. [[!PNG]]

  If the <var>native</var> flag is set, or if the bitmap has one pixel per coordinate space unit,
  then the image file must have the same pixel data (before compression, if applicable) as the
  bitmap, and if the file format used supports encoding resolution metadata, the resolution of that
  bitmap (device pixels per coordinate space units being interpreted as image pixels per CSS pixel)
  must be given as well.

  Otherwise, the image file's pixel data must be the bitmap's pixel data scaled to one image
  pixel per coordinate space unit, and if the file format used supports encoding resolution
  metadata, the resolution must be given as 96dpi (one image pixel per CSS pixel).

  If <var>arguments</var> is not empty, the first value must be interpreted as a <a>MIME type</a>
  giving the format to use. If the type has any parameters, it must be treated as not supported.

  <p class="example">
    For example, the value "<code>image/png</code>" would mean to generate a PNG
    image, the value "<code>image/jpeg</code>" would mean to generate a JPEG image, and the value
    "<code>image/svg+xml</code>" would mean to generate an SVG image (which would require that the
    user agent track how the bitmap was generated, an unlikely, though potentially awesome,
    feature).
  </p>

  User agents must support PNG ("<code>image/png</code>"). User agents may support other types.
  If the user agent does not support the requested type, it must create the file using the PNG
  format. [[!PNG]]

  User agents must <a lt="Converting a string to ASCII lowercase">convert the provided type to ASCII lowercase</a> before establishing if they support that type.

  For image types that do not support an alpha channel, the serialized image must be the bitmap
  image composited onto a solid black background using the source-over operator.

  If the first argument in <var>arguments</var> gives a type corresponding to one of the types
  given in the first column of the following table, and the user agent supports that type, then
  the subsequent arguments, if any, must be treated as described in the second cell of that row.

  <table id="canvas-serialization-arguments">
    <caption>Arguments for serialization methods</caption>
    <thead>
      <tr>
        <th> Type </th>
        <th> Other arguments </th>
        <th> Reference </th>
      </tr>
    </thead>
    <tbody>
      <tr>
      <td> <code>image/jpeg</code> </td>
      <td>
        The second argument, if it is a number in the range 0.0 to 1.0 inclusive, must be treated
        as the desired quality level. If it is not a number or is outside that range, the user
        agent must use its default value, as if the argument had been omitted.
      </td>
      <td> [[!JPEG]] </td>
      </tr>
    </tbody>
  </table>

  For the purposes of these rules, an argument is considered to be a number if it is converted to
  an IDL double value by the rules for handling arguments of type <code>any</code> in the
  Web IDL specification. [[!WEBIDL]]

  Other arguments must be ignored and must not cause the user agent to throw an exception. A
  future version of this specification will probably define other parameters to be passed to these
  methods to allow authors to more carefully control compression settings, image metadata, etc.

<h5 id="security-with-canvas-elements">Security with <{canvas}> elements</h5>

  <em>This section is non-normative.</em>

  <strong>Information leakage</strong> can occur if scripts from one [=concept/origin=] can
  access information (e.g., read pixels) from images from another origin (one that isn't the same).

  To mitigate this, bitmaps used with <{canvas}> elements and <code>ImageBitmap</code>
  objects are defined to have a flag indicating whether they are <a>origin-clean</a>.
  All bitmaps start with their <a>origin-clean</a> set to true. The flag is set to
  false when cross-origin images or fonts are used.

  The <code>toDataURL()</code>, <code>toBlob()</code>, and <code>getImageData()</code>
  methods check the flag and will throw a "{{SecurityError}}" {{DOMException}} rather than
  leak cross-origin data.

  The value of the <a>origin-clean</a> flag is propagated from a source <{canvas}> element's
  bitmap to a new <code>ImageBitmap</code> object by <code>createImageBitmap()</code>.
  Conversely, a destination <{canvas}> element's bitmap will have its <a>origin-clean</a> flags
  set to false by <code>drawImage</code> if the source image is an
  <code>ImageBitmap</code> object whose bitmap has its <a>origin-clean</a> flag set to false.

  The flag can be reset in certain situations; for example, when a
  <code>CanvasRenderingContext2D</code> is bound to a new <{canvas}>, the bitmap is cleared
  and its flag reset.

<h4 id="custom-elements-core-concepts">Custom Elements</h4>

  A <dfn export>custom element</dfn> is an element whose {{constructor}} and
  <code>prototype</code> are defined by the author.
  The author-supplied constructor function is called the
  <dfn export>custom element constructor</dfn>.
  Custom elements have the <a>custom element state</a> "<code>custom</code>".

  <p class="note">
    For the elements whose semantics are described in this specification, or in
    <a>other applicable specifications</a>, {{constructor}} and <a>prototype</a>
    are defined by the user agent.
  </p>

  There are two types of custom elements:
  : <a>autonomous custom Elements</a>
  :: These are entirely author-defined, extending {{HTMLElement}}
  : <a>customized built-in Elements</a>
  :: These extend elements that are already defined. <span class="note">This is typically to inherit some functionality.</span>

<h5 id="sec-autonomous-custom-elements">Autonomous custom elements</h4>

  An <dfn export>autonomous custom element</dfn> is a <a>custom element</a> completely defined by
  the author. It extends {{HTMLElement}}, and its <a>local name</a> is equal to its
  <a for="customElements">name</a>.

  <a>Autonomous custom elements</a> have the following element definition:

  <dl class="element">
    <dt>
      <a>Categories</a>:
    </dt>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Palpable content</a>.</dd>

    <dt>
      <a>Contexts in which this element can be used</a>:
    </dt>
    <dd>
      Where <a>phrasing content</a> is expected.
    </dd>

    <dt>
      <a>Content model</a>:
    </dt>
    <dd>
      <a>Transparent</a>.
    </dd>

    <dt>
      <a>Content attributes</a>:
    </dt>
    <dd>
      <a>Global attributes</a>, except the <{global/is}> attribute
    </dd>

    <dt>
      <a>Allowed ARIA role attribute values</a>:
    </dt>
    <dd>
      <a href="#allowed-aria-roles-states-and-properties">Any role value</a>
    </dd>

    <dt>
      <a>Allowed ARIA state and property attributes</a>:
    </dt>
    <dd><a>Global aria-* attributes</a></dd>
    <dd>
      Any <code>aria-*</code> attributes
      <a href="#allowed-aria-roles-states-and-properties">applicable to the allowed roles</a>.
    </dd>

    <dt>
      <a>DOM interface</a>:
    </dt>
    <dd>
      Supplied by the element's author (inherits from {{HTMLElement}})
    </dd>
  </dl>

  An <a>autonomous custom element</a>'s meaning is defined by its author.
  It <a>represents</a> its children.

  <div class="example">
    To illustrate how to create an <a>autonomous custom element</a>, the following example
    will create the foundation for a custom heading element. The element will have two required
    attributes (<code>level</code> and <code>text</code>) to pass in the heading level and text
    for the heading. The permalink will be created based on the text of the heading.


    Before an author can use a custom element in their markup, a class for the new element must be
    declared by extending {{HTMLElement}} and defining the {{constructor}}. The class always
    starts by calling <code>super()</code> so that the correct prototype chain will be
    established.

    <xmp highlight="javascript">
      class permaHeading extends HTMLElement {
        constructor() {
          super();
          // Element functionality will go here
        }
      }
    </xmp>

    All of the custom element's functionality will be written within the {{constructor}}. It's here
    where the custom element's shadow DOM structure and styling may be defined and attached to
    the custom element's <a>shadow root</a>.

    The basic functionality for the custom element is defined in the following JavaScript. The
    necessary elements for the custom element are created and styling is defined.

    <xmp highlight="javascript">
      class permaHeading extends HTMLElement {
        constructor() {
          super();
          // Create a shadow root
          var shadow = this.attachShadow({mode: 'open'});

          // The custom element will need a heading level
          // and heading text to be complete
          var hLevel = this.getAttribute('level') || '1';
          var hText = this.getAttribute('text') || '';
          var hID = hText.replace(/\s+/g, '-').toLowerCase();

          // Setup wrapping element
          const wrapper = document.createElement('div');
          wrapper.classList.add('ph');

          // Setup the heading
          const heading = document.createElement('h'+ hLevel);
          heading.classList.add('ph__heading');
          heading.id = hID;
          heading.textContent = hText;

          // Setup the link
          const link = document.createElement('a');
          link.classList.add('ph__link');
          link.href = '#' + hID;
          link.setAttribute('aria-label', 'Permalink for ' + hText);
          link.textContent = '§';

          // Add styling to the shadow DOM
          var styles = document.createElement('style');
          styles.textContent = '.ph {' +
            'align-items: center;' +
            'display: flex;' +
          '}' +
          '.ph__heading {' +
            'padding: .25em;' +
          '}' +
          '.ph__link {' +
            'color: #aaa;' +
            'padding: .5em .75em;' +
          '}' +
          '.ph__link:hover, .ph__link:focus {' +
            'background: #111;' +
            'color: #fff;' +
          '}';

          // Attach the created elements to the shadow DOM
          shadow.appendChild(styles);
          shadow.appendChild(wrapper);
          wrapper.appendChild(link);
          wrapper.appendChild(heading);
        }
      }

      // Define the new custom element
      customElements.define('perma-heading', permaHeading);
    </xmp>

    After the custom element has been defined, an author would be able to use the custom element
    in their markup like so:

    <xmp highlight="html">
      <perma-heading level="2" text="Beaches on the east coast"></perma-heading>
    </xmp>
  </div>


 <h5 id="customized-built-in-elements">Customized built-in elements</h5>

  A <dfn export>customized built-in element</dfn> is a <a>custom element</a> that extends an
  existing element.
  A customized built-in element's <a>local name</a> is the name of the element it extends.
  Its <a for="customElements">name</a> is called the <dfn export>is value</dfn>: the value of
  the <{global/is}> attribute when it is used in HTML.

  <div class="example">
    For example a <{button}> has pre-defined interaction behaviour, a <{tr}> already participates
    in the <a>table model</a>, and a <{input/checkbox}> has defined behaviour and participates in
    form submission.

    Since only existing table elements take part in the <a>table model</a>, with other elements
    moved outside the <{table}>, creating a custom element that is part of a <{table}> can only
    be done by customizing a built-in table element.
  </div>

  A <a href="#customized-built-in-element">customized built-in element</a> inherits the semantics
  of the element that it extends.

  A <a>customized built-in element</a> has the same requirements for attributes as the element
  it extends. To add custom attribute-based behavior, use
  [=custom data attributes|data-*=] attributes.

  <p class="note">
    A <a>customized built-in element</a>'s <a>is value</a> is saved on the element when it is
    [=create an element|created=]. This means changing the value of the <{global/is}> attribute
    after the element is [=create an element|created=] does not change the element's behaviour.
  </p>

<h4 id="requirement-for-all-custom-elements">Requirements for all custom elements</h4>

  A <dfn export>valid custom element name</dfn> is a sequence of characters <var>name</var> that
  matches the <a>PotentialCustomElementName</a> production, and is not one of the following:

    <ul class="brief">
      <li><code>annotation-xml</code></li>
      <li><code>color-profile</code></li>
      <li><code>font-face</code></li>
      <li><code>font-face-src</code></li>
      <li><code>font-face-uri</code></li>
      <li><code>font-face-format</code></li>
      <li><code>font-face-name</code></li>
      <li><code>missing-glyph</code></li>
    </ul>

    <p class="note">
      These are all hyphen-containing element names from the <a>applicable specifications</a>:
      <cite>SVG</cite> and <cite>MathML</cite>. [[SVG11]] [[MATHML]]
    </p>
  </li>
</ul>

  The <dfn export><code>PotentialCustomElementName</code></dfn> production is as follows:

  <dl>
    <dt><a>PotentialCustomElementName</a> ::=</code></dt>

    <dd><code>[a-z] (<a>PCENChar</a>)* '-' (<a>PCENChar</a>)*</code></dd>

    <dt><code><dfn>PCENChar</dfn> ::=</code></dt>

    <dd>
      <code>"-" | "." | [0-9] | "_" | [a-z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code>
    </dd>
  </dl>

  This uses the <a>EBNF notation</a> from the <cite>XML</cite> specification. [[!XML]]

  <div class="note">
    These requirements ensure a number of goals for <a>valid custom element names</a>:

    <ul>
      <li>
        They start with a <a>lowercase ASCII letter</a>, ensuring that the HTML parser
        will treat them as tags instead of as text.
      </li>

      <li>
        They do not contain any <a>uppercase ASCII letters</a>, so user agents can always
        treat HTML elements ASCII-case-insensitively.
      </li>

      <li>
        They contain a hyphen, used for namespacing and to ensure forward compatibility.
        No new elements will be added to HTML, SVG, or MathML with names containing a hyphen.
      </li>

      <li>
        They can always be created with {{Document/createElement()}} and
        {{Document/createElementNS()}}, which have more restrictions than the parser.
      </li>

      <li>
        They allow a wide range of names to give maximum flexibility:
        e.g. <code>&lt;x-小山&gt;</code> <code>&lt;math-α&gt;</code> or
        <code>&lt;emotion-😍&gt;</code>.
      </li>
    </ul>
  </div>

  A <dfn export>custom element definition</dfn> describes a <a>custom element</a> and consists of:

  <dl>
    <dt>A <dfn export for="customElements">name</dfn></dt>

    <dd>
      A <a>valid custom element name</a>.
    </dd>

    <dt>A <dfn export for="customElements">local name</dfn></dt>

    <dd>
      For <a>autonomous custom elements</a> this is the same as its
      <a for="customElements">name</a>.
    </dd>
    <dd>
      For <a>customized built-in elements</a> this is the name of the element it extends.
    </dd>

    <dt>A <dfn export for="customElements">constructor</dfn></dt>

    <dd>
      A <a>custom element constructor</a> function.
    </dd>

    <dt>A <dfn>prototype</dfn></dt>

    <dd>A JavaScript object</dd>

    <dt>A list of <dfn export>observed attributes</dfn></dt>

    <dd>
      A <code>sequence&lt;DOMString&gt;</code> that is a list of attribute names.
      When any attribute in that list changes value, the <code>attributeChangedCallback</code>
      <a>custom element reaction</a> is [=enqueue a custom element callback reaction|enqueued=].
    </dd>

    <dt>A collection of <dfn export>lifecycle callbacks</dfn></dt>

    <dd>These callbacks are used to <a>invoke custom element reactions</a></dd>
    <dd>
      The value must be a map, whose four keys are the strings "<code>connectedCallback</code>",
      "<code>disconnectedCallback</code>", "<code>adoptedCallback</code>", and
      "<code>attributeChangedCallback</code>". The values of each key are either a Web IDL
      {{Function!!callback}}, or null. The default value of each entry is null.
    </dd>

    <dt>A <dfn export for="customElements">construction stack</dfn></dt>

    <dd>
      A list, initially empty, that is manipulated by the <a>upgrade an element</a> algorithm
      and the HTML element constructors. Each entry in the list is either an element or an
      <dfn export><i>already constructed</i> marker</dfn>.
    </dd>
  </dl>

  To <dfn export lt="looking up a custom element definition">look up a custom element definition</dfn>,
  given a <var>document</var>, <var>namespace</var>, <var>localName</var>, and <var>is</var>,
  perform the following steps. They will return either a <a>custom element definition</a> or null:

  <ol>
    <li>
      If <var>namespace</var> is not the <a>HTML namespace</a>, return null.
    </li>

    <li>
      If <var>document</var> does not have a <a>browsing context</a>, return null.
    </li>

    <li>
      Let <var>registry</var> be <var>document</var>'s <a>browsing context</a>'s {{Window}}'s
      {{CustomElementRegistry}} object.
    </li>

    <li>
      If there is <a>custom element definition</a> in <var>registry</var> with <a>name</a>
      and <a>local name</a> both equal to <var>localName</var>, return that
      <a>custom element definition</a>.
    </li>

    <li>
      If there is a <a>custom element definition</a> in <var>registry</var> with
      <a>name</a> equal to <var>is</var> and <a>local name</a> equal to <var>localName</var>,
      return that <a>custom element definition</a>.
    </li>

    <li>
      Return null.
    </li>
  </ol>

<h4 id="custom-element-conformance">Requirements for custom element constructors</h4>

  A <a>custom element constructor</a> must meet the following requirements:

  <ul>
    <li>
      A parameter-less call to <code>super()</code> must be the first statement in the
      constructor body. This establishes the correct prototype chain and <code><b>this</b></code>
      value before any further code is run.
    </li>

    <li>
      A <code>return</code> statement must not appear anywhere inside the constructor body,
      unless it is a simple early-return (<code>return</code> or <code>return this</code>).
    </li>

    <li>
      The constructor must not use the {{Document/write()|document.write()}} or
      {{Document/open()|document.open()}} methods.
    </li>

    <li>
      The element's attributes and children must not be inspected.
      In the non-<a>upgrade</a> case none will be present,
      and relying on upgrades makes the element less usable.
    </li>

    <li>
      The element must not gain any attributes or children.
      Doing so violates the expectations of consumers who use the {{Document/createElement()}}
      or {{Document/createElementNS()}}</a></code> methods.
    </li>
  </ul>

  In addition, <a>custom element constructors</a> should implement the following good practices:

  <ul>
    <li>
      Work should be deferred to <code>connectedCallback</code>.
      This especially applies to work involving fetching resources or rendering.
      However, note that <code>connectedCallback</code> can be called more than once,
      so initialization work may need a guard to prevent it from running twice.
    </li>

    <li>
      The constructor should set up initial state and default values, event listeners,
      and possibly a <a>shadow root</a>.
    </li>
  </ul>

  Some of these requirements are checked during [=create an element|element creation=],
  and failing to follow them will result in a custom element that cannot be instantiated
  by the parser or DOM APIs.

<h4 id="sec-the-slot-element">The <dfn element><code>slot</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>Where <a>phrasing content</a> is expected.</dd>
    <dt><a>Content model</a>:</dt>
    <dd><a>Transparent</a></dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><{slot/name}> - the name of the slot created.</dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd>
      <a href="#allowed-aria-roles-states-and-properties">Any role value</a>.
    </dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd>
      Any <code>aria-*</code> attributes
      <a href="#allowed-aria-roles-states-and-properties">applicable to the default or allowed roles</a>.
    </dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl">
      [Exposed=Window, HTMLConstructor]
        interface HTMLSlotElement : HTMLElement {
          [CEReactions] attribute DOMString name;
          sequence&lt;Node&gt; assignedNodes(optional AssignedNodesOptions options);
          sequence&lt;Element&gt; assignedElements(optional AssignedNodesOptions options);
        };

        dictionary AssignedNodesOptions {
          boolean flatten = false;
        };
      </pre>
    </dd>
    <dt>
      DPub Roles:
    </dt>
    <dd>
      Any
    </dd>
  </dl>

  The <{slot}> element creates a named <a>slot</a> within a <a>shadow tree</a>. If it has an
  <a>assigned node</a> it <a>represents</a> that, if not it <a>represents</a> its contents.

  The <dfn element-attr for="slot">name</dfn> attribute's value is a string.
  It <a>represents</a> the name of the <a>slot</a> created in a shadow tree.

  The {{slot/name}} IDL attribute must <a>reflect</a> the <{slot/name}> content attribute.

  <div class="example">
    The following example uses the <{slot}> element with a <{template}> for user profile cards.
    Two <{slot}>s are named, using the <{slot/name}> attribute, the other is unnamed, or anonymous.

    <xmp highlight="html">
      <template id="profile-card">
        <div class="card">
          <slot name="user-name">
            <p>No user name available.</p>
          </slot>
          <slot name="user-email">
            <p>No email provided.</p>
          </slot>
          <!-- an anonymous slot -->
          <slot>
            <p>No details provided.</p>
          </slot>
        </div>
      </template>
    </xmp>

    When using a custom element based on that <{template}>, each slot can be replaced with a
    defined HTML fragment.
    If a child element of the custom element has a <{global/slot}> attribute, that element will
    replace the slot whose <{slot/name}> matches it.
    An element without a <{global/slot}> attribute will be inserted into the anonymous
    <{slot}> element.
    If the browser doesn't support the <code>slot</code> element, or a custom element doesn't
    define replacement content for a slot, the fallback content of that <code>slot</code> in the
    <{template}> will be used.


    <pre highlight="html">
      &lt;user-card>
        &lt;h2 <mark>slot="user-name"</mark>>Violet Ann&lt;/h2>

        &lt;div>
          &lt;p>Enjoys:&lt;/p>
          &lt;ul>
            &lt;li>Reading&lt;/li>
            &lt;li>Sketching&lt;/li>
            &lt;li>Cycling&lt;/li>
          &lt;/ul>
        &lt;/div>

        &lt;-- notice no defined user-email -->
      &lt;/user-card>
    </pre>

    After the browser runs the necessary JavaScript to define the custom element, the content
    defined within the custom element <code>user-card</code> will be inserted into the appropriate
    <{slot}> elements defined within the <{template}>.

    With some CSS styling the example could be rendered like this:

    <img src="./images/rendered-custom-element.jpg" alt="Rendered user-card custom element where the user's name and details are rendered as specified, but as no email was specified, the fallback content from the slot with name='user-email' is rendered.">

  </div>

  <dl class="domintro">
  <dt><var>slot</var> . <code>name</code></dt>
  <dd>Get or set the slot's name.</dd>
  <dt><var>slot</var> . <code>assignedNodes()</code></dt>
  <dd>Returns the slot's <a>assigned nodes</a>.</dd>
  <dt><var>slot</var> . <code>assignedNodes({ flatten: true})</code></dt>
  <dd>Returns the slot's <a>assigned nodes</a>, including those of any <{slot}> elements that are descendants, calculated recursively. If there are not <a>assigned nodes</a> it returns the elements children.</dd>
  <dt><var>slot</var> . <code>assignedElements()</code></dt>
  <dd>Returns the slot's <a>assigned nodes</a> that are <a>Elements</a>.</dd>
  <dt><var>slot</var> . <code>assignedElements({ flatten: true})</code></dt>
  <dd>Returns only the <a>Elements</a> that would be returned by
    <code>assignedNodes({ flatten: true})</code>.</dd>
  </dl>

  The <dfn method for="slot"><code>assignedNodes()</code></dfn>, when invoked on an element
  <var>element</var>, and given <code>options</code> <var>options</var>, must run the
  following algorithm:

  <ol>
    <li>If the <code>flatten</code> member of <var>options</var> is <code>false</code>,
      return the element's <a>assigned nodes</a>.</li>
    <li>otherwise, return the result of
    [=find flattened slotables|finding flattened slottables=] for <var>element</var>.</li>
  </ol>

  The <dfn method for="slot"><code>assignedElements()</code></dfn>, when invoked on an element
  <var>element</var>, and given <code>options</code> <var>options</var>, must run the
  following algorithm:

  <ol>
    <li>Let <var>result</var> be empty.</li>
    <li>If the <code>flatten</code> member of <var>options</var> is <code>false</code>,
      set <var>result</var> to the element's <a>assigned nodes</a>.</li>
    <li>otherwise, set <var>result</var> to the result of
     [=find flattened slotables|finding flattened slottables=] for <var>element</var>.</li>
    <li>Remove all <a>nodes</a> from <var>result</var> that are not <a>elements</a>.</li>
    <li>Return <var>result</var>.</li>
  </ol>

</section>
