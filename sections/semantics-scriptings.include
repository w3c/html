<section>

<!--

    Scripting

  This source produces section 4.12: Scripting
  https://w3c.github.io/html/semantics-scripting.html

  It covers:
  - Introduction to scripts and the following elements
  - script
  - noscript
  - template
  - canvas

-->

<h3 id="semantics-scripting">Scripting</h3>

  Scripts allow authors to add interactivity to their documents.

  Authors are encouraged to use declarative alternatives to scripting where possible, as
  declarative mechanisms are often more maintainable, and many users disable scripting.

  <div class="example">
    For example, instead of using script to show or hide a section to show more details, the
    <{details}> element could be used.

  </div>

  Authors are also encouraged to make their applications degrade gracefully in the absence of
  scripting support.

  <div class="example">
    For example, if an author provides a link in a table header to dynamically resort the table,
    the link could also be made to function without scripts by requesting the sorted table from the
    server.

  </div>

<h4 id="the-script-element">The <dfn element><code>script</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Script-supporting element</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>Where <a>metadata content</a> is expected.</dd>
    <dd>Where <a>phrasing content</a> is expected.</dd>
    <dd>Where <a>script-supporting elements</a> are expected.</dd>
    <dt><a>Content model</a>:</dt>
    <dd>If there is no <code>src</code>
    attribute, depends on the value of the <code>type</code> attribute, but must match
    <a>script content restrictions</a>.</dd>
    <dd>If there <em>is</em> a <code>src</code>
    attribute, the element must be either empty or contain only
    <a>script documentation</a> that also matches <a>script
    content restrictions</a>.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><{script/src}> - Address of the resource</dd>
    <dd><{script/type}> - Type of embedded resource</dd>
    <dd><{script/charset}> - Character encoding of the external script resource</dd>
    <dd><{script/async}> - Execute script <a>in parallel</a></dd>
    <dd><{script/defer}> - Defer script execution</dd>
    <dd><{script/crossorigin}> - How the element handles crossorigin requests</dd>
    <dd><{script/integrity}> -  Integrity metadata used in <em>Subresource Integrity</em> checks [[!SRI]]</dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd>None</dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd>None</dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl">
        interface HTMLScriptElement : HTMLElement {
          attribute DOMString src;
          attribute DOMString type;
          attribute DOMString charset;
          attribute boolean async;
          attribute boolean defer;
          attribute DOMString? crossOrigin;
          attribute DOMString text;
          attribute DOMString nonce;
        };
      </pre>
    </dd>
  </dl>

  The <{script}> element allows authors to include dynamic script and data blocks in
  their documents. The element does not <a>represent</a> content for the
  user.

  The <dfn element-attr for="script"><code>type</code></dfn> attribute allows customization of the
  type of script represented:

  * Omitting the attribute, or setting it to a <a>JavaScript MIME type</a>, means that the script is
     a <a>classic script</a>, to be interpreted according to the JavaScript <a for="ecma">Script</a>
     top-level production. Classic scripts are affected by the <{script/charset}>, <{script/async}>,
     and <{script/defer}> attributes. Authors should omit the attribute, instead of redundantly
     giving a <a>JavaScript MIME type</a>.
  * Setting the attribute to an <a>ASCII case-insensitive</a> match for the string
     "<code>module</code>" means that the script is a <a>module script</a>, to be interpreted
     according to the JavaScript <a>Module</a> top-level production. Module scripts are
     not affected by the <{script/charset}> and <{script/defer}> attributes.
  * Setting the attribute to any other value means that the script is a
     <dfn lt="data block|data blocks">data block</dfn>, which is not processed. None of the
     <{script}> attributes (except <{script/type}> itself) have any effect on <a>data blocks</a>.
     Authors must use a <a>valid MIME type</a> that is not a <a>JavaScript MIME type</a> to denote
     <a>data blocks</a>.

  <p class="note">The requirement that <a>data blocks</a> must be denoted using a
  <a>valid MIME type</a> is in place to avoid potential future collisions. If this specification
  ever adds additional types of [=concept/script=], they will be triggered by setting the
  <{script/type}> attribute to something which is not a MIME type, like how the "<code>module</code>"
  value denotes <a>module scripts</a>. By using a valid MIME type now, you ensure that your data block
  will not ever be reinterpreted as a different script type, even in future user agents.</p>

  <a>Classic scripts</a> and <a>module scripts</a> may either be embedded inline or may be imported
  from an external file using the <dfn element-attr for="script"><code>src</code></dfn> attribute,
  which if specified gives the [=url/URL=] of the external script resource to use. If <{script/src}>
  is specified, it must be a <a>valid non-empty URL potentially surrounded by spaces</a>. The
  contents of inline <{script}> elements, or the external script resource, must conform with the
  requirements of the JavaScript specification's <a for="ecma">Script</a> or
  <a>Module</a> productions, for <a>classic scripts</a> and <a>module scripts</a>
  respectively. [[ECMA-262]]

  When used to include <a>data blocks</a>, the data must be embedded inline, the format of the data
  must be given using the <{script/type}> attribute, and the contents of the <{script}> element must
  conform to the requirements defined for the format used. The <{script/src}>, <{script/charset}>,
  <{script/async}>, <{script/defer}>, <{script/crossorigin}>, and <{script/integrity}> attributes must
  not be specified.

  The <dfn element-attr for="script"><code>async</code></dfn> and
  <dfn element-attr for="script"><code>defer</code></dfn> attributes are <a>boolean attributes</a>
  that indicate how a script should be loaded and executed.
  They have no effect, and must not be used, on <{script}> elements that do not have a <{script/src}> attribute specified.
  <a>Classic scripts</a> may specify either or both of <{script/defer}> and <{script/async}>;
  <a>module scripts</a> may specify <{script/async}>.

  There are several possible modes that can be selected using these attributes, and depending on the
  script's <{script/type}>.

  If a <{script/defer}> attribute is present, then a classic script will be fetched <a>in parallel</a>
  to parsing, and only evaluated when parsing is complete. The attribute has no effect on module scripts
  or data blocks.

  If the <{script/async}> attribute is present, then a classic or module script will be fetched
  <a>in parallel</a> to parsing. A module script will be evaluated as soon as it is available,
  (potentially before parsing completes), as will a classic script unless a <{script/defer}> attribute is present.

  If neither attribute is present, the script is fetched and evaluated immediately, blocking parsing until these are
  both complete.

  <!--This is summarized in the following schematic diagram:

  <img src="images/asyncdefer.svg" style="width: 80%; min-width: 690px;"
  alt="With &lt;script>, parsing is interrupted by fetching and execution.
  With &lt;script defer>, fetching is parallel to parsing and execution takes place after all parsing has finished.
  And with &lt;script async>, fetching is parallel to parsing but once it finishes parsing is interrupted to execute the script.
  The story for &lt;script type=&quot;module&quot;> is similar to &lt;script defer>, but the dependencies will be fetched as well,
  and the story for &lt;script type=&quot;module&quot; async> is similar to &lt;script async> with the extra dependency fetching." /-->

  <p class="note">
    The exact processing details for these attributes are, for mostly historical
  reasons, somewhat non-trivial, involving a number of aspects of HTML. The implementation
  requirements are therefore by necessity scattered throughout the specification. The algorithms
  below (in this section) describe the core of this processing, but these algorithms reference and
  are referenced by the parsing rules for <{script}> [=start tag|start=] and
  [=end tag|end=] tags in HTML, <a>in foreign content</a>, and in XML, the rules for the
  {{Document/write()|document.write()}} method, the handling of
  <a for="concept">scripting</a>, etc.</p>

  The <{script/defer}> attribute may be specified even if the <{script/async}> attribute is
  specified, to cause legacy Web browsers that only support <{script/defer}> (and not
  <{script/async}>) to fall back to the <{script/defer}> behavior instead of the blocking behavior
  that is the default.

  The <dfn element-attr for="script"><code>crossorigin</code></dfn> attribute is a
  <a>CORS settings attribute</a>. For <a>classic scripts</a>, it controls whether error information
  will be exposed, when the script is obtained from other <a for="concept">origins</a>. For
  <a>module scripts</a>, it controls the <a>credentials mode</a> used for cross-origin requests.

  <p class="note">Unlike <a>classic scripts</a>, <a>module scripts</a> require the use of the
  <a>CORS protocol</a> for cross-origin fetching.</p>

  Changing the <{script/src}>, <{script/type}>, <{script/charset}>, <{script/async}>,
  <{script/defer}>, <{script/crossorigin}>, and <{script/integrity}> attributes dynamically has no
  direct effect; these attributes are only used at specific times described below.

  The IDL attributes
  <dfn attribute for="HTMLScriptElement"><code>src</code></dfn>,
  <dfn attribute for="HTMLScriptElement"><code>type</code></dfn>,
  <dfn attribute for="HTMLScriptElement"><code>defer</code></dfn>, and
  <dfn attribute for="HTMLScriptElement"><code>integrity</code></dfn>, must each <a>reflect</a> the
  respective content attributes of the same name.

  The <dfn attribute for="HTMLScriptElement"><code>crossOrigin</code></dfn> IDL attribute must
  <a>reflect</a> the <{script/crossorigin}> content attribute.

  The <dfn attribute for="HTMLScriptElement"><code>async</code></dfn> IDL attribute controls whether
  the element will execute <a>in parallel</a> or not. If the element's "[=non-blocking=]" flag is
  set, then, on getting, the {{HTMLScriptElement/async}} IDL attribute must return true, and on
  setting, the "[=non-blocking=]" flag must first be unset, and then the content attribute must
  be removed if the IDL attribute's new value is false, and must be set to the empty string if the
  IDL attribute's new value is true. If the element's "[=non-blocking=]" flag is <em>not</em>
  set, the IDL attribute must <a>reflect</a> the <{script/async}> content attribute.

  <dl class="domintro">

    <dt><var>script</var> . {{HTMLScriptElement/text}} [ = <var>value</var> ]</dt>
    <dd>Returns the <a>child text content</a> of the element.

    Can be set, to replace the element's children with the given value.
    </dd>
  </dl>

  The IDL attribute <dfn attribute for="HTMLScriptElement"><code>text</code></dfn> must return the
  <a>child text content</a> of the <{script}> element. On setting, it must act the same way as the
  {{Node/textContent}} IDL attribute.

  <p class="note">When inserted using the {{Document/write()|document.write()}}
  method, <{script}> elements execute (typically blocking further script execution or HTML parsing),
  but when inserted using <code>innerHTML</code> and <code>outerHTML</code> attributes, they do not
  execute at all.</p>

  <div class="example">
    In this example, two <{script}> elements are used. One embeds an external <a>classic script</a>,
    and the other includes some data as a <a>data block</a>.

    <xmp highlight="html">
      <script src="game-engine.js"></script>
      <script type="text/x-game-map">
      ........U.........e
      o............A....e
      .....A.....AAA....e
      .A..AAA...AAAAA...e
      </script>
    </xmp>

    The data in this case might be used by the script to generate the map of a video game. The
    data doesn't have to be used that way, though; maybe the map data is actually embedded in other
    parts of the page's markup, and the data block here is just used by the site's search engine to
    help users who are looking for particular features in their game maps.
  </div>

  <div class="example">
    The following sample shows how a <{script}> element can be used to define a function that is
    then used by other parts of the document, as part of a <a>classic script</a>. It also shows how
    a <{script}> element can be used to invoke script while the document is being parsed, in this
    case to initialize the form's output.

    <xmp highlight="html">
      <script>
        function calculate(form) {
          var price = 52000;
          if (form.elements.brakes.checked)
            price += 1000;
          if (form.elements.radio.checked)
            price += 2500;
          if (form.elements.turbo.checked)
            price += 5000;
          if (form.elements.sticker.checked)
            price += 250;
          form.elements.result.value = price;
        }
      </script>
      <form name="pricecalc" onsubmit="return false" onchange="calculate(this)">
        <fieldset>
          <legend>Work out the price of your car</legend>
          <p>Base cost: £52000.</p>
          <p>Select additional options:</p>
          <ul>
            <li><label><input type="checkbox" name="brakes"> Ceramic brakes (£1000)</label></li>
            <li><label><input type="checkbox" name="radio"> Satellite radio (£2500)</label></li>
            <li><label><input type="checkbox" name="turbo"> Turbo charger (£5000)</label></li>
            <li><label><input type="checkbox" name="sticker"> "XZ" sticker (£250)</label></li>
          </ul>
          <p>Total: £<output name="result"></output></p>
        </fieldset>
        <script>
          calculate(document.forms.pricecalc);
        </script>
      </form>
    </xmp>
  </div>

  <div class="example">
    The following sample shows how a <{script}> element can be used to include an external
    <a>module script</a>.

    <xmp highlight="html">
      <script type="module" src="app.js"></script>
    </xmp>

    This module, and all its dependencies (expressed through JavaScript `import` statements in the
    source file), will be fetched. Once the entire resulting module tree has been imported, and the
    document has finished parsing, the contents of `app.js` will be evaluated.
  </div>

  <div class="example">
    The following sample shows how a <{script}> element can be used to write an inline
    <a>module script</a> that performs a number of substitutions on the document's text, in order to
    make for a more interesting reading experience (e.g. on a news site): [[XKCD-1288]]

    <xmp highlight="html">
      <script type="module">
       import { walkAllTextNodeDescendants } from "./dom-utils.js";

       const substitutions = new Map([
         ["witnesses", "these dudes I know"]
         ["allegedly", "kinda probably"]
         ["new study", "Tumblr post"]
         ["rebuild", "avenge"]
         ["space", "spaaace"]
         ["Google glass", "Virtual Boy"]
         ["smartphone", "Pokédex"]
         ["electric", "atomic"]
         ["Senator", "Elf-Lord"]
         ["car", "cat"]
         ["election", "eating contest"]
         ["Congressional leaders", "river spirits"]
         ["homeland security", "Homestar Runner"]
         ["could not be reached for comment", "is guilty and everyone knows it"]
       ]);

       function substitute(textNode) {
         for (const [before, after] of substitutions.entries()) {
           textNode.data = textNode.data.replace(new RegExp('\\b${before}\\b', "ig"), after);
         }
       }

       walkAllTextNodeDescendants(document.body, substitute);
      </script>
    </xmp>

    Some notable features gained by using a <a>module script</a> include the ability to import
    functions from other JavaScript modules, strict mode by default, and how top-level declarations
    do not introduce new properties onto the <a>global object</a>. Also note that no matter where
    this <{script}> element appears in the document, it will not be evaluated until both document
    parsing has complete and its dependency (`dom-utils.js`) has been fetched and evaluated.
  </div>

  <h5 id="script-processing-model">Processing model</h5>

  A <{script}> element has several associated pieces of state.

  The first is a flag indicating whether or not the script block has been
  "<dfn>already started</dfn>". Initially, <{script}> elements must have this flag unset (script
  blocks, when created, are not "already started"). The <a>cloning steps</a> for <{script}> elements
  must set the "already started" flag on the copy if it is set on the element being cloned.

  The second is a flag indicating whether the element was "<dfn>parser-inserted</dfn>".
  Initially, <{script}> elements must have this flag unset. It is set by the <a>HTML parser</a>
  and the <a>XML parser</a> on <{script}> elements they insert and affects the processing of those
  elements.

  The third is a flag indicating whether the element will "<dfn>non-blocking</dfn>". Initially,
  <{script}> elements must have this flag set. It is unset by the <a>HTML parser</a>
  and the <a>XML parser</a> on <{script}> elements they insert. In addition, whenever
  a <{script}> element whose "[=non-blocking=]" flag is set has an <{script/async}> content
  attribute added, the element's "[=non-blocking=]" flag must be unset.

  The fourth is a flag indicating whether or not the script block is
  "<dfn>ready to be parser-executed</dfn>". Initially, <{script}> elements must have this flag unset
  (script blocks, when created, are not "ready to be parser-executed"). This flag is used only for
  elements that are also "[=parser-inserted=]", to let the parser know when to execute the
  script.

  The fifth is <dfn>the script's type</dfn>, which is either "<code>classic</code>" or
  "<code>module</code>". It is determined when the script is <a>prepared</a>, based on the
  <{script/type}> attribute of the element at that time. Initially, <{script}> elements must have
  this flag unset.

  The sixth is a flag indicating whether or not the script is <dfn>from an external file</dfn>. It
  is determined when the script is <a>prepared</a>, based on the <{script/src}> attribute of the
  element at that time.

  Finally, a <{script}> element has <dfn>the script's script</dfn>, which is a
  <{script}> resulting from <a>preparing</a> the element. This is set asynchronously after the
  <a>classic script</a> or module tree is fetched. Once it is set, either to a <{script}> in the
  case of success or to null in the case of failure, the fetching algorithms will note that
  <dfn>the script is ready</dfn>, which can trigger other actions. The user agent must
  <a>delay the load event</a> of the element's <a>node document</a> until
  <a>the script is ready</a>.

  When a <{script}> element that is not marked as being "[=parser-inserted=]" experiences one of
  the events listed in the following list, the user agent must <a>immediately</a> <a>prepare</a> the
  <{script}> element:

  * The <{script}> element gets <a for="document">inserted into a document</a>, at the time the node
     is inserted according to the DOM, after any other <{script}> elements inserted at the same time
     that are earlier in the <code>Document</code> in <a>tree order</a>.
  * The <{script}> element is <a>in a <code>Document</code></a> and a node or document fragment is
     <a>inserted</a> into the <{script}> element, after any <{script}> elements <a>inserted</a> at
     that time.
  * The <{script}> element is <a>in a <code>Document</code></a> and has a <code>src</code> attribute
     set where previously the element had no such attribute.

  To <dfn lt="prepare a script|preparing|prepared">prepare a script</dfn>, the user agent must act
  as follows:

  1. If the <{script}> element is marked as having "[=already started=]", then the user agent
      must abort these steps at this point. The script is not executed.
  2. If the element has its "[=parser-inserted=]" flag set, then set
      <var>was-parser-inserted</var> to true and unset the element's "[=parser-inserted=]" flag.
      Otherwise, set <var>was-parser-inserted</var> to false.

      <p class="note">This is done so that if parser-inserted <{script}> elements fail to run when
      the parser tries to run them, e.g., because they are empty or specify an unsupported
      scripting language, another script can later mutate them and cause them to run again.</p>
  3. If <var>was-parser-inserted</var> is true and the element does not have an <{script/async}>
      attribute, then set the element's "[=non-blocking=]" flag to true.

      <p class="note">This is done so that if a parser-inserted <{script}> element fails to run when
      the parser tries to run it, but it is later executed after a script dynamically updates it, it
      will execute in a non-blocking fashion even if the <{script/async}> attribute isn't set.</p>
  4. If the element has no <{script/src}> attribute, and its child nodes, if any, consist only of
      comment nodes and empty {{Text}} nodes, then abort these steps at this point. The script is
      not executed.
  5. If the element is not <a>in a <code>Document</code></a>, then the user agent must abort these
      steps at this point. The script is not executed.
  6. If either:

      * the <{script}> element has a <{script/type}> attribute and its value is the empty string, or
      * the <{script}> element has no <{script/type}> attribute but it has a <{script/language}>
         attribute and <em>that</em> attribute's value is the empty string, or
      * the <{script}> element has neither a <{script/type}> attribute nor a <{script/language}>
         attribute, then

      ...let <var>the script block's type string</var> for this <{script}> element be
      "`text/javascript`".

      Otherwise, if the <{script}> element has a <{script/type}> attribute, let
      <var>the script block's type string</var> for this <{script}> element be the value of that
      attribute after <a>stripping leading and trailing white space</a>.

      Otherwise, the element has a non-empty <{script/language}> attribute; let
      <var>the script block's type string</var> for this <{script}> element be the
      concatenation of the string "<code>text/</code>" followed by the value of the <{script/language}> attribute.

      <p class="note">The <{script/language}> attribute is never conforming, and is always ignored
      if there is a <{script/type}> attribute present.</p>

      Determine <a>the script's type</a> as follows:

      * If <var>the script block's type string</var> is an <a>ASCII case-insensitive</a> match for
         any <a>JavaScript MIME type</a>, <a>the script's type</a> is "<code>classic</code>".
      * If <var>the script block's type string</var> is an <a>ASCII case-insensitive</a> match for
         the string "<code>module</code>", <a>the script's type</a> is "<code>module</code>".
      * If neither of the above conditions are true, then abort these steps at this point. No script
         is executed.
  7. If <var>was-parser-inserted</var> is true, then flag the element as "[=parser-inserted=]"
      again, and set the element's "[=non-blocking=]" flag to false.
  8. The user agent must set the element's "[=already started=]" flag.
  9. If the element is flagged as "[=parser-inserted=]", but the element's <a>node document</a>
      is not the {{Document}} of the parser that created the element, then abort these steps.
  10. If <a>scripting is disabled</a> for the <{script}> element, then abort these steps at this
       point. The script is not executed.

       <p class="note">The definition of <a>scripting is disabled</a> means that, amongst others,
       the following scripts will not execute: scripts in {{XMLHttpRequest}}'s
       {{XMLHttpRequest/responseXML}} documents, scripts in {{DOMParser}}-created documents, scripts
       in documents created by <code>XSLTProcessor</code>'s <code>transformToDocument</code>
       feature, and scripts that are first inserted by a script into a {{Document}} that was created
       using the {{DOMImplementation/createDocument()}} API. [[!XHR]] [[!DOM-PARSING]] [[XSLTP]]
       [[!DOM]]</p>
  11. If the <{script}> element does not have a <{script/src}> content attribute, and the
       <a>Should element's inline behavior be blocked by Content Security Policy?</a> algorithm
       returns "<code>Blocked</code>" when executed upon the <{script}> element, "<code>script</code>", and the <{script}>
       element's <a>child text content</a>, then abort these steps. The script is not executed.
       [[CSP3]]
  12. If the <{script}> element has an <{script/event}> attribute and a <{script/for}> attribute,
       and <a>the script's type</a> is "<code>classic</code>", then run these substeps:

       1. Let <var>for</var> be the value of the <{script/for}> attribute.
       2. Let <var>event</var> be the value of the <{script/event}> attribute.
       3. <a>Strip leading and trailing white space</a> from <var>event</var> and <var>for</var>.
       4. If <var>for</var> is not an <a>ASCII case-insensitive</a> match for the string "<code>window</code>",
           then the user agent must abort these steps at this point. The script is not executed.
       5. If <var>event</var> is not an <a>ASCII case-insensitive</a> match for either the string
           "<code>onload</code>" or the string "`onload()`", then the user agent must abort these steps at this
           point. The script is not executed.
  13. If the <{script}> element has a <{script/charset}> attribute, then let <var>encoding</var> be
       the result of <a>getting an encoding</a> from the value of the <{script/charset}> attribute.

       If the <{script}> element does not have a <{script/charset}> attribute, or if
       <a>getting an encoding</a> failed, let <var>encoding</var> be the same as
       <a lt="encoding">the encoding of the document itself</a>.

       <p class="note">If <a>the script's type</a> is "<code>module</code>", this encoding will be
       ignored.</p>
  14. Let <var>CORS setting</var> be the current state of the element's <{script/crossorigin}>
       content attribute.
  15. <p>Let <var>cryptographic nonce</var> be the element's <a href="#cryptographicnonce">[[<span>CryptographicNonce</span>]]</a>
       internal slot's value.
  16. If the <{script}> element has an <{script/integrity}> attribute, then let <var>integrity metadata</var> be that attribute's value.
      Otherwise, let <var>integrity metadata</var> be the empty string.
  17. Let <var>parser metadata</var> be "<code>parser-inserted</code>" if the <{script}> element has been flagged
       as "[=parser-inserted=]", and "`not parser-inserted`" otherwise.
  18. Let options be a set of <a>script fetch options</a> whose <a>cryptographic nonce metadata</a> is 
       cryptographic nonce, <a>integrity metadata</a> is integrity metadata, 
       <a>parser metadata</a> is <var>parser metadata</var>, <a>credentials mode</a> is module 
       script credentials mode, and <a>referrer policy</a> is the empty string.
  19. Let <var>settings</var> be the element's <a>node document</a>'s {{Window}} object's
       <a>environment settings object</a>.
  20. If the element has a <{script/src}> content attribute, run these substeps:

       1. Let <var>src</var> be the value of the element's <{script/src}> attribute.
       2. If <var>src</var> is the empty string, <a>queue a task</a> to <a>fire a simple event</a>
           named <code>error</code> at the element, and abort these steps.
       3. Set the element's <a>from an external file</a> flag.
       4. <a>Parse</a> <var>src</var> relative to the element's <a>node document</a>.
       5. If the previous step failed, <a>queue a task</a> to <a>fire a simple event</a> named
           <code>error</code> at the element, and abort these steps.

           Otherwise, let <var>url</var> be the <a>resulting URL record</a>.
       6. Switch on <a>the script's type</a>:
           <dl class="switch">
             <dt>`"classic"`</dt>
             <dd><a>Fetch a classic script</a> given <var>url</var>, <var>settings object</var>,
             <var>options</var>, <var ignore=''>classic script CORS setting</var>, and
             <var>encoding</var>.

             <dt><code>"module"</code></dt>
             <dd><a>Fetch a module script tree</a> given <var>url</var>,
                       <var>settings object</var>, "<code>script</code>", and <var>options</var>.
             </dd>
           </dl>
           When the chosen algorithm asynchronously completes, set <a>the script's script</a> to the
           result. At that time, <a>the script is ready</a>.

           For performance reasons, user agents may start fetching the classic script or module tree
           (as defined above) as soon as the <{script/src}> attribute is set, instead, in the hope that the
           element will be <a for="document">inserted into the document</a> (and that the
           <{script/crossorigin}> attribute won't change value in the meantime). Either way, once
           the element is <a for="document">inserted into the document</a>, the load must have
           started as described in this step. If the UA performs such prefetching, but the element
           is never inserted in the document, or the <{script/src}> attribute is dynamically
           changed, or the <{script/crossorigin}> attribute is dynamically changed, then the user
           agent will not execute the script so obtained, and the fetching process will have been
           effectively wasted.
  21. If the element does not have a <{script/src}> content attribute, run these substeps:

       1. Let <var>source text</var> be the <{script}> element's <a>child text content</a>.
       2. Let <var>base URL</var> be the <{script}> element's <a>node document</a>'s <a>document base URL</a>.
       3. Switch on <a>the script's type</a>:
           <dl class="switch">
             <dt>`"classic"`</dt>
             <dd>
                  1. Let <var>script</var> be the result of <a>creating a classic script</a> using
                      <var>source text</var>, <var>settings object</var>, <var>base URL</var> and <var>options</var>.
                  2. Set <a>the script's script</a> to <var>script</var>.
                  3. <a>The script is ready</a>.
             </dd>

             <dt><code>"module"</code></dt>
             <dd>
                  1. Let <var>script</var> be the result of <a>creating a module script</a> using
                      <var>source text</var>, <var>settings object</var>, <var>base URL</var>, and
                      <var>options</var>.
                  2. If this returns null, set <a>the script's script</a> to null and abort these
                      substeps; <a>the script is ready</a>.
                  3. <a>Fetch the descendants</a> of and instantiate script, given the destination "<var>script</var>". When this asynchronously
                      completes, set <a>the script's script</a> to the result. At that time,
                      <a>the script is ready</a>.
             </dd>
           </dl>
  22. Then, follow the first of the following options that describes the situation:
       <dl class="switch">
         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td>`"classic"`
               <td>yes
               <td>yes
               <td>no
               <td>element flagged as "[=parser-inserted=]"
             </tr>
             <tr>
               <td><code>"module"</code>
               <td>yes or no
               <td>n/a
               <td>no
               <td>element flagged as "[=parser-inserted=]"
             </tr>
           </tbody>
         </table>
         Add the element to the end of the <dfn>list of scripts that will execute when the
         document has finished parsing</dfn> associated with the {{Document}} of the parser that
         created the element.

         When the <a>the script is ready</a>, set the element's "[=ready to be parser-executed=]"
         flag. The parser will handle executing the script.</dd>

         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td>`"classic"`
               <td>yes
               <td>no
               <td>no
               <td>element flagged as "[=parser-inserted=]"
             </tr>
           </tbody>
         </table>
         The element is the <a>pending parsing-blocking script</a> of the {{Document}} of the
         parser that created the element. (There can only be one such script per {{Document}} at a
         time.)

         When <a>the script is ready</a>, set the element's "[=ready to be parser-executed=]"
         flag. The parser will handle executing the script.
         </dd>

         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td>`"classic"`
               <td>yes
               <td>yes or no
               <td>no
               <td>"[=non-blocking=]" flag not set on element
             </tr>
             <tr>
               <td><code>"module"</code>
               <td>yes or no
               <td>n/a
               <td>no
               <td>"[=non-blocking=]" flag not set on element
             </tr>
           </tbody>
         </table>
         Add the element to the end of the <dfn>list of scripts that will execute in order
         as soon as possible</dfn> associated with the <a>node document</a> of the <{script}>
         element at the time the <a>prepare a script</a> algorithm started.

         When <a>the script is ready</a>, run the following steps:

         1. If the element is not now the first element in the
             <a>list of scripts that will execute in order as soon as possible</a> to which it was
             added above, then mark the element as ready but abort these steps without executing the
             script yet.
         2. <var>Execution</var>: <a>Execute the script block</a> corresponding to the first script
             element in this <a>list of scripts that will execute in order as soon as possible</a>.
         3. Remove the first element from this
             <a>list of scripts that will execute in order as soon as possible</a>.
         4. If this <a>list of scripts that will execute in order as soon as possible</a> is still
             not empty and the first entry has already been marked as ready, then jump back to the
             step labeled <var>Execution</var>.

         </dd>

         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td>`"classic"`
               <td>yes
               <td>yes or no
               <td>yes or no
               <td>n/a
             </tr>
             <tr>
               <td><code>"module"</code>
               <td>yes or no
               <td>n/a
               <td>yes or no
               <td>n/a
             </tr>
           </tbody>
         </table>
         The element must be added to the
         <dfn>set of scripts that will execute as soon as possible</dfn> of the <a>node document</a>
         of the <{script}> element at the time the <a>prepare a script</a> algorithm started.

         When <a>the script is ready</a>, <a>execute the script block</a> and then remove the
         element from the <a>set of scripts that will execute as soon as possible</a>.</dd>

         <dt></dt>
         <dd>
         <table>
           <thead>
             <tr>
               <th><a>the script's type</a>
               <th><{script/src}> present?
               <th><{script/defer}> present?
               <th><{script/async}> present?
               <th>other conditions
             </tr>
           </thead>
           <tbody>
             <tr>
               <td><code>"classic"</code> or <code>"module"</code>
               <td>no
               <td>yes or no
               <td>yes or no
               <td>All of the following:

                    * element flagged as "[=parser-inserted=]"
                    * an <a>XML parser</a> or an <a>HTML parser</a> whose
                        <a>script nesting level</a> is not greater than one created the <{script}>
                    * the {{Document}} of the <a>XML parser</a> or <a>HTML parser</a> that created
                        the <{script}> <a>has a style sheet that is blocking scripts</a>
             </tr>
           </tbody>
         </table>
         The element is the <a>pending parsing-blocking script</a> of the {{Document}} of the
         parser that created the element. (There can only be one such script per {{Document}} at a
         time.)

         Set the element's "[=ready to be parser-executed=]" flag. The parser will handle
         executing the script.</dd>

         <dt>Otherwise</dt>
         <dd><a>Immediately</a> <a>execute the script block</a>, even if other scripts are already
         executing.</dd>
       </dl>

  The <dfn>pending parsing-blocking script</dfn> of a {{Document}} is used by the {{Document}}'s
  parser(s).

  <p class="note">If a <{script}> element that blocks a parser gets moved to another {{Document}}
  before it would normally have stopped blocking that parser, it nonetheless continues blocking that
  parser until the condition that causes it to be blocking the parser no longer applies (e.g., if
  the script is a <a>pending parsing-blocking script</a> because there was
  <a>a style sheet that is blocking scripts</a> when it was parsed, but then the script is moved to
  another {{Document}} before the style sheet loads, the script still blocks the parser until the
  style sheets are all loaded, at which time the script executes and the parser is unblocked).</p>

  When the user agent is required to <dfn lt="execute a script block|execute|execute the script block">execute a script block</dfn>, it must run the following steps:

  1. If the element is flagged as "[=parser-inserted=]", but the element's <a>node document</a>
      is not the {{Document}} of the parser that created the element, then abort these steps.
  2. If <a>the script's script</a> is null, <a>fire a simple event</a> named <code>error</code> at the element,
      and abort these steps.
  3. If the script is <a>from an external file</a>, or <a>the script's type</a> is "<code>module</code>", then
      increment the <a>ignore-destructive-writes counter</a> of the <{script}> element's
      <a>node document</a>. Let <var>neutralized doc</var> be that {{Document}}.
  4. Let <var>old script element</var> be the value to which the <{script}> element's
      <a>node document</a>'s {{Document/currentScript}} object was most recently set.
  5. Switch on <a>the script's type</a>:
      <dl class="switch">
        <dt>`"classic"`</dt>
        <dd>
             1. Set the <{script}> element's <a>node document</a>'s {{Document/currentScript}}
                 attribute to the <{script}> element.

                 <p class="note">This does not use the <a>in a document</a> check, as the <{script}>
                 element could have been removed from the document prior to execution, and in that
                 scenario {{Document/currentScript}} still needs to point to it.</p>
             2. <a>Run the classic script</a> given by <a>the script's script</a>.
        </dd>

        <dt><code>"module"</code></dt>
        <dd>
             1. Set the <{script}> element's <a>node document</a>'s {{Document/currentScript}}
                 attribute to null.
             2. <a>Run the module script</a> given by <a>the script's script</a>.
        </dd>
  6. Set the <{script}> element's <a>node document</a>'s {{Document/currentScript}} object to
      <var>old script element</var>.
  7. Decrement the <a>ignore-destructive-writes counter</a> of <var>neutralized doc</var>, if it was
      incremented in the earlier step.
  8. If <a>the script's type</a> is "<code>classic</code>" and the script is <a>from an external file</a>,
      <a>fire a simple event</a> named <code>load</code> at the <{script}> element.

      Otherwise <a>queue a task</a> to <a>fire a simple event</a> named <code>load</code> at the <{script}>
      element.

<h5 id="scripting-languages">Scripting languages</h5>

  A <dfn>JavaScript MIME type</dfn> is a <a>MIME type</a> string that is one of the
  following and refers to JavaScript: [[!ECMA-262]]

  <ul class="brief">
    <li><code>application/ecmascript</code>
    </li><li><code>application/javascript</code>
    </li><li><code>application/x-ecmascript</code>
    </li><li><code>application/x-javascript</code>
    </li><li><code>text/ecmascript</code>
    </li><li><code>text/javascript</code>
    </li><li><code>text/javascript1.0</code>
    </li><li><code>text/javascript1.1</code>
    </li><li><code>text/javascript1.2</code>
    </li><li><code>text/javascript1.3</code>
    </li><li><code>text/javascript1.4</code>
    </li><li><code>text/javascript1.5</code>
    </li><li><code>text/jscript</code>
    </li><li><code>text/livescript</code>
    </li><li><code>text/x-ecmascript</code>
    </li><li><code>text/x-javascript</code>
  </li></ul>

  User agents must recognize all <a>JavaScript MIME types</a>.

  User agents may support other <a>MIME types</a> for other languages, but must not support other
  <a>MIME types</a> for the languages in the list above. User agents are not required to support
  JavaScript. The processing model for languages other than JavaScript is outside the scope of this
  specification.

  The following <a>MIME types</a> (with or without parameters) must not be interpreted as scripting
  languages:

  * `text/plain`
  * `text/xml`
  * `application/octet-stream`
  * `application/xml`

  <p class="note">These types are explicitly listed here because they are poorly-defined types that
  are nonetheless likely to be used as formats for data blocks, and it would be problematic if they
  were suddenly to be interpreted as script by a user agent.</p>

  When examining types to determine if they represent supported languages, user agents must not
  ignore MIME parameters. Types are to be compared including all parameters.

  <p class="note">For example, types that include the <code>charset</code> parameter will not be
  recognized as referencing any of the scripting languages listed above.</p>

<h5 id="restrictions-for-contents-of-script-elements"><dfn lt="script content restrictions">Restrictions for contents of <{script}> elements</dfn></h5>

  <p class="note">The easiest and safest way to avoid the rather strange restrictions described in
  this section is to always escape "`&lt;!--`" as "`&lt;\!--`", "`&lt;script`" as "`&lt;\script`",
  and "`&lt;/script`" as "`&lt;\/script`" when these sequences appear in literals in scripts (e.g.,
  in strings, regular expressions, or comments), and to avoid writing code that uses such constructs
  in expressions. Doing so avoids the pitfalls that the restrictions in this section are prone to
  triggering: namely, that, for historical reasons, parsing of <{script}> blocks in HTML is a
  strange and exotic practice that acts unintuitively in the face of these sequences.</p>

  The {{Node/textContent}} of a <{script}> element must match the <code>script</code> production in
  the following ABNF, the character set for which is Unicode. [[!ABNF]]

  <pre data-highlight="abnf">
    script        = outer *( comment-open inner comment-close outer )

    outer         = &lt; any string that doesn't contain a substring that matches not-in-outer &gt;
    not-in-outer  = comment-open
    inner         = &lt; any string that doesn't contain a substring that matches not-in-inner &gt;
    not-in-inner  = comment-close / script-open

    comment-open  = "&lt;!--"
    comment-close = "--&gt;"
    script-open   = "&lt;" s c r i p t tag-end

    s             =  %x0053 ; U+0053 LATIN CAPITAL LETTER S
    s             =/ %x0073 ; U+0073 LATIN SMALL LETTER S
    c             =  %x0043 ; U+0043 LATIN CAPITAL LETTER C
    c             =/ %x0063 ; U+0063 LATIN SMALL LETTER C
    r             =  %x0052 ; U+0052 LATIN CAPITAL LETTER R
    r             =/ %x0072 ; U+0072 LATIN SMALL LETTER R
    i             =  %x0049 ; U+0049 LATIN CAPITAL LETTER I
    i             =/ %x0069 ; U+0069 LATIN SMALL LETTER I
    p             =  %x0050 ; U+0050 LATIN CAPITAL LETTER P
    p             =/ %x0070 ; U+0070 LATIN SMALL LETTER P
    t             =  %x0054 ; U+0054 LATIN CAPITAL LETTER T
    t             =/ %x0074 ; U+0074 LATIN SMALL LETTER T

    tag-end       =  %x0009 ; U+0009 CHARACTER TABULATION (tab)
    tag-end       =/ %x000A ; U+000A LINE FEED (LF)
    tag-end       =/ %x000C ; U+000C FORM FEED (FF)
    tag-end       =/ %x0020 ; U+0020 SPACE
    tag-end       =/ %x002F ; U+002F SOLIDUS (/)
    tag-end       =/ %x003E ; U+003E GREATER-THAN SIGN (&gt;)
  </pre>

  When a <{script}> element contains <a>script documentation</a>, there are further restrictions on
  the contents of the element, as described in the section below.

  <div class="example">
    The following script illustrates this issue. Suppose you have a script that contains a string,
    as in:

    <xmp highlight="javascript">
      var example = 'Consider this string: <!-- <script>';
      console.log(example);
    </xmp>

    If one were to put this string directly in a <{script}> block, it would violate the
    restrictions above:

    <xmp highlight="html">
      <script>
        var example = 'Consider this string: <!-- <script>';
        console.log(example);
      </script>;
    </xmp>

    The bigger problem, though, and the reason why it would violate those restrictions, is that
    actually the script would get parsed weirdly: <em>the script block above is not terminated</em>.
    That is, what looks like a "`&lt;/script&gt;`" end tag in this snippet is actually still part of
    the <{script}> block. The script doesn't execute (since it's not terminated); if it somehow were
    to execute, as it might if the markup looked as follows, it would fail because the script is not
    valid JavaScript:

    <xmp highlight="html">
      <script>
        var example = 'Consider this string: <!-- <script>';
        console.log(example);
      </script>
      <!-- despite appearances, this is actually part of the script still! -->
      <script>
        ... // this is the same script block still...
      </script>
    </xmp>

    What is going on here is that for legacy reasons, "`&lt;!--`" and "`&lt;script`" strings in
    <{script}> elements in HTML need to be balanced in order for the parser to consider closing the
    block.

    By escaping the problematic strings as mentioned at the top of this section, the problem is
    avoided entirely:

    <xmp highlight="html">
      <script>
        var example = 'Consider this string: <\!-- <\script>';
        console.log(example);
      </script>
      <!-- this is just a comment between script blocks -->
      <script>
        ... // this is a new script block
      </script>
    </xmp>

    It is possible for these sequences to naturally occur in script expressions, as in the
    following examples:

    <xmp highlight="javascript">
      if (x<!--y) { ... }
      if ( player<script ) { ... }
    </xmp>

    In such cases the characters cannot be escaped, but the expressions can be rewritten so that
    the sequences don't occur, as in:

    <xmp highlight="javascript">
      if (x < !--y) { ... }
      if (!--y > x) { ... }
      if (!(--y) > x) { ... }
      if (player < script) { ... }
      if (script > player) { ... }
    </xmp>

    Doing this also avoids a different pitfall as well: for related historical reasons, the string
    "`&lt;!--`" in <a>classic scripts</a> is actually treated as a line comment start, just like
    "`//`".

  </div>

<h5 id="inline-documentation-for-external-scripts"><dfn lt="script documentation">Inline documentation for external scripts</dfn></h5>

  If a <{script}> element's <{script/src}> attribute is specified, then the contents of the
  <{script}> element, if any, must be such that the value of the {{HTMLScriptElement/text}} IDL
  attribute, which is derived from the element's contents, matches the <code>documentation</code> production in
  the following ABNF, the character set for which is Unicode. [[!ABNF]]

  <pre data-highlight="abnf">
    documentation = *( *( space / tab / comment ) [ line-comment ] newline )
    comment       = slash star *( not-star / star not-slash ) 1*star slash
    line-comment  = slash slash *not-newline

    ; characters
    tab           = %x0009 ; U+0009 CHARACTER TABULATION (tab)
    newline       = %x000A ; U+000A LINE FEED (LF)
    space         = %x0020 ; U+0020 SPACE
    star          = %x002A ; U+002A ASTERISK (*)
    slash         = %x002F ; U+002F SOLIDUS (/)
    not-newline   = %x0000-0009 / %x000B-10FFFF
                    ; a Unicode character other than U+000A LINE FEED (LF)
    not-star      = %x0000-0029 / %x002B-10FFFF
                    ; a Unicode character other than U+002A ASTERISK (*)
    not-slash     = %x0000-002E / %x0030-10FFFF
                    ; a Unicode character other than U+002F SOLIDUS (/)
  </pre>

  <p class="note">This corresponds to putting the contents of the element in JavaScript comments.
  </p>

  <p class="note">
    This requirement is in addition to the earlier restrictions on the syntax of
    contents of <{script}> elements.
  </p>

  <div class="example">
    This allows authors to include documentation, such as license information or API information,
    inside their documents while still referring to external script files. The syntax is constrained
    so that authors don't accidentally include what looks like valid script while also providing a
    <{script/src}> attribute.

    <xmp highlight="html">
      <script src="cool-effects.js">
        // create new instances using:
        //    var e = new Effect();
        // start the effect using .play, stop using .stop:
        //    e.play();
        //    e.stop();
      </script>
    </xmp>
  </div>

<h5 id="interaction-of-script-elements-and-xslt">Interaction of <{script}> elements and XSLT</h5>

  <em>This section is non-normative.</em>

  This specification does not define how XSLT interacts with the <{script}> element.
  However, in the absence of another specification actually defining this, here are some guidelines
  for implementors, based on existing implementations:

  * When an XSLT transformation program is triggered by an `&lt;?xml-stylesheet?&gt;` processing
     instruction and the browser implements a direct-to-DOM transformation, <{script}> elements
     created by the XSLT processor need to be marked "[=parser-inserted=]" and run in document
     order (modulo scripts marked <{script/defer}> or <{script/async}>), <a>immediately</a>, as the
     transformation is occurring.
  * The <code>XSLTProcessor.transformToDocument()</code> method [[XSLTP]] adds elements to a
     {{Document}} that is not in a <a>browsing context</a>, and, accordingly, any <{script}>
     elements they create need to have their "[=already started=]" flag set in the
     <a>prepare a script</a> algorithm and never get executed (<a>scripting is disabled</a>). Such
     <{script}> elements still need to be marked "[=parser-inserted=]", though, such that their
     {{HTMLScriptElement/async}} IDL attribute will return false in the absence of an
     <{script/async}> content attribute.
  * The <code>XSLTProcessor.transformToFragment()</code> method needs to create a fragment that is
     equivalent to one built manually by creating the elements using
     {{Document/createElementNS()|document.createElementNS()}}. For instance, it needs to create
     <{script}> elements that aren't "[=parser-inserted=]" and that don't have their
     "[=already started=]" flag set, so that they will execute when the fragment is
     <a for="document">inserted into a document</a>.

  The main distinction between the first two cases and the last case is that the first two
  operate on {{Document}}s and the last operates on a fragment.

<h4 id="the-noscript-element">The <dfn element><code>noscript</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>In a <{head}> element of an <a>HTML document</a>, if there are no ancestor <{noscript}> elements.</dd>
    <dd>Where <a>phrasing content</a> is expected in <a>HTML documents</a>, if there are no ancestor <{noscript}> elements.</dd>
    <dt><a>Content model</a>:</dt>
    <dd>When <a>scripting is disabled</a>, in a <{head}> element: in any order, zero or more <{link}> elements, zero or more <{style}> elements, and zero or more <{meta}> elements.</dd>
    <dd>When <a>scripting is disabled</a>, not in a <{head}> element: <a>transparent</a>, but there must be no <{noscript}> element descendants.</dd>
    <dd>Otherwise: text that conforms to the requirements given in the prose.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd>None</dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd>None</dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>Uses {{HTMLElement}}.</dd>
  </dl>

  The <{noscript}> element <a>represents</a> nothing if <a>scripting is enabled</a>, and
  <a>represents</a> its children if <a>scripting is disabled</a>. It is used to present different
  markup to user agents that support scripting and those that don't support scripting, by affecting
  how the document is parsed.

  When used in <a>HTML documents</a>, the allowed content model is as follows:

  : In a <{head}> element, if <a>scripting is disabled</a> for the <{noscript}> element
  :: The <{noscript}> element must contain only <{link}>, <{style}>, and <{meta}> elements.

  : In a <{head}> element, if <a>scripting is enabled</a> for the <{noscript}> element
  :: The <{noscript}> element must contain only text, except that invoking the
      <a>HTML fragment parsing algorithm</a> with the <{noscript}> element as the <a>context</a>
      element and the text contents as the <var>input</var> must result in a list of nodes that
      consists only of <{link}>, <{style}>, and <{meta}> elements that would be conforming if they
      were children of the <{noscript}> element, and no
      [=parse errors=].

  : Outside of <{head}> elements, if <a>scripting is disabled</a> for the <{noscript}> element
  :: The <{noscript}> element's content model is <a>transparent</a>, with the additional restriction
      that a <{noscript}> element must not have a <{noscript}> element as an ancestor (that is,
      <{noscript}> can't be nested).

  : Outside of <{head}> elements, if <a>scripting is enabled</a> for the <{noscript}> element
  :: The <{noscript}> element must contain only text, except that the text must be such that running
      the following algorithm results in a <a lt="conforming document">conforming document</a> with
      no <{noscript}> elements and no <{script}> elements, and such that no step in the algorithm
      throws an exception or causes an <a>HTML parser</a> to flag a [=parse error=]:

      1. Remove every <{script}> element from the document.
      2. Make a list of every <{noscript}> element in the document. For every <{noscript}> element
          in that list, perform the following steps:

          1. Let <var>s</var> be the <a>child text content</a> of the <{noscript}> element.
          2. Set the <code>outerHTML</code> attribute of the <{noscript}> element to the value of
              <var>s</var>. (This, as a side-effect, causes the <{noscript}> element to be removed
              from the document.) [[!DOM-PARSING]]

  <p class="note">All these contortions are required because, for historical reasons, the
  <{noscript}> element is handled differently by the <a>HTML parser</a> based on whether
  [=scripting flag|scripting was enabled or not=] when the parser was invoked.</p>

  The <{noscript}> element must not be used in <a>XML documents</a>.

  <p class="note">The <{noscript}> element is only effective in
  <a href="#syntax">the HTML syntax</a>, it has no effect in <a href="#xhtml">the XHTML syntax</a>.
  This is because the way it works is by essentially "turning off" the parser when scripts are
  enabled, so that the contents of the element are treated as pure text and not as real elements.
  XML does not define a mechanism by which to do this.</p>

  The <{noscript}> element has no other requirements. In particular, children of the <{noscript}>
  element are not exempt from [[#forms-form-submission]], scripting, and so forth, even when
  <a>scripting is enabled</a> for the element.

  <div class="example">
    In the following example, a <{noscript}> element is used to provide fallback for a script.

    <xmp highlight="html">
      <form action="calcSquare.php">
        <p>
          <label for="x">Number</label>:
          <input id="x" name="x" type="number">
        </p>
        <script>
          var x = document.getElementById('x');
          var output = document.createElement('p');
          output.textContent = 'Type a number; it will be squared right then!';
          x.form.appendChild(output);
          x.form.onsubmit = function() {
            return false;
          }
          x.oninput = function() {
            var v = x.valueAsNumber;
            output.textContent = v + ' squared is ' + v * v;
          };
        </script>
        <noscript>
          <input type="submit" value="Calculate Square">
        </noscript>
      </form>
    </xmp>

    When script is disabled, a button appears to do the calculation on the server side. When
    script is enabled, the value is computed on-the-fly instead.

    The <{noscript}> element is a blunt instrument. Sometimes, scripts might be enabled,
    but for some reason the page's script might fail. For this reason, it's generally better to avoid
    using <{noscript}>, and to instead design the script to change the page from being a
    scriptless page to a scripted page on the fly, as in the next example:

    <xmp highlight="html">
      <form action="calcSquare.php">
        <p>
          <label for="x">Number</label>:
          <input id="x" name="x" type="number">
        </p>
        <input id="submit" type=submit value="Calculate Square">
        <script>
          var x = document.getElementById('x');
          var output = document.createElement('p');
          output.textContent = 'Type a number; it will be squared right then!';
          x.form.appendChild(output);
          x.form.onsubmit = function() {
            return false;
          }
          x.oninput = function() {
            var v = x.valueAsNumber;
            output.textContent = v + ' squared is ' + v * v;
          };
          var submit = document.getElementById('submit');
          submit.parentNode.removeChild(submit);
        </script>
      </form>
    </xmp>

    The above technique is also useful in XHTML, since <{noscript}> is not supported in
    <a href="#xhtml">the XHTML syntax</a>.

  </div>

<h4 id="the-template-element">The <dfn element><code>template</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Script-supporting element</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>Where <a>metadata content</a> is expected.</dd>
    <dd>Where <a>phrasing content</a> is expected.</dd>
    <dd>Where <a>script-supporting elements</a> are expected.</dd>
    <dd>As a child of a <{colgroup}> element that doesn't have a <code>span</code> attribute.</dd>
    <dt><a>Content model</a>:</dt>
    <dd><a>Nothing</a> (for clarification, <a href="#template-example">see example</a>).</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible.</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd>None</dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd>None</dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl">
        [Exposed=Window,
         HTMLConstructor]
        interface HTMLTemplateElement : HTMLElement {
          readonly attribute DocumentFragment content;
        };
      </pre>
    </dd>
  </dl>

  The <{template}> element is used to declare fragments of HTML that can be cloned and
  inserted in the document by script.

  In a rendering, the <{template}> element <a>represents</a> nothing.

  <p>The <a>template contents</a> of a <{template}> element <a
  href="#template-syntax">are not children of the element itself</a>.</p>

  <p class="note">It is also possible, as a result of DOM manipulation,
  for a <{template}> element to contain {{Text}} nodes and element nodes;
  however, having any is a violation of the <{template}> element's content model,
  since its content model is defined as <a>Nothing</a>.</p>

  <div class="example" id="template-example">

    <p>For example, consider the following document:</p>

    <xmp highlight="html">
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <title>Homework</title>
        </head>
        <body>
          <template id="template">
            <p>Smile!</p>
          </template>
          <script>
            let num = 3;
            const fragment = document.getElementById('template').content.cloneNode(true);
            while (num-- > 1) {
              fragment.firstChild.before(fragment.firstChild.cloneNode(true));
              fragment.firstChild.textContent += fragment.lastChild.textContent;
            }
            document.body.appendChild(fragment);
          </script>
        </body>
      </html>
    </xmp>

   <p>The <{p}> element in the <{template}> is <em>not</em> a child of the
   <{template}> in the DOM; it is a child of the {{DocumentFragment}} returned by the <{template}> element's <code>content</code> IDL
   attribute.</p>

   <p>If the script were to call <code>appendChild()</code> on the <{template}> element, that would add a child to the <{template}> element (as for any other element); however, doing so is a violation of the <{template}> element's content model.</p>

  </div>


  <dl class="domintro">

    <dt><var>template</var> . <code>content</code></dt>

    <dd>

    <p>Returns the <a>template contents</a> (a {{DocumentFragment}}).</p>

   </dd>

  </dl>

  <p>Each <{template}> element has an associated {{DocumentFragment}} object that is its <dfn>template contents</dfn>. The <a>template contents</a> have <a href="#no-browsing-context">no conformance requirements</a>. When a <{template}> element is created, the user agent must run the following steps to establish the <a>template contents</a>:</p>

  <ol>

   <li><p>Let <var>doc</var> be the <{template}> element's <a>node document</a>'s <a>appropriate template contents owner document</a>.</p></li>

   <li><p>Create a {{DocumentFragment}} object whose <a>node document</a> is
   <var>doc</var> and [=host-concept/host=] is the
   <{template}> element.</p></li>

   <li><p>Set the <{template}> element's <a>template contents</a> to the newly
   created {{DocumentFragment}} object.</p></li>

  </ol>

  <p>A {{Document}} <var>doc</var>'s <dfn>appropriate template contents owner document</dfn> is the {{Document}} returned by the following algorithm:</p>

  <ol>

    <li>

    If <var>doc</var> is not a {{Document}} created by this algorithm, then:

    <ol>

      <li>

      If <var>doc</var> does not yet have an <dfn>associated inert template document</dfn>, then:

      <ol>

        <li>Let <var>new doc</var> be a new {{Document}} (that does not have a
        <a>browsing context</a>). This is "a {{Document}} created by this algorithm"
        for the purposes of the step above.</li>

        <li>If <var>doc</var> is an <a>HTML document</a>, mark
        <var>new doc</var> as an <a>HTML document</a>
        also.</li>

        <li>Let <var>doc</var>'s <a>associated inert template document</a> be <var>new doc</var>.</li>

      </ol>

      </li>

      <li>Set <var>doc</var> to <var>doc</var>'s <a>associated inert template document</a>.</li>

    </ol>

    <p class="note">
    Each <code>Document</code> not created by this algorithm thus gets a single
    <code>Document</code> to act as its proxy for owning the <a>template contents</a> of all
    its <{template}> elements, so that they aren't in a <a>browsing context</a> and
    thus remain inert (e.g., scripts do not run). Meanwhile, <{template}> elements inside
    <code>Document</code> objects that <em>are</em> created by this algorithm just reuse the same
    <code>Document</code> owner for their contents.
  </p>

    </li>

    <li>Return <var>doc</var>.</li>

  </ol>

  The <a>adopting steps</a>
  (with <var>node</var> and <var>oldDocument</var> as parameters) for <{template}> elements
  are the following:

  <ol>

    <li>

    Let <var>doc</var> be <var>node</var>'s <a>node document</a>'s
    <a>appropriate template contents owner document</a>.

    <p class="note"><var>node</var>'s <a>node document</a> is the <code>Document</code> object
    that <var>node</var> was just adopted <em>into</em>.</p>

    </li>

    <li><a>Adopt</a> <var>node</var>'s
    <a>template contents</a> (a <code>DocumentFragment</code> object) into <var>doc</var>.</li>

  </ol>

  The <dfn attribute for="HTMLTemplateElement"><code>content</code></dfn> IDL attribute must return
  the <{template}> element's <a>template contents</a>.

  <hr />

  The <a>cloning steps</a> for a <code>template</code>
  element <var>node</var> being cloned to a copy <var>copy</var> must run the
  following steps:

  <ol>

    <li>If the <var>clone children flag</var> is not set in the calling <a lt="clone a node">clone</a> algorithm, abort these steps.</li>

    <li>Let <var>copied contents</var> be the result of <a lt="clone a node">cloning</a> all the children of <var>node</var>'s
    <a>template contents</a>, with <var>document</var> set to <var>copy</var>'s <a>template contents</a>'s <a>node
    document</a>, and with the <var>clone children
    flag</var> set.</li>

    <li>Append <var>copied contents</var> to <var>copy</var>'s <a>template contents</a>.</li>

  </ol>

  <div class="example">
    In this example, a script populates a table four-column with data from a data structure, using
    a <code>template</code> to provide the element structure instead of manually generating the
    structure from markup.

    <xmp highlight="html">
      <!DOCTYPE html>
      <html lang="en">
      <title>Cat data</title>
      <script>
        // Data is hard-coded here, but could come from the server
        var data = [
          { name: 'Pillar', color: 'Tabby',  sex: 'Female', legs: 3 },
          { name: 'Hedral', color: 'Tuxedo', sex: 'Male',   legs: 4 },
        ];
      </script>
      <table>
        <thead>
          <tr>
            <th>Name</th> <th>Color</th> <th>Sex</th> <th>Legs</th>
          </tr>
        </thead>
        <tbody>
          <template id="row">
            <tr>
              <td></td> <td></td> <td></td> <td></td>
            </tr>
          </template>
        </tbody>
      </table>
      <script>
        var template = document.querySelector('#row');
        for (var i = 0; i < data.length; i += 1) {
          var cat = data[i];
          var clone = template.content.cloneNode(true);
          var cells = clone.querySelectorAll('td');
          cells[0].textContent = cat.name;
          cells[1].textContent = cat.color;
          cells[2].textContent = cat.sex;
          cells[3].textContent = cat.legs;
          template.parentNode.appendChild(clone);
        }
      </script>
    </xmp>

    This example uses <code>cloneNode()</code> on the <code>template</code>'s contents; it could
    equivalently have used <code>document.importNode()</code>, which does the same thing. The only
    difference between these two APIs is when the <a>node document</a> is updated: with
    <code>cloneNode()</code> it is updated when the nodes are appended with
    <code>appendChild()</code>, with <code>document.importNode()</code> it is updated when the nodes
    are cloned.
  </div>

<h5 id="interaction-of-template-elements-with-xslt-and-xpath">Interaction of <{template}> elements with XSLT and XPath</h5>

  <em>This section is non-normative.</em>

  This specification does not define how XSLT and XPath interact with the <code>template</code>
  element. However, in the absence of another specification actually defining this, here are some
  guidelines for implementors, which are intended to be consistent with other processing described
  in this specification:

  <ul>

    <li>An XSLT processor based on an XML parser that acts as described
    in this specification needs to act as if <{template}> elements contain as
    descendants their <a>template contents</a> for the purposes of the transform.</li>

    <li>An XSLT processor that outputs a DOM needs to ensure that nodes that would go into a
    <{template}> element are instead placed into the element's <a>template
    contents</a>.</li>

    <li>XPath evaluation using the XPath DOM API when applied to a <code>Document</code> parsed
    using the <a>HTML parser</a> or the <a>XML parser</a> described in this specification
    needs to ignore <a>template contents</a>.

  </li></ul>

<h4 id="the-canvas-element">The <dfn element><code>canvas</code></dfn> element</h4>

  <dl class="element">
    <dt><a>Categories</a>:</dt>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Embedded content</a>.</dd>
    <dd><a>Palpable content</a>.</dd>
    <dt><a>Contexts in which this element can be used</a>:</dt>
    <dd>Where <a>embedded content</a> is expected.</dd>
    <dt><a>Content model</a>:</dt>
    <dd><a>Transparent</a>.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><code>width</code> - Horizontal dimension</dd>
    <dd><code>height</code> - Vertical dimension</dd>
    <dt>[=Allowed ARIA role attribute values=]:</dt>
    <dd><a href="#allowed-aria-roles-states-and-properties">Any role value</a>.</dd>
    <dt>[=Allowed ARIA state and property attributes=]:</dt>
    <dd><a>Global aria-* attributes</a></dd>
    <dd>Any <code>aria-*</code> attributes
    <a href="#allowed-aria-roles-states-and-properties">applicable to the allowed roles</a>.</dd>

    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl">
        typedef (CanvasRenderingContext2D or WebGLRenderingContext or WebGL2RenderingContext) RenderingContext;

        interface HTMLCanvasElement : HTMLElement {
          attribute unsigned long width;
          attribute unsigned long height;

          RenderingContext? getContext(DOMString contextId, any... arguments);
          boolean probablySupportsContext(DOMString contextId, any... arguments);

          DOMString toDataURL(optional DOMString type, any... arguments);
          void toBlob(BlobCallback _callback, optional DOMString type, any... arguments);
        };

        callback BlobCallback = void (Blob? blob);
      </pre>
    </dd>
  </dl>

  The <{canvas}> element provides scripts with a resolution-dependent bitmap canvas,
  which can be used for rendering graphs, game graphics, art, or other visual images on the fly.

  Authors should not use the <{canvas}> element in a document when a more suitable
  element is available. For example, it is inappropriate to use a <{canvas}> element to
  render a page heading: if the desired presentation of the heading is graphically intense, it
  should be marked up using appropriate elements (typically <code>h1</code>) and then styled using
  CSS and supporting technologies such as Web Components.

  When authors use the <{canvas}> element, they must also provide content that, when
  presented to the user, conveys essentially the same function or purpose as the
  <{canvas}>'s bitmap. This content may be placed as content of the <{canvas}>
  element. The contents of the <{canvas}> element, if any, are the element's <a>fallback
  content</a>.

  <hr />

  In interactive visual media, if <a>scripting is enabled</a> for
  the <{canvas}> element, and if support for <{canvas}> elements has been enabled,
  the <{canvas}> element <a>represents</a> <a>embedded content</a> consisting
  of a dynamically created image, the element's bitmap.

  In non-interactive, static, visual media, if the <{canvas}> element has been
  previously associated with a rendering context (e.g., if the page was viewed in an interactive
  visual medium and is now being printed, or if some script that ran during the page layout process
  painted on the element), then the <{canvas}> element <a>represents</a>
  <a>embedded content</a> with the element's current bitmap and size. Otherwise, the element
  represents its <a>fallback content</a> instead.

  In non-visual media, and in visual media if <a>scripting is
  disabled</a> for the <{canvas}> element or if support for <{canvas}> elements
  has been disabled, the <{canvas}> element <a>represents</a> its <a>fallback
  content</a> instead.

  When a <{canvas}> element <a>represents</a> <a>embedded content</a>, the
  user can still focus descendants of the <{canvas}> element (in the <a>fallback
  content</a>). When an element is <a>focused</a>, it is the target of keyboard interaction
  events (even though the element itself is not visible). This allows authors to make an interactive
  canvas keyboard-accessible: authors should have a one-to-one mapping of interactive regions to <i>focusable areas</i> in the <a>fallback content</a>. (Focus has no
  effect on mouse interaction events.) [[!UIEVENTS]]

  An element whose nearest <{canvas}> element ancestor is <a>being rendered</a>
  and <a>represents</a> <a>embedded content</a> is an element that is <dfn>being used as
  relevant canvas fallback content</dfn>.

  <hr />

  The <{canvas}> element has two attributes to control the size of the element's bitmap:
  <dfn element-attr for="canvas"><code>width</code></dfn> and
  <dfn element-attr for="canvas"><code>height</code></dfn>. These attributes, when specified, must have
  values that are <a>valid non-negative integers</a>.
  The <a>rules for parsing non-negative integers</a> must be used to obtain their
  numeric values. If an attribute is missing, or if parsing its value returns an error, then the
  default value must be used instead. The <code>width</code>
  attribute defaults to 300, and the <code>height</code> attribute
  defaults to 150.

  The <a>intrinsic dimensions</a> of the <{canvas}> element when it
  <a>represents</a> <a>embedded content</a> are equal to the dimensions of the
  element's bitmap.

  The user agent must use a square pixel density consisting of one pixel of image data per
  coordinate space unit for the bitmaps of a <code>canvas</code> and its rendering contexts.

  <p class="note">
    A <{canvas}> element can be sized arbitrarily by a style sheet, its
  bitmap is then subject to the 'object-fit' CSS property. [[!CSS3-IMAGES]]
  </p>


  <hr />

  The bitmaps of <{canvas}> elements, the bitmaps of <code>ImageBitmap</code> objects,
  as well as some of the bitmaps of rendering contexts, such as those described in the section on
  the <code>CanvasRenderingContext2D</code> object below, have an <dfn for="canvas">origin-clean</dfn> flag, which can be set to true or false.
  Initially, when the <{canvas}> element or <code>ImageBitmap</code> object is created,
  its bitmap's <a>origin-clean</a> flag must be set to
  true.

  A <code>canvas</code> bitmap can also have a hit region list, as described in the
  <code>CanvasRenderingContext2D</code> section below.

  A <{canvas}> element can have a rendering context bound to it. Initially, it does not
  have a bound rendering context. To keep track of whether it has a rendering context or not, and
  what kind of rendering context it is, a <code>canvas</code> also has a
  <dfn mode for="canvas" lt="context mode|canvas context mode">canvas context mode</dfn>,
  which is initially <dfn context for="canvas">none</dfn> but can be changed to either
  <dfn context for="canvas">2d</dfn>, <dfn context for="canvas">webgl</dfn>, <dfn context
  for="canvas">webgl2</dfn> by algorithms defined in this specification.

  When its <a mode for="canvas">canvas context mode</a> is <a context for="canvas">none</a>, a <{canvas}> element has no rendering context,
  and its bitmap must be fully transparent black with an <a for="css">intrinsic width</a> equal to the numeric value
  of the element's <code>width</code> attribute and an <a for="css">intrinsic height</a>
  equal to the numeric value of the element's <code>height</code>
  attribute, those values being interpreted in CSS pixels, and being updated as the attributes are
  set, changed, or removed.

  When a <{canvas}> element represents <a>embedded content</a>, it provides
  a <a>paint source</a> whose width is the element's <a for="css">intrinsic width</a>, whose height is
  the element's <a for="css">intrinsic height</a>, and whose appearance is the element's bitmap.

  Whenever the <code>width</code> and <code>height</code> content attributes are set, removed, changed, or
  redundantly set to the value they already have, if the <a mode for="canvas">canvas context mode</a>
  is <a context for="canvas">2d</a>, the user agent must set bitmap dimensions to the numeric values of
  the <code>width</code> and <code>height</code> content attributes.

  The <dfn attribute for="HTMLCanvasElement"><code>width</code></dfn> and
  <dfn attribute for="HTMLCanvasElement"><code>height</code></dfn> IDL attributes must <a>reflect</a> the
  respective content attributes of the same name, with the same defaults.

  <hr />

  <dl class="domintro">

    <dt><var>context</var> = <var>canvas</var> . <code>getContext</code>(<var>contextId</var> [, ... ] )</dt>

    <dd>

    Returns an object that exposes an API for drawing on the canvas. The first argument specifies
    the desired API. Subsequent arguments are handled by that API.

    Valid contexts are: "<code>2d</code>" [[!CANVAS-2D]] or "<code>webgl</code>" [[!WEBGL-1]] or "<code>webgl2</code>" [[!webgl-2]].

    Returns null if the given context ID is not supported or if the canvas has already been
    initialized with some other (incompatible) context type (e.g., trying to get a "<code>2d</code>" context after getting a "<code>webgl</code>" context).

    </dd>

    <dt><var>supported</var> = <var>canvas</var> . <code>probablySupportsContext</code>(<var>contextId</var> [, ... ] )</dt>

    <dd>

    Returns false if calling <code>getContext()</code> with the
    same arguments would definitely return null, and true otherwise.

    This return value is not a guarantee that <code>getContext()</code> will or will not return an object, as
    conditions (e.g., availability of system resources) can vary over time.

    </dd>

  </dl>

  The <dfn method for="HTMLCanvasElement"><code>getContext(<var>contextId</var>, <var>arguments...</var>)</code></dfn> method of the <{canvas}> element, when invoked,
  must run the steps in the cell of the following table whose column header describes the
  <{canvas}> element's <a mode for="canvas">canvas context mode</a>
  and whose row header describes the method's first argument.

<table class='data'>
   <caption>getContext() invocation steps</caption>
   <thead>
      <tr>
         <td></td>
         <th><a context for="canvas">none</a></th>
         <th><a context for="canvas">2d</a></th>
         <th><a context for="canvas">webgl</a></th>
         <th><a context for="canvas">webgl2</a></th>
      </tr>
   </thead>
   <tbody>
      <tr>
         <th>"<dfn><code>2d</code></dfn>"</th>
         <td>
            Set the <{canvas}> element's <a mode for="canvas">context mode</a> to <a context for="canvas">2d</a>, obtain a
            <code>CanvasRenderingContext2D</code> object as
            defined in the HTML Canvas 2D Context
            specification [[!CANVAS-2D]], set the obtained
            <code>CanvasRenderingContext2D</code> object's
            <a mode for="canvas">context mode</a> to
            <a context for="canvas">2d</a>, and return the
            <code>CanvasRenderingContext2D</code> object
         </td>
         <td>
            Return the same object as was return the last time the method was invoked with this same
            first argument.
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
      </tr>
      <tr>
         <th>"<dfn><code>webgl</code></dfn>", if the user agent supports the WebGL feature in its current configuration</th>
         <td>
            Follow the instructions given in the WebGL specification's <i>Context Creation</i> section to
            obtain either a <code>WebGLRenderingContext</code> or null; if the returned value is null,
            then return null and abort these steps, otherwise, set the <{canvas}> element's <a mode for="canvas">context mode</a> to <a context for="canvas">webgl</a>, set the new
            <code>WebGLRenderingContext</code> object's <a mode for="canvas">context mode</a> to <a context for="canvas">webgl</a>, and return the <code>WebGLRenderingContext</code>
            object‡ [[!WEBGL-1]]
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return the same object as was return the last time the method was invoked with this same
            first argument.
         </td>
         <td>
            Return null
         </td>
      </tr>
      <tr>
         <th>"<dfn><code>webgl2</code></dfn>", if the user agent supports the WebGL2 feature in its current configuration</th>
         <td>
            Follow the instructions given in the WebGL2 specification's <i>Context Creation</i> section to
            obtain either a <code>WebGL2RenderingContext</code> or null; if the returned value is null,
            then return null and abort these steps, otherwise, set the <{canvas}> element's <a mode for="canvas">context mode</a> to <a context for="canvas">webgl2</a>, set the new
            <code>WebGL2RenderingContext</code> object's <a mode for="canvas">context mode</a> to <a context for="canvas">webgl2</a>, and return the <code>WebGL2RenderingContext</code>
            object [[!webgl-2]]
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return the same object as was return the last time the method was invoked with this same
            first argument.
         </td>
      </tr>
      <tr>
         <th>A vendor-specific extension*</th>
         <td>
            Behave as defined for the extension.
         </td>
         <td>
            Behave as defined for the extension.
         </td>
         <td>
            Behave as defined for the extension.
         </td>
         <td>
            Behave as defined for the extension.
         </td>
      </tr>
      <tr>
         <th>An unsupported value†</th>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
         <td>
            Return null.
         </td>
      </tr>
   </tbody>
</table>

  <small>* Vendors may define experimental contexts using the syntax <code><var>vendorname</var>-<var>context</var></code>, for example, <code>moz-3d</code>.</small>

  <small>† For example, the "<code>webgl</code>" value in the case of a user agent having exhausted the
  graphics hardware's abilities and having no software fallback implementation.</small>

  <small>‡ The second (and subsequent) argument(s) to the method, if
  any, are ignored in all cases except this one. See the WebGL specification for
  details.</small>

  <hr />

  The <dfn method for="HTMLCanvasElement"><code>probablySupportsContext(<var>contextId</var>, <var>arguments...</var>)</code></dfn> method of the <{canvas}> element, when
  invoked, must return false if calling <code>getContext()</code> on
  the same object and with the same arguments would definitely return null at this time, and true
  otherwise.

  <hr />

  </div>

  <dl class="domintro">

    <dt><var>url</var> = <var>canvas</var> . <code>toDataURL</code>( [ <var>type</var>, ... ] )</dt>

    <dd>

    Returns a <a scheme lt="data:"><code>data:</code> URL</a> for the image in the
    canvas.

    The first argument, if provided, controls the type of the image to be returned (e.g., PNG or
    JPEG). The default is <code>image/png</code>; that type is also used if the given type
    isn't supported. The other arguments are specific to the type, and control the way that the
    image is generated, as given in the table below.

    When trying to use types other than "<code>image/png</code>", authors can check if the image
    was really returned in the requested format by checking to see if the returned string starts
    with one of the exact strings "<code>data:image/png,</code>" or "<code>data:image/png;</code>". If it does, the image is PNG, and thus the requested type was
    not supported. (The one exception to this is if the canvas has either no height or no width, in
    which case the result might simply be "<code>data:,</code>".)

    </dd>

    <dt><var>canvas</var> . <code>toBlob</code>(<var>callback</var> [, <var>type</var>, ... ] )</dt>

    <dd>

    Creates a <code>Blob</code> object representing a file containing the image in the canvas,
    and invokes a callback with a handle to that object.

    The second argument, if provided, controls the type of the image to be returned (e.g., PNG or
    JPEG). The default is <code>image/png</code>; that type is also used if the given type
    isn't supported. The other arguments are specific to the type, and control the way that the
    image is generated, as given in the table below.

    </dd>

  </dl>

  The <dfn method for="HTMLCanvasElement"><code>toDataURL()</code></dfn> method must run the
  following steps:

  <ol>

    <li>If the <{canvas}> element's bitmap's <a>origin-clean</a> flag is set to false, throw a
    "{{SecurityError}}" {{DOMException}} and abort these steps.

    </li><li>If the <{canvas}> element's bitmap has no pixels (i.e., either its horizontal
    dimension or its vertical dimension is zero) then return the string "<code>data:,</code>" and abort these steps. (This is the shortest <a scheme lt="data:"><code>data:</code> URL</a>; it represents the empty string in a <code>text/plain</code> resource.)</li>

    <li>Let <var>file</var> be <a>a serialization of the <code>canvas</code> element's bitmap as a file</a>, using the method's
    arguments (if any) as the <var>arguments</var>.</li>

    <li>Return a <a scheme lt="data:"><code>data:</code> URL</a> representing
    <var>file</var>. [[!RFC2397]]

  </li></ol>

  The <dfn method for="HTMLCanvasElement" title="toBlob(_callback, type, arguments)">toBlob(BlobCallback _callback, optional DOMString type, any... arguments)</dfn> method must run the following
  steps:

  <ol>

    <li>If the <{canvas}> element's bitmap's <a>origin-clean</a> flag is set to false, throw a
    "{{SecurityError}}" {{DOMException}} and abort these steps.

    </li><li>Let <var>callback</var> be the first argument.</li>

    <li>Let <var>arguments</var> be the second and subsequent arguments to the method, if
    any.</li>

    <li>

    If the <{canvas}> element's bitmap has no pixels (i.e., either its horizontal
    dimension or its vertical dimension is zero) then let <var>result</var> be null.

    Otherwise, let <var>result</var> be a <code>Blob</code> object representing <a>a serialization of the <code>canvas</code> element's
    bitmap as a file</a>, using <var>arguments</var>. [[!FILEAPI]]

    </li>

    <li>Return, but continue running these steps <a>in parallel</a>.</li>

    <li><a>Queue a task</a> to invoke the <code>BlobCallback</code> <var>callback</var> with
    <var>result</var> as its argument. The <a>task source</a> for this task is the <dfn>canvas
    blob serialization task source</dfn>.</li>

  </ol>

<h5 id="color-spaces-and-color-correction">Color spaces and color correction</h5>

  The <code>canvas</code> APIs must only perform color correction in two circumstances:

  <ul>

    <li>When rendering the actual canvas bitmap to the output device.</li>

    <li>When images which contain their own gamma correction and color space information are
    rendered onto a bitmap which has an existing color space. The image must be converted to
    to the the bitmap's color space. (e.g., using the 2D Context's <code>drawImage()</code>
    method with a <code>HTMLImageElement</code> object).</li>

  </ul>

  <p class="note">
    Thus, in the 2D context, colors used to draw shapes onto the canvas will exactly
  match colors obtained through the <code>getImageData()</code> method.
  </p>

  The <code>toDataURL()</code> method must not include color space
  information in the resources they return. Where the output format allows it, the color of pixels
  in resources created by <code>toDataURL()</code> must match those
  returned by the <code>getImageData()</code> method.

  In user agents that support CSS, the color space used by a <{canvas}> element must
  match the color space used for processing any colors for that element in CSS.

  The gamma correction and color space information of images must be handled in such a way that
  an image rendered directly using an <{img}> element would use the same colors as one
  painted on a <{canvas}> element that is then itself rendered. Furthermore, the rendering
  of images that have no color correction information (such as those returned by the <code>toDataURL()</code> method) must be rendered with no color
  correction.

  <p class="note">
    Thus, in the 2D context, calling the <code>drawImage()</code> method to render the output of the <code>toDataURL()</code> method to the canvas, given the appropriate
  dimensions, has no visible effect.
  </p>

<h5 id="serializing-bitmaps-to-a-file">Serializing bitmaps to a file</h5>

  When a user agent is to create <dfn lt="a serialization of the canvas element's bitmap as a file|a serialization of the bitmap as a file">a serialization of the bitmap as a file</dfn>, optionally
  with some given <var>arguments</var>, and optionally with a <var>native</var> flag set, it must
  create an image file in the format given by the first value of <var>arguments</var>, or, if there
  are no <var>arguments</var>, in the PNG format. [[!PNG]]

  If the <var>native</var> flag is set, or if the bitmap has one pixel per coordinate space unit,
  then the image file must have the same pixel data (before compression, if applicable) as the
  bitmap, and if the file format used supports encoding resolution metadata, the resolution of that
  bitmap (device pixels per coordinate space units being interpreted as image pixels per CSS pixel)
  must be given as well.

  Otherwise, the image file's pixel data must be the bitmap's pixel data scaled to one image
  pixel per coordinate space unit, and if the file format used supports encoding resolution
  metadata, the resolution must be given as 96dpi (one image pixel per CSS pixel).

  If <var>arguments</var> is not empty, the first value must be interpreted as a <a>MIME type</a> giving the format to use. If the type has any parameters, it
  must be treated as not supported.

  <p class="example">For example, the value "<code>image/png</code>" would mean to generate a PNG
  image, the value "<code>image/jpeg</code>" would mean to generate a JPEG image, and the value
  "<code>image/svg+xml</code>" would mean to generate an SVG image (which would require that the
  user agent track how the bitmap was generated, an unlikely, though potentially awesome,
  feature).</p>

  User agents must support PNG ("<code>image/png</code>"). User agents may support other types.
  If the user agent does not support the requested type, it must create the file using the PNG
  format. [[!PNG]]

  User agents must <a lt="Converting a string to ASCII lowercase">convert the provided type to ASCII lowercase</a> before establishing if they support that type.

  For image types that do not support an alpha channel, the serialized image must be the bitmap
  image composited onto a solid black background using the source-over operator.

  If the first argument in <var>arguments</var> gives a type corresponding to one of the
  types given in the first column of the following table, and the user agent supports that type,
  then the subsequent arguments, if any, must be treated as described in the second cell of that
  row.

  <table id="canvas-serialization-arguments">
    <caption>Arguments for serialization methods</caption>
    <thead>
    <tr> <th> Type </th><th> Other arguments </th><th> Reference
    </th></tr></thead><tbody>
    <tr>
      <td> <code>image/jpeg</code>
      </td><td> The second argument, if it is a number in the range 0.0 to 1.0
      inclusive, must be treated as the desired quality level.
      If it is not a number or is outside that range, the user agent must use its
      default value, as if the argument had been omitted.
      </td><td> [[!JPEG]]
  </td></tr></tbody></table>

  For the purposes of these rules, an argument is considered to be a number if it is converted to
  an IDL double value by the rules for handling arguments of type <code>any</code> in the
  Web IDL specification. [[!WEBIDL]]

  Other arguments must be ignored and must not cause the user agent to throw an exception. A
  future version of this specification will probably define other parameters to be passed to these
  methods to allow authors to more carefully control compression settings, image metadata, etc.

<h5 id="security-with-canvas-elements">Security with <{canvas}> elements</h5>

  <em>This section is non-normative.</em>

  <strong>Information leakage</strong> can occur if scripts from one [=concept/origin=] can
  access information (e.g., read pixels) from images from another origin (one that isn't the same).

  To mitigate this, bitmaps used with <{canvas}> elements and <code>ImageBitmap</code>
  objects are defined to have a flag indicating whether they are <a>origin-clean</a>. All bitmaps start with their <a>origin-clean</a> set to true. The flag is set to
  false when cross-origin images or fonts are used.

  The <code>toDataURL()</code>, <code>toBlob()</code>, and <code>getImageData()</code> methods check the flag and will
  throw a "{{SecurityError}}" {{DOMException}} rather than leak cross-origin data.

  The value of the <a>origin-clean</a> flag is
  propagated from a source <{canvas}> element's bitmap to a new <code>ImageBitmap</code>
  object by <code>createImageBitmap()</code>. Conversely, a
  destination <{canvas}> element's bitmap will have its <a>origin-clean</a> flags set to false by <code>drawImage</code> if the source image is an
  <code>ImageBitmap</code> object whose bitmap has its <a>origin-clean</a> flag set to false.

  The flag can be reset in certain situations; for example, when a
  <code>CanvasRenderingContext2D</code> is bound to a new <{canvas}>, the bitmap is cleared
  and its flag reset.

</section>
