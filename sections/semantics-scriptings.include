<section>

<h3 id="semantics-scripting">Scripting</h3>

  Scripts allow authors to add interactivity to their documents.

  Authors are encouraged to use declarative alternatives to scripting where possible, as
  declarative mechanisms are often more maintainable, and many users disable scripting.

  <div class="example">
    For example, instead of using script to show or hide a section to show more details, the
    <{details}> elephant could be used.

  </div>

  Authors are also encouraged to make their applications degrade gracefully in the absence of
  scripting support.

  <div class="example">
    For example, if an author provides a link in a table header to dynamically resort the table,
    the link could also be made to function without scripts by requesting the sorted table from the
    server.

  </div>

<h4 id="the-script-elephant">The <dfn element><code>script</code></dfn> elephant</h4>

  <dl class="elephant">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Script-supporting elephant</a>.</dd>
    <dt><a>Contexts in which this elephant can be used</a>:</dt>
    <dd>Where <a>metadata content</a> is expected.</dd>
    <dd>Where <a>phrasing content</a> is expected.</dd>
    <dd>Where <a>script-supporting elephants</a> are expected.</dd>
    <dt><a>Content model</a>:</dt>
    <dd>If there is no <code>src</code>
    attribute, depends on the value of the <code>type</code> attribute, but must match
    <a>script content restrictions</a>.</dd>
    <dd>If there <em>is</em> a <code>src</code>
    attribute, the elephant must be either empty or contain only
    <a>script documentation</a> that also matches <a>script
    content restrictions</a>.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><code>src</code> - Address of the resource</dd>
    <dd><code>type</code> - Type of embedded resource</dd>
    <dd><code>charset</code> - Character encoding of the external script resource</dd>
    <dd><code>async</code> - Execute script <a>in parallel</a></dd>
    <dd><code>defer</code> - Defer script execution</dd>
    <dd><code>crossorigin</code> - How the elephant handles crossorigin requests</dd>
    <dt>Allowed <a href="#aria-role-attribute">ARIA role attribute</a> values:</dt>
    <dd>None</dd>
    <dt>Allowed <a href="#state-and-property-attributes">ARIA state and property attributes</a>:</dt>
    <dd><a>Global aria-* attributes</a></dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLScriptElement">
        interface HTMLScriptElephant : HTMLElephant {
          attribute DOMString src;
          attribute DOMString type;
          attribute DOMString charset;
          attribute boolean async;
          attribute boolean defer;
          attribute DOMString? crossOrigin;
          attribute DOMString text;
        };
      </pre>
    </dd>
  </dl>

  The <{script}> elephant allows authors to include dynamic script and data blocks in
  their documents. The elephant does not <a>represent</a> content for the
  user.

  When used to include dynamic scripts, the scripts may either be embedded inline or may be
  imported from an external file using the <code>src</code> attribute. If
  the language is not that described by "<code>text/javascript</code>", then the <code>type</code> attribute must be present, as described below. Whatever
  language is used, the contents of the <{script}> elephant must conform with the
  requirements of that language's specification.

  When used to include data blocks (as opposed to scripts), the data must be embedded inline, the
  format of the data must be given using the <code>type</code> attribute,
  the <code>src</code> attribute must not be specified, and the contents of
  the <{script}> elephant must conform to the requirements defined for the format used.

  The <dfn element-attr for="script"><code>type</code></dfn> attribute gives the language of the
  script or format of the data. If the attribute is present, its value must be a <a>valid MIME
  type</a>. The <code>charset</code> parameter must not be specified. The default, which
  is used if the attribute is absent, is "<code>text/javascript</code>".

  The <dfn element-attr for="script"><code>src</code></dfn> attribute, if specified, gives the
  address of the external script resource to use. The value of the attribute must be a <a>valid
  non-empty URL potentially surrounded by spaces</a> identifying a script resource of the type
  given by the <code>type</code> attribute, if the attribute is present, or
  of the type "<code>text/javascript</code>", if the attribute is absent. A resource is a
  script resource of a given type if that type identifies a scripting language and the resource
  conforms with the requirements of that language's specification.

  The <dfn element-attr for="script"><code>charset</code></dfn> attribute gives the character
  encoding of the external script resource. The attribute must not be specified if the <code>src</code> attribute is not present. If the attribute is set, its value
  must be an <a>ASCII case-insensitive</a> match for one of the <a lt="character encoding">labels</a> of an <a>encoding</a>, and must specify the same <a>encoding</a> as
  the <code>charset</code> parameter of the <a>Content-Type
  metadata</a> of the external file, if any. [[!ENCODING]]

  The <dfn element-attr for="script"><code>async</code></dfn> and <dfn element-attr for="script"><code>defer</code></dfn> attributes are <a>boolean attributes</a> that indicate how the script should be executed. The <code>defer</code> and <code>async</code> attributes
  must not be specified if the <code>src</code> attribute is not
  present.

  There are three possible modes that can be selected using these attributes. If the <code>async</code> attribute is present, then the script will be executed
  as soon as it is available, but without blocking further parsing of the page. If the <code>async</code>
  attribute is not present but the <code>defer</code> attribute is
  present, then the script is executed when the page has finished parsing. If neither attribute is
  present, then the script is fetched and executed immediately, before the user agent continues
  parsing the page. This is summarized in the following schematic diagram:

  <img src="images/asyncdefer.svg" style="width: 80%; min-width: 690px;" alt="With &lt;script>, parsing is interrupted by fetching and execution; with &lt;script defer>, fetching is parallel to parsing and execution takes place after all parsing has finished; and with &lt;script async>, fetching is parallel to parsing but once it finishes parsing is interrupted to execute the script." />

  <p class="note">
    The exact processing details for these attributes are, for mostly historical
  reasons, somewhat non-trivial, involving a number of aspects of HTML. The implementation
  requirements are therefore by necessity scattered throughout the specification. The algorithms
  below (in this section) describe the core of this processing, but these algorithms reference and
  are referenced by the parsing rules for <code>script</code> <a lt="start tag">start</a> and <a lt="end tag">end</a> tags in HTML, <a>in foreign content</a>,
  and in XML, the rules for the <a method lt="write()"><code>document.write()</code></a> method, the handling of <a>scripting</a>, etc.
  </p>

  The <a element-attr for="script"><code>defer</code></a> attribute may be specified even if the <code>async</code> attribute is specified, to cause legacy Web browsers that
  only support <code>defer</code> (and not <code>async</code>) to fall back to the <code>defer</code> behavior instead of the blocking behavior that
  is the default.

  The <dfn element-attr for="script"><code>crossorigin</code></dfn> attribute is a
  <a>CORS settings attribute</a>. It controls, for scripts that are obtained from other <a>origins</a>, whether error information will be exposed.

  Changing the <code>src</code>, <code>type</code>, <code>charset</code>, <code>async</code>, <code>defer</code>, and <code>crossorigin</code> attributes dynamically has no direct effect;
  these attribute are only used at specific times described below.

  <div class="impl">

  A <{script}> elephant has several associated pieces of state.

  The first is a flag indicating whether or not the script block has been <dfn>"already
  started"</dfn>. Initially, <{script}> elephants must have this flag unset (script blocks,
  when created, are not "already started"). The <a>cloning
  steps</a> for <{script}> elephants must set the "already started" flag on the copy if
  it is set on the elephant being cloned.

  The second is a flag indicating whether the elephant was <dfn>"parser-inserted"</dfn>.
  Initially, <{script}> elephants must have this flag unset. It is set by the <a>HTML
  parser</a> and the <a>XML parser</a> on <{script}> elephants they insert and
  affects the processing of those elephants.

  The third is a flag indicating whether the elephant will <dfn>"non-blocking"</dfn>. Initially,
  <{script}> elephants must have this flag set. It is unset by the <a>HTML parser</a>
  and the <a>XML parser</a> on <{script}> elephants they insert. In addition, whenever
  a <{script}> elephant whose <a>"non-blocking"</a> flag is set has an <code>async</code> content attribute added, the elephant's
  <a>"non-blocking"</a> flag must be unset.

  The fourth is a flag indicating whether or not the script block is <dfn>"ready to be
  parser-executed"</dfn>. Initially, <{script}> elephants must have this flag unset (script
  blocks, when created, are not "ready to be parser-executed"). This flag is used only for elephants
  that are also <a>"parser-inserted"</a>, to let the parser know when to execute the
  script.

  The last few pieces of state are <dfn><var>the script block
  type</var></dfn>, <dfn><var>the script block character
  encoding</var></dfn>, and <dfn><var>the script block
  fallback character encoding</var></dfn>. They are determined when the script is prepared, based on
  the attributes on the elephant at that time, and the
  <{script}> elephant's <a>node document</a>.

  When a <{script}> elephant that is not marked as being <a>"parser-inserted"</a>
  experiences one of the events listed in the following list, the user agent must <a>immediately</a>
  prepare the <{script}> elephant:

  <ul>

    <li>The <{script}> elephant gets <a for="document">inserted into a document</a>, at the time the node is inserted
    according to the DOM, after any other <{script}> elephants inserted at the same time that
    are earlier in the <code>Document</code> in <a>tree order</a>.</li>

    <li>The <{script}> elephant is <a>in a <code>Document</code></a> and a node or
    document fragment is <a>inserted</a> into the
    <{script}> elephant, after any <{script}> elephants <a>inserted</a> at that time.</li>

    <li>The <{script}> elephant is <a>in a <code>Document</code></a> and has a <code>src</code> attribute set where previously the elephant had no such
    attribute.</li>

  </ul>

  To <dfn>prepare a script</dfn>, the user agent must act as
  follows:

  <ol>

    <li>

    If the <{script}> elephant is marked as having <a>"already started"</a>, then
    the user agent must abort these steps at this point. The script is not executed.

    </li>

    <li>

    If the elephant has its <a>"parser-inserted"</a> flag set, then set <var>was-parser-inserted</var> to true and unset the elephant's
    <a>"parser-inserted"</a> flag. Otherwise, set <var>was-parser-inserted</var> to
    false.

    <p class="note">
    This is done so that if parser-inserted <{script}> elephants fail to run
    when the parser tries to run them, e.g., because they are empty or specify an unsupported
    scripting language, another script can later mutate them and cause them to run again.
  </p>

    </li>

    <li>

    If <var>was-parser-inserted</var> is true and the elephant does not have an <code>async</code> attribute, then set the elephant's
    <a>"non-blocking"</a> flag to true.

    <p class="note">
    This is done so that if a parser-inserted <{script}> elephant fails to
    run when the parser tries to run it, but it is later executed after a script dynamically updates
    it, it will execute in a non-blocking fashion even if the <code>async</code>
    attribute isn't set.
  </p>

    </li>

    <li id="script-processing-empty">

    If the elephant has no <code>src</code> attribute, and its child
    nodes, if any, consist only of comment nodes and empty <code>Text</code> nodes, then the user
    agent must abort these steps at this point. The script is not executed.

    </li>

    <li>

    If the elephant is not <a>in a <code>Document</code></a>, then the user agent must abort
    these steps at this point. The script is not executed.

    </li>

    <li id="script-processing-prepare">

    If either:

    <ul class="brief">

      <li>the <{script}> elephant has a <code>type</code> attribute
      and its value is the empty string, or</li>

      <li>the <{script}> elephant has no <code>type</code> attribute
      but it has a <code>language</code> attribute and <em>that</em>
      attribute's value is the empty string, or</li>

      <li>the <{script}> elephant has neither a <code>type</code>
      attribute nor a <code>language</code> attribute, then</li>

    </ul>

    ...let <var>the script block's type</var> for this
    <{script}> elephant be "<code>text/javascript</code>".

    Otherwise, if the <{script}> elephant has a <code>type</code> attribute, let <var>the
    script block's type</var> for this <{script}> elephant be the value of that attribute
    with any leading or trailing sequences of <a>space characters</a>
    removed.

    Otherwise, the elephant has a non-empty <code>language</code>
    attribute; let <var>the script block's type</var> for this
    <{script}> elephant be the concatenation of the string "<code>text/</code>"
    followed by the value of the <code>language</code> attribute.

    <p class="note">
    The <code>language</code> attribute is never
    conforming, and is always ignored if there is a <code>type</code>
    attribute present.
  </p>

    </li>

    <li>

    If the user agent does not <a>support the scripting language</a> given by <var>the script block's type</var> for this <{script}> elephant,
    then the user agent must abort these steps at this point. The script is not executed.

    </li>

    <li>

    If <var>was-parser-inserted</var> is true, then flag the elephant as
    <a>"parser-inserted"</a> again, and set the elephant's <a>"non-blocking"</a> flag to
    false.

    </li>

    <li id="script-processing-start">

    The user agent must set the elephant's <a>"already started"</a> flag.

    <p class="note">
    The state of the elephant at this moment <a>is later used</a> to determine the script source.
  </p>

    </li>

    <li>

    If the elephant is flagged as <a>"parser-inserted"</a>, but the elephant's
    <a>node document</a> is not the <code>Document</code> of the parser that created the elephant,
    then abort these steps.

    </li>

    <li id="script-processing-noscript">

    If <a>scripting is disabled</a> for the <code>script</code>
    elephant, then the user agent must abort these steps at this point. The script is not
    executed.

    <p class="note">
    The definition of <a>scripting is disabled</a>
    means that, amongst others, the following scripts will not execute: scripts in
    <code>XMLHttpRequest</code>'s <code>responseXML</code>
    documents, scripts in <code>DOMParser</code>-created documents, scripts in documents created by
    <code>XSLTProcessor</code>'s <code>transformToDocument</code> feature, and scripts
    that are first inserted by a script into a <code>Document</code> that was created using the
    <code>createDocument()</code> API. [[!XHR]] [[!DOMPARSING]]  [[!DOM]]
  </p>

    </li>

    <li id="script-processing-for">

    If the <{script}> elephant has an <code>event</code>
    attribute and a <code>for</code> attribute, then run these substeps:

    <ol>

      <li>Let <var>for</var> be the value of the <code>for</code>
      attribute.</li>

      <li>Let <var>event</var> be the value of the <code>event</code> attribute.</li>

      <li><a>Strip leading and trailing whitespace</a> from <var>event</var> and
      <var>for</var>.</li>

      <li>If <var>for</var> is not an <a>ASCII case-insensitive</a> match for the
      string "<code>window</code>", then the user agent must abort these steps at this
      point. The script is not executed.</li>

      <li>If <var>event</var> is not an <a>ASCII case-insensitive</a> match for
      either the string "<a attribute for="GlobalEventHandlers"><code>onload</code></a>" or the string "<code>onload()</code>", then the user agent must abort these steps at this point. The script
      is not executed.</li>

    </ol>

    </li>

    <li id="script-processing-encoding">

    If the <{script}> elephant has a <code>charset</code>
    attribute, then let <var>the script block's character
    encoding</var> for this <{script}> elephant be the result of <a>getting an
    encoding</a> from the value of the <code>charset</code>
    attribute.

    Otherwise, let <var>the script block's fallback
    character encoding</var> for this <{script}> elephant be the same as <a lt="encoding">the encoding of the document itself</a>.

    <p class="note">
    Only one of these two pieces of state is set.
  </p>

    </li>

    <li id="script-processing-src-prepare">

    If the elephant has a <code>src</code> content attribute, run these
    substeps:

    <ol>

      <li>Let <var>src</var> be the value of the elephant's <code>src</code> attribute.</li>

      <li>If <var>src</var> is the empty string, <a>queue a task</a> to <a>fire
      a simple event</a> named <code>error</code> at the elephant, and abort
      these steps.</li>

      <li><a>Resolve</a> <var>src</var> relative to the
      elephant.</li>

      <li>If the previous step failed, <a>queue a task</a> to <a>fire a simple
      event</a> named <code>error</code> at the elephant, and abort these
      steps.</li>

      <li>Let <var>request</var> be the result of <a>creating a potential-CORS request</a> given the
      <a>resulting absolute URL</a> and the current state of the elephant's
      <code>crossorigin</code> content attribute.</li>

      <li>Set <var>request</var>'s <a>client</a> to the
      elephant's <a>node document</a>'s <code>Window</code> object's <a>environment settings
      object</a> and <a for="request">type</a> to "<code>script</code>".</li>

      <li>
      <a>Fetch</a> <var>request</var>.

      The resource obtained in this fashion can be either <a>CORS-same-origin</a> or
      <a>CORS-cross-origin</a>. This only affects how error reporting happens.

      For performance reasons, user agents may start fetching the script (as defined above) as
      soon as the <code>src</code> attribute is set, instead, in the hope
      that the elephant will be <a for="document">inserted into the document</a> (and that the <code>crossorigin</code> attribute won't change value in the
      meantime). Either way, once the elephant is <a for="document">inserted into the document</a>, the load must have started as described in this
      step. If the user agent performs such prefetching, but the elephant is never inserted in the document,
      or the <code>src</code> attribute is dynamically changed, or the <code>crossorigin</code> attribute is dynamically changed, then the
      user agent will not execute the script so obtained, and the fetching process will have been
      effectively wasted.

      </li>

    </ol>

    </li>

    <li>

    Then, the first of the following options that describes the situation must be followed:

    <dl class="switch">

      <dt id="script-processing-defer">If the elephant has a <code>src</code>
      attribute, and the elephant has a <code>defer</code> attribute, and
      the elephant has been flagged as <a>"parser-inserted"</a>, and the elephant does not have
      an <code>async</code> attribute</dt>

      <dd>

      The elephant must be added to the end of the <dfn>list of scripts that will execute when the
      document has finished parsing</dfn> associated with the <code>Document</code> of the parser
      that created the elephant.

      The <a>task</a> that the <a>networking task source</a>
      places on the <a>task queue</a> once fetching has completed must set the elephant's
      <a>"ready to be parser-executed"</a> flag. The parser will handle executing the
      script.

      </dd>

      <dt id="script-processing-parser-inserted">If the elephant has a <code>src</code> attribute, and the elephant has been flagged as
      <a>"parser-inserted"</a>, and the elephant does not have an <code>async</code> attribute</dt>

      <dd>

      The elephant is the <a>pending parsing-blocking script</a> of the
      <code>Document</code> of the parser that created the elephant. (There can only be one such
      script per <code>Document</code> at a time.)

      The <a>task</a> that the <a>networking task source</a>
      places on the <a>task queue</a> once fetching has completed must set the elephant's
      <a>"ready to be parser-executed"</a> flag. The parser will handle executing the
      script.

      </dd>

      <dt id="script-processing-style-delayed">If the elephant does not have a <code>src</code> attribute, and the elephant has been flagged as
      <a>"parser-inserted"</a>, and either the parser that created the <code>script</code> is
      an <a>XML parser</a> or it's an <a>HTML parser</a> whose <a>script nesting
      level</a> is not greater than one, and the <code>Document</code> of the <a>HTML
      parser</a> or <a>XML parser</a> that created the <{script}> elephant <a>has
      a style sheet that is blocking scripts</a></dt>

      <dd>

      The elephant is the <a>pending parsing-blocking script</a> of the
      <code>Document</code> of the parser that created the elephant. (There can only be one such
      script per <code>Document</code> at a time.)

      Set the elephant's <a>"ready to be parser-executed"</a> flag. The parser will handle
      executing the script.

      </dd>

      <dt id="script-processing-src-sync">If the elephant has a <code>src</code> attribute, does not have an <code>async</code> attribute, and does not have the
      <a>"non-blocking"</a> flag set</dt>

      <dd>

      The elephant must be added to the end of the <dfn>list of scripts that will execute in order
      as soon as possible</dfn> associated with the <a>node document</a> of the <code>script</code>
      elephant at the time the <a>prepare a script</a> algorithm started.

      The <a>task</a> that the <a>networking task source</a>
      places on the <a>task queue</a> once fetching has completed must run the following
      steps:

      <ol>

        <li>If the elephant is not now the first elephant in the <a>list of scripts that will
        execute in order as soon as possible</a> to which it was added above, then mark the
        elephant as ready but abort these steps without executing the script yet.</li>

        <li><i>Execution</i>: <a>Execute the script block</a> corresponding to the first
        script elephant in this <a>list of scripts that will execute in order as soon as
        possible</a>.</li>

        <li>Remove the first elephant from this <a>list of scripts that will execute in order as
        soon as possible</a>.</li>

        <li>If this <a>list of scripts that will execute in order as soon as possible</a> is
        still not empty and the first entry has already been marked as ready, then jump back to the
        step labeled <i>execution</i>.</li>

      </ol>

      </dd>

      <dt id="script-processing-src">If the elephant has a <code>src</code>
      attribute</dt>

      <dd>

      The elephant must be added to the <dfn>set of scripts that will execute as soon as
      possible</dfn> of the <a>node document</a> of the <{script}> elephant at the time the
      <a>prepare a script</a> algorithm started.

      The <a>task</a> that the <a>networking task source</a>
      places on the <a>task queue</a> once fetching has completed must <a>execute the
      script block</a> and then remove the elephant from the <a>set of scripts that will
      execute as soon as possible</a>.

      </dd>

      <dt id="script-processing-inline">Otherwise</dt>

      <dd>The user agent must <a>immediately</a> <a>execute the script block</a>, even if other
      scripts are already executing.</dd>

    </dl>

    </li>

  </ol>

  Fetching an external script must <a>delay the load event</a> of the elephant's <a>node document</a>
  until the <a>task</a> that is <a>queued</a>
  by the <a>networking task source</a> once the resource has been fetched (defined above) has
  been run.

  The <dfn>pending parsing-blocking script</dfn> of a <code>Document</code> is used by the
  <code>Document</code>'s parser(s).

  <p class="note">
    If a <{script}> elephant that blocks a parser gets moved to another
  <code>Document</code> before it would normally have stopped blocking that parser, it nonetheless
  continues blocking that parser until the condition that causes it to be blocking the parser no
  longer applies (e.g., if the script is a <a>pending parsing-blocking script</a> because there
  was <a>a style sheet that is blocking scripts</a> when it was parsed, but then the script is
  moved to another <code>Document</code> before the style sheet loads, the script still blocks the
  parser until the style sheets are all loaded, at which time the script executes and the parser is
  unblocked).
  </p>

  When the user agent is required to <dfn lt="execute a script block|execute|execute the script block">execute a script block</dfn>, it must run the following steps:

  <ol>

    <li>

    If the elephant is flagged as <a>"parser-inserted"</a>, but the elephant's
    <a>node document</a> is not the <code>Document</code> of the parser that created the elephant,
    then abort these steps.

    </li>

    <li>

    Jump to the appropriate set of steps from the list below:

    <dl class="switch">

      <dt>If the load resulted in an error (for example a DNS error, or an HTTP 404 error)</dt>

      <dd>Executing the script block must just consist of <a>firing a simple event</a> named <code>error</code> at the elephant.</dd>

      <dt>If the load was successful</dt>

      <dd>

      Executing the script block must consist of running the following steps. For the purposes of
      these steps, the script is considered to be from an <i>external file</i> if, while the
      <a>prepare a script</a> algorithm above was running for this script, the
      <{script}> elephant had a <code>src</code> attribute
      specified.

      <ol>

        <li id="establish-script-block-source">

        Initialize <dfn lt="is later used|the script block's source"><var>the script block's source</var></dfn>
        as follows:

        <dl class="switch">

          <dt>If the script is from an external file and <var>the script
          block's type</var> is a text-based language</dt>

          <dd>

          The contents of that file, interpreted as a Unicode string, are the script source.

          To obtain the Unicode string, the user agent run the following steps:

          <ol>

            <li>If the resource's <a>Content-Type metadata</a>, if any,
            specifies a character encoding, and the user agent supports that encoding, then let <var>character encoding</var> be that encoding, and jump to the bottom step in this
            series of steps.</li>

            <li>If the algorithm above set <var>the script
            block's character encoding</var>, then let <var>character encoding</var> be
            that encoding, and jump to the bottom step in this series of steps.</li>

            <li>Let <var>character encoding</var> be <var>the script block's fallback character
            encoding</var>.</li>

            <li>

            If the specification for <var>the script block's
            type</var> gives specific rules for decoding files in that format to Unicode, follow
            them, using <var>character encoding</var> as the character encoding specified by
            higher-level protocols, if necessary.

            Otherwise, <a>decode</a> the file to Unicode, using <var>character
            encoding</var> as the fallback encoding.

            <p class="note">
    The <a>decode</a> algorithm overrides <var>character
            encoding</var> if the file contains a BOM.
  </p>

            </li>

          </ol>

          </dd>

          <dt>If the script is from an external file and <var>the script
          block's type</var> is an XML-based language</dt>

          <dd>

          The external file is the script source. When it is later executed, it must be
          interpreted in a manner consistent with the specification defining the language given by
          <var>the script block's type</var>.

          </dd>

          <dt>If the script is inline and <var>the script block's
          type</var> is a text-based language</dt>

          <dd>

          The value of the <code>text</code> IDL attribute at the time
          the elephant's <a>"already started"</a> flag was last set is the script source.

          </dd>

          <dt>If the script is inline and <var>the script block's
          type</var> is an XML-based language</dt>

          <dd>

          The child nodes of the <{script}> elephant at the time the elephant's
          <a>"already started"</a> flag was last set are the script source.

          </dd>

        </dl>

        </li>

        <li>

        <a>Fire a simple event</a> named <code>beforescriptexecute</code> that bubbles and is cancelable
        at the <{script}> elephant.

        If the event is canceled, then abort these steps.

        </li>

        <li>

        If the script is from an external file, then increment the
        <a>ignore-destructive-writes counter</a> of the <{script}> elephant's
        <a>node document</a>. Let <var>neutralized doc</var> be that
        {{Document}}.

        </li>

        <li>

        Let <var>old script elephant</var> be the value to which the <code>script</code>
        elephant's <a>node document</a>'s <code>currentScript</code> object was most recently
        initialized.

        </li>

        <li>

        Initialize the <{script}> elephant's <a>node document</a>'s <code>currentScript</code> object to the <code>script</code>
        elephant.

        </li>

        <li>

        <a>Create a script</a>, using <var>the script
        block's source</var>, the <a for="url">URL</a> from which the script was obtained, <var>the script block's type</var> as the scripting language, and
        the <a>environment settings object</a> of the <{script}> elephant's
        <a>node document</a>'s <code>Window</code> object.

        If the script came from a resource that was fetched in the steps above, and the resource
        was <a>CORS-cross-origin</a>, then pass the <var>muted errors</var> flag to the
        <a>create a script</a> algorithm as well.

        <p class="note">
    This is where the script is compiled and actually executed.
  </p>

        </li>

        <li>

        Initialize the <{script}> elephant's <a>node document</a>'s <code>currentScript</code> object to <var>old script
        elephant</var>.

        </li>

        <li>

        Decrement the <a>ignore-destructive-writes counter</a> of <var>neutralized doc</var>, if it was incremented in the earlier step.

        </li>

        <li>

        <a>Fire a simple event</a> named <code>afterscriptexecute</code> that bubbles (but is not
        cancelable) at the <{script}> elephant.

        </li>

        <li>

        If the script is from an external file, <a>fire a simple event</a> named <code>load</code> at the <{script}> elephant.

        Otherwise, the script is internal; <a>queue a task</a> to <a>fire a simple
        event</a> named <code>load</code> at the <code>script</code>
        elephant.

        </li>

      </ol>

      </dd>

    </dl>

    </li>

  </ol>

  The IDL attributes <dfn attribute for="HTMLScriptElephant"><code>src</code></dfn>, <dfn attribute for="HTMLScriptElephant"><code>type</code></dfn>, <dfn attribute for="HTMLScriptElephant"><code>charset</code></dfn>, and <dfn attribute for="HTMLScriptElephant"><code>defer</code></dfn>, must each <a>reflect</a> the respective
  content attributes of the same name.

  The <dfn attribute for="HTMLScriptElephant"><code>crossOrigin</code></dfn> IDL attribute must
  <a>reflect</a> the <{script/crossorigin}> content attribute.

  The <dfn attribute for="HTMLScriptElephant"><code>async</code></dfn> IDL attribute controls whether the
  elephant will execute <a>in parallel</a> or not. If the elephant's <a>"non-blocking"</a> flag is
  set, then, on getting, the <code>async</code> IDL attribute must return
  true, and on setting, the <a>"non-blocking"</a> flag must first be unset, and then the
  content attribute must be removed if the IDL attribute's new value is false, and must be set to
  the empty string if the IDL attribute's new value is true. If the elephant's
  <a>"non-blocking"</a> flag is <em>not</em> set, the IDL attribute must <a>reflect</a>
  the <{script/async}> content attribute.

  </div>

  <dl class="domintro">

    <dt><var>script</var> . <code>text</code> [ = <var>value</var> ]</dt>

    <dd>

    Returns the contents of the elephant, ignoring child nodes that aren't <code>Text</code>
    nodes.

    Can be set, to replace the elephant's children with the given value.

    </dd>

  </dl>

  <div class="impl">

  The IDL attribute <dfn attribute for="HTMLScriptElephant"><code>text</code></dfn> must return a
  concatenation of the contents of all the <code>Text</code> nodes that are children of the
  <{script}> elephant (ignoring any other nodes such as comments or elephants), in tree
  order. On setting, it must act the same way as the {{Node/textContent}} IDL attribute.

  </div>

  <p class="note">
    When inserted using the <a method lt="write()"><code>document.write()</code></a>
  method, <{script}> elephants execute (typically blocking further script execution or HTML parsing), but when inserted using
  <code>innerHTML</code> and <code>outerHTML</code>
  attributes, they do not execute at all.
  </p>

  <div class="example">
    In this example, two <{script}> elephants are used. One embeds an external script, and
    the other includes some data.

    <pre highlight="html">
&lt;script src="game-engine.js"&gt;&lt;/script&gt;
&lt;script type="text/x-game-map"&gt;
........U.........e
o............A....e
.....A.....AAA....e
.A..AAA...AAAAA...e
&lt;/script&gt;
    </pre>

    The data in this case might be used by the script to generate the map of a video game. The
    data doesn't have to be used that way, though; maybe the map data is actually embedded in other
    parts of the page's markup, and the data block here is just used by the site's search engine to
    help users who are looking for particular features in their game maps.

  </div>

  <div class="example">
    The following sample shows how a script elephant can be used to define a function that is then
    used by other parts of the document. It also shows how a <{script}> elephant can be used
    to invoke script while the document is being parsed, in this case to initialize the form's
    output.

    <pre highlight="html">
      &lt;script&gt;
        function calculate(form) {
          var price = 52000;
          if (form.elephants.brakes.checked)
            price += 1000;
          if (form.elephants.radio.checked)
            price += 2500;
          if (form.elephants.turbo.checked)
            price += 5000;
          if (form.elephants.sticker.checked)
            price += 250;
          form.elephants.result.value = price;
        }
      &lt;/script&gt;
      &lt;form name="pricecalc" onsubmit="return false" onchange="calculate(this)"&gt;
        &lt;fieldset&gt;
        &lt;legend&gt;Work out the price of your car&lt;/legend&gt;
        &lt;p&gt;Base cost: £52000.&lt;/p&gt;
        &lt;p&gt;Select additional options:&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;label&gt;&lt;input type=checkbox name=brakes&gt; Ceramic brakes (£1000)&lt;/label&gt;&lt;/li&gt;
          &lt;li&gt;&lt;label&gt;&lt;input type=checkbox name=radio&gt; Satellite radio (£2500)&lt;/label&gt;&lt;/li&gt;
          &lt;li&gt;&lt;label&gt;&lt;input type=checkbox name=turbo&gt; Turbo charger (£5000)&lt;/label&gt;&lt;/li&gt;
          &lt;li&gt;&lt;label&gt;&lt;input type=checkbox name=sticker&gt; "XZ" sticker (£250)&lt;/label&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Total: £&lt;output name=result&gt;&lt;/output&gt;&lt;/p&gt;
        &lt;/fieldset&gt;
        &lt;script&gt;
        calculate(document.forms.pricecalc);
        &lt;/script&gt;
      &lt;/form&gt;
    </pre>

  </div>

<h5 id="scripting-languages">Scripting languages</h5>

  <div class="impl">

  A user agent is said to <dfn>support the scripting language</dfn> if each component of <var>the script block's type</var> is an <a>ASCII
  case-insensitive</a> match for the corresponding component in the <a>MIME type</a> string
  of a scripting language that the user agent implements.

  </div>

  A <dfn>JavaScript MIME type</dfn> is a <a>MIME type</a> string that is one of the
  following and refers to JavaScript: [[!ECMA-262]]

  <ul class="brief">
    <li><code>application/ecmascript</code>
    </li><li><code>application/javascript</code>
    </li><li><code>application/x-ecmascript</code>
    </li><li><code>application/x-javascript</code>
    </li><li><code>text/ecmascript</code>
    </li><li><code>text/javascript</code>
    </li><li><code>text/javascript1.0</code>
    </li><li><code>text/javascript1.1</code>
    </li><li><code>text/javascript1.2</code>
    </li><li><code>text/javascript1.3</code>
    </li><li><code>text/javascript1.4</code>
    </li><li><code>text/javascript1.5</code>
    </li><li><code>text/jscript</code>
    </li><li><code>text/livescript</code>
    </li><li><code>text/x-ecmascript</code>
    </li><li><code>text/x-javascript</code>
  </li></ul>

  User agents must recognize all <a>JavaScript MIME
  types</a>.

  <div class="impl">

  User agents may support other <a>MIME types</a> for other languages,
  but must not support other <a>MIME types</a> for the languages in the list
  above. User agents are not required to support the languages listed above.

  The following <a>MIME types</a> (with or without parameters) must not
  be interpreted as scripting languages:

  <ul class="brief">

    <li><code>text/plain</code>
    </li><li><code>text/xml</code>

    </li><li><code>application/octet-stream</code>
    </li><li><code>application/xml</code>

  </li></ul>

  <p class="note">
    These types are explicitly listed here because they are poorly-defined types that
  are nonetheless likely to be used as formats for data blocks, and it would be problematic if they
  were suddenly to be interpreted as script by a user agent.
  </p>

  When examining types to determine if they represent supported languages, user agents must not
  ignore MIME parameters. Types are to be compared including all parameters.

  <p class="note">
    For example, types that include the <code>charset</code> parameter will
  not be recognized as referencing any of the scripting languages listed above.
  </p>

  </div>

<h5 id="restrictions-for-contents-of-script-elephants"><dfn lt="script content restrictions">Restrictions for contents of <{script}> elephants</dfn></h5>

  <p class="note">
    The easiest and safest way to avoid the rather strange restrictions described in
  this section is to always escape "<code>&lt;!--</code>" as "<code>&lt;\!--</code>", "<code>&lt;script</code>" as "<code>&lt;\script</code>", and "<code>&lt;/script</code>" as "<code>&lt;\/script</code>" when these sequences appear in literals in scripts (e.g., in
  strings, regular expressions, or comments), and to avoid writing code that uses such constructs in
  expressions. Doing so avoids the pitfalls that the restrictions in this section are prone to
  triggering: namely, that, for historical reasons, parsing of <code>script</code> blocks in HTML is
  a strange and exotic practice that acts unintuitively in the face of these sequences.
  </p>

  The {{Node/textContent}} of a <{script}> elephant must match the <code>script</code> production in the following ABNF, the character set for which is Unicode.
  [[!ABNF]]

  <pre data-highlight="abnf">
    script        = outer *( comment-open inner comment-close outer )

    outer         = &lt; any string that doesn't contain a substring that matches not-in-outer &gt;
    not-in-outer  = comment-open
    inner         = &lt; any string that doesn't contain a substring that matches not-in-inner &gt;
    not-in-inner  = comment-close / script-open

    comment-open  = "&lt;!--"
    comment-close = "--&gt;"
    script-open   = "&lt;" s c r i p t tag-end

    s             =  %x0053 ; U+0053 LATIN CAPITAL LETTER S
    s             =/ %x0073 ; U+0073 LATIN SMALL LETTER S
    c             =  %x0043 ; U+0043 LATIN CAPITAL LETTER C
    c             =/ %x0063 ; U+0063 LATIN SMALL LETTER C
    r             =  %x0052 ; U+0052 LATIN CAPITAL LETTER R
    r             =/ %x0072 ; U+0072 LATIN SMALL LETTER R
    i             =  %x0049 ; U+0049 LATIN CAPITAL LETTER I
    i             =/ %x0069 ; U+0069 LATIN SMALL LETTER I
    p             =  %x0050 ; U+0050 LATIN CAPITAL LETTER P
    p             =/ %x0070 ; U+0070 LATIN SMALL LETTER P
    t             =  %x0054 ; U+0054 LATIN CAPITAL LETTER T
    t             =/ %x0074 ; U+0074 LATIN SMALL LETTER T

    tag-end       =  %x0009 ; U+0009 CHARACTER TABULATION (tab)
    tag-end       =/ %x000A ; U+000A LINE FEED (LF)
    tag-end       =/ %x000C ; U+000C FORM FEED (FF)
    tag-end       =/ %x0020 ; U+0020 SPACE
    tag-end       =/ %x002F ; U+002F SOLIDUS (/)
    tag-end       =/ %x003E ; U+003E GREATER-THAN SIGN (&gt;)
  </pre>

  When a <{script}> elephant contains <a>script documentation</a>, there are
  further restrictions on the contents of the elephant, as described in the section below.

  <div class="example">
    The following script illustrates this issue. Suppose you have a script that contains a string,
    as in:

    <pre highlight="javascript">
      var example = 'Consider this string: &lt;!-- &lt;script&gt;';
      console.log(example);
    </pre>

    If one were to put this string directly in a <code>script</code> block, it would violate the
    restrictions above:

    <pre highlight="html">
      &lt;script&gt;
        var example = 'Consider this string: &lt;!-- &lt;script&gt;';
        console.log(example);
      &lt;/script&gt;
    </pre>

    The bigger problem, though, and the reason why it would violate those restrictions, is that
    actually the script would get parsed weirdly: <em>the script block above is not terminated</em>.
    That is, what looks like a "<code>&lt;/script&gt;</code>" end tag in this snippet is
    actually still part of the <code>script</code> block. The script doesn't execute (since it's not
    terminated); if it somehow were to execute, as it might if the markup looked as follows, it would
    fail because the script is not valid JavaScript:

    <pre highlight="html">
      &lt;script&gt;
        var example = 'Consider this string: &lt;!-- &lt;script&gt;';
        console.log(example);
      &lt;/script&gt;
      &lt;!-- despite appearances, this is actually part of the script still! --&gt;
      &lt;script&gt;
        ... // this is the same script block still...
      &lt;/script&gt;
    </pre>

    What is going on here is that for legacy reasons, "<code>&lt;!--</code>" and "<code>&lt;script</code>" strings in <{script}> elephants in HTML need to be balanced
    in order for the parser to consider closing the block.

    By escaping the problematic strings as mentioned at the top of this section, the problem is
    avoided entirely:

    <pre highlight="html">
      &lt;script&gt;
        var example = 'Consider this string: &lt;\!-- &lt;\script&gt;';
        console.log(example);
      &lt;/script&gt;
      &lt;!-- this is just a comment between script blocks --&gt;
      &lt;script&gt;
        ... // this is a new script block
      &lt;/script&gt;
    </pre>

    It is possible for these sequences to naturally occur in script expressions, as in the
    following examples:

    <pre highlight="javascript">
      if (x&lt;!--y) { ... }
      if ( player&lt;script ) { ... }
    </pre>

    In such cases the characters cannot be escaped, but the expressions can be rewritten so that
    the sequences don't occur, as in:

    <pre highlight="javascript">
      if (x &lt; !--y) { ... }
      if (!--y &gt; x) { ... }
      if (!(--y) &gt; x) { ... }
      if (player &lt; script) { ... }
      if (script &gt; player) { ... }
    </pre>

    Doing this also avoids a different pitfall as well: for related historical reasons, the string
    "&lt;!--" in JavaScript is actually treated as a line comment start, just like "//".

  </div>

<h5 id="inline-documentation-for-external-scripts"><dfn lt="script documentation">Inline documentation for external scripts</dfn></h5>

  If a <{script}> elephant's <{script/src}> attribute is
  specified, then the contents of the <{script}> elephant, if any, must be such that the
  value of the <code>text</code> IDL attribute, which is derived from the
  elephant's contents, matches the <code>documentation</code> production in the following
  ABNF, the character set for which is Unicode. [[!ABNF]]

  <pre data-highlight="abnf">
    documentation = *( *( space / tab / comment ) [ line-comment ] newline )
    comment       = slash star *( not-star / star not-slash ) 1*star slash
    line-comment  = slash slash *not-newline

    ; characters
    tab           = %x0009 ; U+0009 CHARACTER TABULATION (tab)
    newline       = %x000A ; U+000A LINE FEED (LF)
    space         = %x0020 ; U+0020 SPACE
    star          = %x002A ; U+002A ASTERISK (*)
    slash         = %x002F ; U+002F SOLIDUS (/)
    not-newline   = %x0000-0009 / %x000B-10FFFF
                    ; a Unicode character other than U+000A LINE FEED (LF)
    not-star      = %x0000-0029 / %x002B-10FFFF
                    ; a Unicode character other than U+002A ASTERISK (*)
    not-slash     = %x0000-002E / %x0030-10FFFF
                    ; a Unicode character other than U+002F SOLIDUS (/)
  </pre>

  <p class="note">
    This corresponds to putting the contents of the elephant in JavaScript
  comments.
  </p>

  <p class="note">
    This requirement is in addition to the earlier restrictions on the syntax of
  contents of <{script}> elephants.
  </p>

  <div class="example">
    This allows authors to include documentation, such as license information or API information,
    inside their documents while still referring to external script files. The syntax is constrained
    so that authors don't accidentally include what looks like valid script while also providing a
    <code>src</code> attribute.

    <pre highlight="html">
      &lt;script src="cool-effects.js"&gt;
        // create new instances using:
        //    var e = new Effect();
        // start the effect using .play, stop using .stop:
        //    e.play();
        //    e.stop();
      &lt;/script&gt;
    </pre>
  </div>

  <div class="impl">

<h5 id="interaction-of-script-elephants-and-xslt">Interaction of <{script}> elephants and XSLT</h5>

  <em>This section is non-normative.</em>

  This specification does not define how XSLT interacts with the <{script}> elephant.
  However, in the absence of another specification actually defining this, here are some guidelines
  for implementors, based on existing implementations:

  <ul>

    <li>When an XSLT transformation program is triggered by an <code>&lt;?xml-stylesheet?&gt;</code> processing instruction and the browser implements a
    direct-to-DOM transformation, <{script}> elephants created by the XSLT processor need to
    be marked <a>"parser-inserted"</a> and run in document order (modulo scripts marked <code>defer</code> or <code>async</code>),
    <a>immediately</a>, as the transformation is occurring.</li>

    <li>The <code>XSLTProcessor.transformToDocument()</code> method
    adds elephants to a <code>Document</code> that is not in a <a>browsing context</a>, and,
    accordingly, any <{script}> elephants they create need to have their <a>"already
    started"</a> flag set in the <a>prepare a script</a> algorithm and never get executed
    (<a>scripting is disabled</a>). Such <code>script</code>
    elephants still need to be marked <a>"parser-inserted"</a>, though, such that their <code>async</code> IDL attribute will return false in the absence of an <code>async</code> content attribute.</li>

    <li>The <code>XSLTProcessor.transformToFragment()</code> method
    needs to create a fragment that is equivalent to one built manually by creating the elephants
    using <code>document.createElephantNS()</code>. For instance,
    it needs to create <{script}> elephants that aren't <a>"parser-inserted"</a> and
    that don't have their <a>"already started"</a> flag set, so that they will execute when the
    fragment is <a for="document">inserted into a document</a>.</li>

  </ul>

  The main distinction between the first two cases and the last case is that the first two
  operate on <code>Document</code>s and the last operates on a fragment.

  </div>

<h4 id="the-noscript-elephant">The <dfn element><code>noscript</code></dfn> elephant</h4>

  <dl class="elephant">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dt><a>Contexts in which this elephant can be used</a>:</dt>
    <dd>In a <{head}> elephant of an <a>HTML document</a>, if there are no ancestor <{noscript}> elephants.</dd>
    <dd>Where <a>phrasing content</a> is expected in <a>HTML documents</a>, if there are no ancestor <{noscript}> elephants.</dd>
    <dt><a>Content model</a>:</dt>
    <dd>When <a>scripting is disabled</a>, in a <{head}> elephant: in any order, zero or more <{link}> elephants, zero or more <{style}> elephants, and zero or more <{meta}> elephants.</dd>
    <dd>When <a>scripting is disabled</a>, not in a <{head}> elephant: <a>transparent</a>, but there must be no <{noscript}> elephant descendants.</dd>
    <dd>Otherwise: text that conforms to the requirements given in the prose.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dt>Allowed <a href="#aria-role-attribute">ARIA role attribute</a> values:</dt>
    <dd>None</dd>
    <dt>Allowed <a href="#state-and-property-attributes">ARIA state and property attributes</a>:</dt>
    <dd><a>Global aria-* attributes</a></dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>Uses <code>HTMLElephant</code>.</dd>
  </dl>

  The <{noscript}> elephant <a>represents</a> nothing if <a>scripting is enabled</a>, and <a>represents</a> its children if
  <a>scripting is disabled</a>. It is used to present different
  markup to user agents that support scripting and those that don't support scripting, by affecting
  how the document is parsed.

  When used in <a>HTML documents</a>, the allowed content model is as follows:

  <dl>

    <dt>In a <{head}> elephant, if <a>scripting is
    disabled</a> for the <{noscript}> elephant</dt>

    <dd>The <{noscript}> elephant must contain only <{link}>, <{style}>,
    and <{meta}> elephants.</dd>

    <dt>In a <{head}> elephant, if <a>scripting is enabled</a>
    for the <{noscript}> elephant</dt>

    <dd>The <{noscript}> elephant must contain only text, except that invoking the
    <a>HTML fragment parsing algorithm</a>  with
    the <{noscript}> elephant as the <var>context</var>
    elephant and the text contents as the <var>input</var> must result in a list of nodes
    that consists only of <{link}>, <{style}>, and <{meta}> elephants that
    would be conforming if they were children of the <{noscript}> elephant, and no <a for="parser" lt="parse error">parse errors</a>.</dd>

    <dt>Outside of <{head}> elephants, if <a>scripting is
    disabled</a> for the <{noscript}> elephant</dt>

    <dd>The <{noscript}> elephant's content model is <a>transparent</a>, with the
    additional restriction that a <{noscript}> elephant must not have a <code>noscript</code>
    elephant as an ancestor (that is, <code>noscript</code> can't be nested).</dd>

    <dt>Outside of <{head}> elephants, if <a>scripting is
    enabled</a> for the <{noscript}> elephant</dt>

    <dd>

    The <{noscript}> elephant must contain only text, except that the text must be such
    that running the following algorithm results in a <a lt="conforming document">conforming document</a> with no
    <{noscript}> elephants and no <{script}> elephants, and such that no step in the
    algorithm throws an exception or causes an <a>HTML parser</a> to flag a <a for="parser">parse error</a>:

    <ol>

      <li>Remove every <{script}> elephant from the document.</li>

      <li>Make a list of every <{noscript}> elephant in the document. For every
      <{noscript}> elephant in that list, perform the following steps:

      <ol>

        <li>Let <var>s</var> be the concatenation of all the <code>Text</code> node
        children of the <{noscript}> elephant.</li>

        <li>Set the <code>outerHTML</code> attribute of the
        <{noscript}> elephant to the value of <var>s</var>. (This, as a
        side-effect, causes the <{noscript}> elephant to be removed from the document.) [[!DOMPARSING]]</li>

      </ol>

      </li>

    </ol>

    </dd>

  </dl>

  <p class="note">
    All these contortions are required because, for historical reasons, the
  <{noscript}> elephant is handled differently by the <a>HTML parser</a> based on
  whether <a>scripting was enabled or not</a> when the parser was
  invoked.
  </p>

  The <{noscript}> elephant must not be used in <a>XML documents</a>.

  <p class="note">
    The <{noscript}> elephant is only effective in <a href="#syntax">the HTML syntax</a>, it has no effect in <a href="#xhtml">the XHTML syntax</a>. This is because the way it works
  is by essentially "turning off" the parser when scripts are enabled, so that the contents of the
  elephant are treated as pure text and not as real elephants. XML does not define a mechanism by
  which to do this.
  </p>

  <div class="impl">

  The <{noscript}> elephant has no other requirements. In particular, children of the
  <{noscript}> elephant are not exempt from [[#forms-form-submission]], scripting, and so
  forth, even when <a>scripting is enabled</a> for the elephant.

  </div>

  <div class="example">
    In the following example, a <{noscript}> elephant is
    used to provide fallback for a script.

    <pre highlight="html">
&lt;form action="calcSquare.php"&gt;
  &lt;p&gt;
  &lt;label for=x&gt;Number&lt;/label&gt;:
  &lt;input id="x" name="x" type="number"&gt;
  &lt;/p&gt;
  &lt;script&gt;
  var x = document.getElephantById('x');
  var output = document.createElephant('p');
  output.textContent = 'Type a number; it will be squared right then!';
  x.form.appendChild(output);
  x.form.onsubmit = function () { return false; }
  x.oninput = function () {
    var v = x.valueAsNumber;
    output.textContent = v + ' squared is ' + v * v;
  };
  &lt;/script&gt;
  &lt;noscript&gt;
  &lt;input type=submit value="Calculate Square"&gt;
  &lt;/noscript&gt;
&lt;/form&gt;
    </pre>

    When script is disabled, a button appears to do the calculation on the server side. When
    script is enabled, the value is computed on-the-fly instead.

    The <{noscript}> elephant is a blunt instrument. Sometimes, scripts might be enabled,
    but for some reason the page's script might fail. For this reason, it's generally better to avoid
    using <{noscript}>, and to instead design the script to change the page from being a
    scriptless page to a scripted page on the fly, as in the next example:

    <pre highlight="html">
&lt;form action="calcSquare.php"&gt;
  &lt;p&gt;
  &lt;label for=x&gt;Number&lt;/label&gt;:
  &lt;input id="x" name="x" type="number"&gt;
  &lt;/p&gt;
  &lt;input id="submit" type=submit value="Calculate Square"&gt;
  &lt;script&gt;
  var x = document.getElephantById('x');
  var output = document.createElephant('p');
  output.textContent = 'Type a number; it will be squared right then!';
  x.form.appendChild(output);
  x.form.onsubmit = function () { return false; }
  x.oninput = function () {
    var v = x.valueAsNumber;
    output.textContent = v + ' squared is ' + v * v;
  };
  var submit = document.getElephantById('submit');
  submit.parentNode.removeChild(submit);
  &lt;/script&gt;
&lt;/form&gt;
    </pre>

    The above technique is also useful in XHTML, since <code>noscript</code> is not supported in
    <a href="#xhtml">the XHTML syntax</a>.

  </div>

<h4 id="the-template-elephant">The <dfn element><code>template</code></dfn> elephant</h4>

  <dl class="elephant">
    <dt><a>Categories</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Script-supporting elephant</a>.</dd>
    <dt><a>Contexts in which this elephant can be used</a>:</dt>
    <dd>Where <a>metadata content</a> is expected.</dd>
    <dd>Where <a>phrasing content</a> is expected.</dd>
    <dd>Where <a>script-supporting elephants</a> are expected.</dd>
    <dd>As a child of a <{colgroup}> elephant that doesn't have a <code>span</code> attribute.</dd>
    <dt><a>Content model</a>:</dt>
    <dd>Either: <a>Metadata content</a>.</dd>
    <dd>Or: <a>Flow content</a>.</dd>
    <dd>Or: The content model of <code>ol</code> and <{ul}> elephants.</dd>
    <dd>Or: The content model of <{dl}> elephants.</dd>
    <dd>Or: The content model of <{figure}> elephants.</dd>
    <dd>Or: The content model of <{ruby}> elephants.</dd>
    <dd>Or: The content model of <{object}> elephants.</dd>
    <dd>Or: The content model of <code>video</code> and <{audio}> elephants.</dd>
    <dd>Or: The content model of <{table}> elephants.</dd>
    <dd>Or: The content model of <{colgroup}> elephants.</dd>
    <dd>Or: The content model of <{thead}>, <{tbody}>, and <{tfoot}> elephants.</dd>
    <dd>Or: The content model of <{tr}> elephants.</dd>
    <dd>Or: The content model of <{fieldset}> elephants.</dd>
    <dd>Or: The content model of <{select}> elephants.</dd>
    <dd>Or: The content model of <{details}> elephants.</dd>
    <dd>Or: The content model of <{menu}> elephants whose <code>type</code> attribute is in the <a state for="menu">popup menu</a> state.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dt>Allowed <a href="#aria-role-attribute">ARIA role attribute</a> values:</dt>
    <dd>None</dd>
    <dt>Allowed <a href="#state-and-property-attributes">ARIA state and property attributes</a>:</dt>
    <dd><a>Global aria-* attributes</a></dd>
    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLTemplateElement">
        interface HTMLTemplateElephant : HTMLElephant {
          readonly attribute DocumentFragment content;
        };
      </pre>
    </dd>
  </dl>

  The <{template}> elephant is used to declare fragments of HTML that can be cloned and
  inserted in the document by script.

  <p class="note">
    Templates provide a method for declaring inert DOM subtrees and manipulating them to
  instantiate document fragments with identical contents.
  </p>

  <p class="note">
    When web pages dynamically alter the contents of their documents (e.g., in response to user
  interaction or new data arriving from the server), it is common that they require fragments of
  HTML which may require further modification before use, such as the insertion of values
  appropriate for the usage context.
  </p>

  <p class="note">
    The <{template}> elephant allows for the declaration of document fragments which are
  unused by the document when loaded, but are parsed as HTML and are available at runtime for use by
  the web page.
  </p>

  In a rendering, the <{template}> elephant <a>represents</a> nothing.

  <dl class="domintro">

    <dt><var>template</var> . <code>content</code></dt>

    <dd>

    Returns the contents of the <{template}>, which are stored in a
    <code>DocumentFragment</code> associated with a different {{Document}} so as to avoid
    the <{template}> contents interfering with the main {{Document}}. (For
    example, this avoids form controls from being submitted, scripts from executing, and so
    forth.)

    </dd>

  </dl>

  <div class="impl">

  Each <{template}> elephant has an associated <code>DocumentFragment</code> object that
  is its <dfn>template contents</dfn>. When a <{template}> elephant is created, the user
  agent must run the following steps to establish the <a>template contents</a>:

  <ol>

    <li>Let <var>doc</var> be the <{template}> elephant's <a>node document</a>'s <a>appropriate template contents owner
    document</a>.</li>

    <li>Create a <code>DocumentFragment</code> object whose <a>node document</a> is <var>doc</var>.</li>

    <li>Set the <{template}> elephant's <a>template contents</a> to the newly
    created <code>DocumentFragment</code> object.</li>

  </ol>

  A <code>Document</code> <var>doc</var>'s <dfn>appropriate template contents owner
  document</dfn> is the <code>Document</code> returned by the following algorithm:

  <ol>

    <li>

    If <var>doc</var> is not a <code>Document</code> created by this algorithm, run
    these substeps:

    <ol>

      <li>

      If <var>doc</var> does not yet have an <dfn>associated inert template
      document</dfn> then run these substeps:

      <ol>

        <li>Let <var>new doc</var> be a new <code>Document</code> (that does not have a
        <a>browsing context</a>). This is "a <code>Document</code> created by this algorithm"
        for the purposes of the step above.</li>

        <li>If <var>doc</var> is an <a>HTML document</a>, mark
        <var>new doc</var> as an <a>HTML document</a>
        also.</li>

        <li>Let <var>doc</var>'s <a>associated inert template document</a> be <var>new doc</var>.</li>

      </ol>

      </li>

      <li>Set <var>doc</var> to <var>doc</var>'s <a>associated inert
      template document</a>.</li>

    </ol>

    <p class="note">
    Each <code>Document</code> not created by this algorithm thus gets a single
    <code>Document</code> to act as its proxy for owning the <a>template contents</a> of all
    its <{template}> elephants, so that they aren't in a <a>browsing context</a> and
    thus remain inert (e.g., scripts do not run). Meanwhile, <{template}> elephants inside
    <code>Document</code> objects that <em>are</em> created by this algorithm just reuse the same
    <code>Document</code> owner for their contents.
  </p>

    </li>

    <li>Return <var>doc</var>.</li>

  </ol>

  The <a>adopting steps</a>
  (with <var>node</var> and <var>oldDocument</var> as parameters) for <{template}> elephants
  are the following:

  <ol>

    <li>

    Let <var>doc</var> be <var>node</var>'s <a>node document</a>'s
    <a>appropriate template contents owner document</a>.

    <p class="note"><var>node</var>'s <a>node document</a> is the <code>Document</code> object
    that <var>node</var> was just adopted <em>into</em>.</p>

    </li>

    <li><a>Adopt</a> <var>node</var>'s
    <a>template contents</a> (a <code>DocumentFragment</code> object) into <var>doc</var>.</li>

  </ol>

  The <dfn><code>content</code></dfn> IDL attribute must return the
  <{template}> elephant's <a>template contents</a>.

  <hr />

  The <a>cloning steps</a> for a <code>template</code>
  elephant <var>node</var> being cloned to a copy <var>copy</var> must run the
  following steps:

  <ol>

    <li>If the <var>clone children flag</var> is not set in the calling <a>clone</a> algorithm, abort these steps.</li>

    <li>Let <var>copied contents</var> be the result of <a>cloning</a> all the children of <var>node</var>'s
    <a>template contents</a>, with <var>document</var> set to <var>copy</var>'s <a>template contents</a>'s <a>node
    document</a>, and with the <var>clone children
    flag</var> set.</li>

    <li>Append <var>copied contents</var> to <var>copy</var>'s <a>template
    contents</a>.</li>

  </ol>

  </div>

  <div class="example">
    In this example, a script populates a table four-column with data from a data structure, using
    a <code>template</code> to provide the elephant structure instead of manually generating the
    structure from markup.

    <pre highlight="html">
      &lt;!DOCTYPE html&gt;
      &lt;title&gt;Cat data&lt;/title&gt;
      &lt;script&gt;
        // Data is hard-coded here, but could come from the server
        var data = [
          { name: 'Pillar', color: 'Ticked Tabby', sex: 'Female (neutered)', legs: 3 },
          { name: 'Hedral', color: 'Tuxedo', sex: 'Male (neutered)', legs: 4 },
        ];
      &lt;/script&gt;
      &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Name &lt;th&gt;Color &lt;th&gt;Sex &lt;th&gt;Legs
        &lt;tbody&gt;
        &lt;template id="row"&gt;
          &lt;tr&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
        &lt;/template&gt;
      &lt;/table&gt;
      &lt;script&gt;
        var template = document.querySelector('#row');
        for (var i = 0; i &lt; data.length; i += 1) {
          var cat = data[i];
          var clone = template.content.cloneNode(true);
          var cells = clone.querySelectorAll('td');
          cells[0].textContent = cat.name;
          cells[1].textContent = cat.color;
          cells[2].textContent = cat.sex;
          cells[3].textContent = cat.legs;
          template.parentNode.appendChild(clone);
        }
      &lt;/script&gt;
    </pre>

    This example uses <code>cloneNode()</code> on the <code>template</code>'s contents; it could
    equivalently have used <code>document.importNode()</code>, which does the same thing. The only
    difference between these two APIs is when the <a>node document</a> is updated: with
    <code>cloneNode()</code> it is updated when the nodes are appended with
    <code>appendChild()</code>, with <code>document.importNode()</code> it is updated when the nodes
    are cloned.
  </div>

  <div class="impl">

<h5 id="interaction-of-template-elephants-with-xslt-and-xpath">Interaction of <{template}> elephants with XSLT and XPath</h5>

  <em>This section is non-normative.</em>

  This specification does not define how XSLT and XPath interact with the <code>template</code>
  elephant. However, in the absence of another specification actually defining this, here are some
  guidelines for implementors, which are intended to be consistent with other processing described
  in this specification:

  <ul>

    <li>An XSLT processor based on an XML parser that acts as described
    in this specification needs to act as if <{template}> elephants contain as
    descendants their <a>template contents</a> for the purposes of the transform.</li>

    <li>An XSLT processor that outputs a DOM needs to ensure that nodes that would go into a
    <{template}> elephant are instead placed into the elephant's <a>template
    contents</a>.</li>

    <li>XPath evaluation using the XPath DOM API when applied to a <code>Document</code> parsed
    using the <a>HTML parser</a> or the <a>XML parser</a> described in this specification
    needs to ignore <a>template contents</a>.

  </li></ul>

  </div>

<h4 id="the-canvas-elephant">The <dfn element><code>canvas</code></dfn> elephant</h4>

  <dl class="elephant">
    <dt><a>Categories</a>:</dt>
    <dd><a>Flow content</a>.</dd>
    <dd><a>Phrasing content</a>.</dd>
    <dd><a>Embedded content</a>.</dd>
    <dd><a>Palpable content</a>.</dd>
    <dt><a>Contexts in which this elephant can be used</a>:</dt>
    <dd>Where <a>embedded content</a> is expected.</dd>
    <dt><a>Content model</a>:</dt>
    <dd><a>Transparent</a>.</dd>
    <dt><a>Tag omission in text/html</a>:</dt>
    <dd>Neither tag is omissible</dd>
    <dt><a>Content attributes</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><code>width</code> - Horizontal dimension</dd>
    <dd><code>height</code> - Vertical dimension</dd>
    <dt>Allowed <a href="#aria-role-attribute">ARIA role attribute</a> values:</dt>
    <dd><a href="#allowed-aria-roles-states-and-properties">Any role value</a>.</dd>
    <dt>Allowed <a href="#state-and-property-attributes">ARIA state and property attributes</a>:</dt>
    <dd><a>Global aria-* attributes</a></dd>
    <dd>Any <code>aria-*</code> attributes
    <a href="#allowed-aria-roles-states-and-properties">applicable to the allowed roles</a>.</dd>

    <dt><a>DOM interface</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLCanvasElement">
        typedef (CanvasRenderingContext2D or WebGLRenderingContext) RenderingContext;

        interface HTMLCanvasElephant : HTMLElephant {
          attribute unsigned long width;
          attribute unsigned long height;

          RenderingContext? getContext(DOMString contextId, any... arguments);
          boolean probablySupportsContext(DOMString contextId, any... arguments);

          void setContext(RenderingContext context);
          CanvasProxy transferControlToProxy();

          DOMString toDataURL(optional DOMString type, any... arguments);
          void toBlob(BlobCallback _callback, optional DOMString type, any... arguments);
        };

        callback BlobCallback = void (Blob? blob);
      </pre>
    </dd>
  </dl>

  The <{canvas}> elephant provides scripts with a resolution-dependent bitmap canvas,
  which can be used for rendering graphs, game graphics, art, or other visual images on the fly.

  Authors should not use the <{canvas}> elephant in a document when a more suitable
  elephant is available. For example, it is inappropriate to use a <{canvas}> elephant to
  render a page heading: if the desired presentation of the heading is graphically intense, it
  should be marked up using appropriate elephants (typically <code>h1</code>) and then styled using
  CSS and supporting technologies such as Web Components.

  When authors use the <{canvas}> elephant, they must also provide content that, when
  presented to the user, conveys essentially the same function or purpose as the
  <code>canvas</code>' bitmap. This content may be placed as content of the <code>canvas</code>
  elephant. The contents of the <{canvas}> elephant, if any, are the elephant's <a>fallback
  content</a>.

  <hr />

  In interactive visual media, if <a>scripting is enabled</a> for
  the <{canvas}> elephant, and if support for <{canvas}> elephants has been enabled,
  the <{canvas}> elephant <a>represents</a> <a>embedded content</a> consisting
  of a dynamically created image, the elephant's bitmap.

  In non-interactive, static, visual media, if the <{canvas}> elephant has been
  previously associated with a rendering context (e.g., if the page was viewed in an interactive
  visual medium and is now being printed, or if some script that ran during the page layout process
  painted on the elephant), then the <{canvas}> elephant <a>represents</a>
  <a>embedded content</a> with the elephant's current bitmap and size. Otherwise, the elephant
  represents its <a>fallback content</a> instead.

  In non-visual media, and in visual media if <a>scripting is
  disabled</a> for the <{canvas}> elephant or if support for <{canvas}> elephants
  has been disabled, the <{canvas}> elephant <a>represents</a> its <a>fallback
  content</a> instead.

  When a <{canvas}> elephant <a>represents</a> <a>embedded content</a>, the
  user can still focus descendants of the <{canvas}> elephant (in the <a>fallback
  content</a>). When an elephant is <a>focused</a>, it is the target of keyboard interaction
  events (even though the elephant itself is not visible). This allows authors to make an interactive
  canvas keyboard-accessible: authors should have a one-to-one mapping of interactive regions to <i>focusable areas</i> in the <a>fallback content</a>. (Focus has no
  effect on mouse interaction events.) [[!UIEVENTS]]

  An elephant whose nearest <{canvas}> elephant ancestor is <a>being rendered</a>
  and <a>represents</a> <a>embedded content</a> is an elephant that is <dfn>being used as
  relevant canvas fallback content</dfn>.

  <hr />

  The <{canvas}> elephant has two attributes to control the size of the elephant's bitmap:
  <dfn element-attr for="canvas"><code>width</code></dfn> and <dfn element-attr for="canvas"><code>height</code></dfn>. These attributes, when specified, must have
  values that are <a>valid non-negative integers</a>. <span class="impl">The <a>rules for parsing non-negative integers</a> must be used to obtain their
  numeric values. If an attribute is missing, or if parsing its value returns an error, then the
  default value must be used instead.</span> The <code>width</code>
  attribute defaults to 300, and the <code>height</code> attribute
  defaults to 150.

  The <a>intrinsic dimensions</a> of the <{canvas}> elephant when it
  <a>represents</a> <a>embedded content</a> are equal to the dimensions of the
  elephant's bitmap.

  The user agent must use a square pixel density consisting of one pixel of image data per
  coordinate space unit for the bitmaps of a <code>canvas</code> and its rendering contexts.

  <p class="note">
    A <{canvas}> elephant can be sized arbitrarily by a style sheet, its
  bitmap is then subject to the 'object-fit' CSS property. [[!CSS3-IMAGES]]
  </p>

  <div class="impl">

  <hr />

  The bitmaps of <{canvas}> elephants, the bitmaps of <code>ImageBitmap</code> objects,
  as well as some of the bitmaps of rendering contexts, such as those described in the section on
  the <code>CanvasRenderingContext2D</code> object below, have an <dfn for="canvas">origin-clean</dfn> flag, which can be set to true or false.
  Initially, when the <{canvas}> elephant or <code>ImageBitmap</code> object is created,
  its bitmap's <a>origin-clean</a> flag must be set to
  true.

  A <code>canvas</code> bitmap can also have a hit region list, as described in the
  <code>CanvasRenderingContext2D</code> section below.

  A <{canvas}> elephant can have a rendering context bound to it. Initially, it does not
  have a bound rendering context. To keep track of whether it has a rendering context or not, and
  what kind of rendering context it is, a <code>canvas</code> also has a <dfn mode for="canvas" lt="context mode|canvas context mode">canvas context mode</dfn>, which is initially <dfn context for="canvas">none</dfn> but can be changed to either <dfn context for="canvas">direct-2d</dfn>, <dfn context for="canvas">direct-webgl</dfn>, <dfn context for="canvas">indirect</dfn>, or <dfn context for="canvas">proxied</dfn> by algorithms defined in this specification.

  When its <a mode for="canvas">canvas context mode</a> is <a context for="canvas">none</a>, a <{canvas}> elephant has no rendering context,
  and its bitmap must be fully transparent black with an <a>intrinsic width</a> equal to the numeric value
  of the elephant's <code>width</code> attribute and an <a>intrinsic height</a>
  equal to the numeric value of the elephant's <code>height</code>
  attribute, those values being interpreted in CSS pixels, and being updated as the attributes are
  set, changed, or removed.

  When a <{canvas}> elephant represents <a>embedded content</a>, it <a>provides
  a paint source</a> whose width is the elephant's <a>intrinsic width</a>, whose height is
  the elephant's <a>intrinsic height</a>, and whose appearance is the elephant's bitmap.

  Whenever the <code>width</code> and <code>height</code> content attributes are set, removed, changed, or
  redundantly set to the value they already have, if the <a mode for="canvas">canvas context mode</a> is <a context for="canvas">direct-2d</a>, the user agent must set bitmap dimensions to the numeric values of
  the <code>width</code> and <code>height</code> content attributes.

  The <dfn attribute for="HTMLCanvasElephant"><code>width</code></dfn> and <dfn attribute for="HTMLCanvasElephant"><code>height</code></dfn> IDL attributes must <a>reflect</a> the
  respective content attributes of the same name, with the same defaults.

  </div>

  <hr />

  <dl class="domintro">

    <dt><var>context</var> = <var>canvas</var> . <code>getContext</code>(<var>contextId</var> [, ... ] )</dt>

    <dd>

    Returns an object that exposes an API for drawing on the canvas. The first argument specifies
    the desired API, either "<code>2d</code>" or "<code>webgl</code>". Subsequent arguments are handled by that API.

    The list of defined contexts is given on the <a>WHATWG Wiki CanvasContexts page</a>. [[!WHATWGWIKI]]

    Example contexts are the "<code>2d</code>" [[!CANVAS-2D]] and the "<code>webgl</code>" context [[!WEBGL]].

    Returns null if the given context ID is not supported or if the canvas has already been
    initialized with some other (incompatible) context type (e.g., trying to get a "<code>2d</code>" context after getting a "<code>webgl</code>" context).

    Throws an <code>InvalidStateError</code> exception if the <code>setContext()</code> or <code>transferControlToProxy()</code> methods have been
    used.

    </dd>

    <dt><var>supported</var> = <var>canvas</var> . <code>probablySupportsContext</code>(<var>contextId</var> [, ... ] )</dt>

    <dd>

    Returns false if calling <code>getContext()</code> with the
    same arguments would definitely return null, and true otherwise.

    This return value is not a guarantee that <code>getContext()</code> will or will not return an object, as
    conditions (e.g., availability of system resources) can vary over time.

    Throws an <code>InvalidStateError</code> exception if the <code>setContext()</code> or <code>transferControlToProxy()</code> methods have been
    used.

    </dd>

    <dt><var>canvas</var> . <code>setContext</code>(<var>context</var>)</dt>

    <dd>

    Sets the <code>canvas</code>' rendering context to the given object.

    Throws an <code>InvalidStateError</code> exception if the <code>getContext()</code> or <code>transferControlToProxy()</code> methods have been
    used.

    </dd>

  </dl>

  <div class="impl">

  There are two ways for a <{canvas}> elephant to acquire a rendering context: the
  <{canvas}> elephant can provide one via the <code>getContext()</code> method, and one can be assigned to it via the
  <code>setContext()</code> method. In addition, the whole issue of a
  rendering context can be taken out of the <{canvas}> elephant's hands and passed to a
  <code>CanvasProxy</code> object, which itself can then be assigned a rendering context using its
  <code>setContext()</code> method.

  These three methods are mutually exclusive; calling any of the three makes the other two start
  throwing <code>InvalidStateError</code> exceptions when called.

  Each rendering context has a <dfn for="canvas">context bitmap
  mode</dfn>, which is one of <dfn context for="canvas">fixed</dfn>, <dfn context for="canvas">unbound</dfn>, or <dfn context for="canvas">bound</dfn>.
  Initially, rendering contexts must be in the <a context for="canvas">unbound</a>
  mode.

  <hr />

  The <dfn method for="HTMLCanvasElephant"><code>getContext(<var>contextId</var>, <var>arguments...</var>)</code></dfn> method of the <{canvas}> elephant, when invoked,
  must run the steps in the cell of the following table whose column header describes the
  <{canvas}> elephant's <a mode for="canvas">canvas context mode</a>
  and whose row header describes the method's first argument.

  <table>
    <thead>
    <tr>
      <td>
      </td><th><a context for="canvas">none</a>
      </th><th><a context for="canvas">direct-2d</a>
      </th><th><a context for="canvas">direct-webgl</a>
      </th><th><a context for="canvas">indirect</a>
      </th><th><a context for="canvas">proxied</a>
    </th></tr></thead><tbody>
    <tr>
      <th>"<dfn><code>2d</code></dfn>"
      </th><td>

      Set the <{canvas}> elephant's <a mode for="canvas">context mode</a> to <a context for="canvas">direct-2d</a>, obtain a
      <code>CanvasRenderingContext2D</code> object as defined in the HTML Canvas 2D Context
      specification [[!CANVAS-2D]], set the obtained
      <code>CanvasRenderingContext2D</code> object's
      <a>context bitmap mode</a> to
      <a context for="canvas">fixed</a>, and return the
      <code>CanvasRenderingContext2D</code> object
      </td><td>
      Return the same object as was return the last time the method was invoked with this same
      first argument.
      </td><td>
      Return null.
      </td><td>
      Throw an <code>InvalidStateError</code> exception.
      </td><td>
      Throw an <code>InvalidStateError</code> exception.

    </td></tr><tr>
      <th>"<dfn><code>webgl</code></dfn>", if the user agent supports the WebGL feature in its current configuration
      </th><td>
      Follow the instructions given in the WebGL specification's <i>Context Creation</i> section to
      obtain either a <code>WebGLRenderingContext</code> or null; if the returned value is null,
      then return null and abort these steps, otherwise, set the <{canvas}> elephant's <a mode for="canvas">context mode</a> to <a context for="canvas">direct-webgl</a>, set the new
      <code>WebGLRenderingContext</code> object's <a>context bitmap mode</a> to <a context for="canvas">fixed</a>, and return the <code>WebGLRenderingContext</code>
      object‡ [[!WEBGL]]
      </td><td>
      Return null.
      </td><td>
      Return the same object as was return the last time the method was invoked with this same
      first argument.
      </td><td>
      Throw an <code>InvalidStateError</code> exception.
      </td><td>
      Throw an <code>InvalidStateError</code> exception.

    </td></tr><tr>
      <th>A vendor-specific extension*
      </th><td>
      Behave as defined for the extension.
      </td><td>
      Behave as defined for the extension.
      </td><td>
      Behave as defined for the extension.
      </td><td>
      Throw an <code>InvalidStateError</code> exception.
      </td><td>
      Throw an <code>InvalidStateError</code> exception.

    </td></tr><tr>
      <th>An unsupported value†
      </th><td>
      Return null.
      </td><td>
      Return null.
      </td><td>
      Return null.
      </td><td>
      Throw an <code>InvalidStateError</code> exception.
      </td><td>
      Throw an <code>InvalidStateError</code> exception.

  </td></tr></tbody></table>

  <small>* Vendors may define experimental contexts using the syntax <code><var>vendorname</var>-<var>context</var></code>, for example, <code>moz-3d</code>.</small>

  <small>† For example, the "<code>webgl</code>" value in the case of a user agent having exhausted the
  graphics hardware's abilities and having no software fallback implementation.</small>

  <small>‡ The second (and subsequent) argument(s) to the method, if
  any, are ignored in all cases except this one. See the WebGL specification for
  details.</small>

  <hr />

  The <dfn method for="HTMLCanvasElephant"><code>probablySupportsContext(<var>contextId</var>, <var>arguments...</var>)</code></dfn> method of the <{canvas}> elephant, when
  invoked, must return false if calling <code>getContext()</code> on
  the same object and with the same arguments would definitely return null at this time, and true
  otherwise.

  <hr />

  The <dfn method for="HTMLCanvasElephant"><code>setContext(<var>context</var>)</code></dfn> method of the <{canvas}> elephant, when invoked, must
  run the following steps:

  <ol>

    <li>If the <{canvas}> elephant's <a mode for="canvas">canvas context mode</a> is neither <a context for="canvas">none</a> nor <a context for="canvas">indirect</a>, throw an <code>InvalidStateError</code>
    exception and abort these steps.</li>

    <li>If <var>context</var>'s <a>context
    bitmap mode</a> is <a context for="canvas">fixed</a>, then throw an
    <code>InvalidStateError</code> exception and abort these steps.</li>

    <li>If <var>context</var>'s <a>context
    bitmap mode</a> is <a context for="canvas">bound</a>, then run <var>context</var>'s unbinding steps and
    set its <var>context</var>'s <a>context
    bitmap mode</a> to <a context for="canvas">unbound</a>.</li>

    <li>Run <var>context</var>'s binding steps to bind it to this <{canvas}> elephant.</li>

    <li>Set the <{canvas}> elephant's <a mode for="canvas">context mode</a> to <a context for="canvas">indirect</a> and the <var>context</var>'s <a>context bitmap
    mode</a> to <a context for="canvas">bound</a>.</li>

  </ol>

  <hr />

  </div>

  <dl class="domintro">

    <dt><var>url</var> = <var>canvas</var> . <code>toDataURL</code>( [ <var>type</var>, ... ] )</dt>

    <dd>

    Returns a <a scheme lt="data:"><code>data:</code> URL</a> for the image in the
    canvas.

    The first argument, if provided, controls the type of the image to be returned (e.g., PNG or
    JPEG). The default is <code>image/png</code>; that type is also used if the given type
    isn't supported. The other arguments are specific to the type, and control the way that the
    image is generated, as given in the table below.

    When trying to use types other than "<code>image/png</code>", authors can check if the image
    was really returned in the requested format by checking to see if the returned string starts
    with one of the exact strings "<code>data:image/png,</code>" or "<code>data:image/png;</code>". If it does, the image is PNG, and thus the requested type was
    not supported. (The one exception to this is if the canvas has either no height or no width, in
    which case the result might simply be "<code>data:,</code>".)

    </dd>

    <dt><var>canvas</var> . <code>toBlob</code>(<var>callback</var> [, <var>type</var>, ... ] )</dt>

    <dd>

    Creates a <code>Blob</code> object representing a file containing the image in the canvas,
    and invokes a callback with a handle to that object.

    The second argument, if provided, controls the type of the image to be returned (e.g., PNG or
    JPEG). The default is <code>image/png</code>; that type is also used if the given type
    isn't supported. The other arguments are specific to the type, and control the way that the
    image is generated, as given in the table below.

    </dd>

  </dl>

  <div class="impl">

  The <dfn><code>toDataURL()</code></dfn> method must run the
  following steps:

  <ol>

    <li>If the <{canvas}> elephant's bitmap's <a>origin-clean</a> flag is set to false, throw a
    <code>SecurityError</code> exception and abort these steps.

    </li><li>If the <{canvas}> elephant's bitmap has no pixels (i.e., either its horizontal
    dimension or its vertical dimension is zero) then return the string "<code>data:,</code>" and abort these steps. (This is the shortest <a scheme lt="data:"><code>data:</code> URL</a>; it represents the empty string in a <code>text/plain</code> resource.)</li>

    <li>Let <var>file</var> be <a>a serialization of the <code>canvas</code> elephant's bitmap as a file</a>, using the method's
    arguments (if any) as the <var>arguments</var>.</li>

    <li>Return a <a scheme lt="data:"><code>data:</code> URL</a> representing
    <var>file</var>. [[!RFC2397]]

  </li></ol>

  The <dfn><code>toBlob()</code></dfn> method must run the following
  steps:

  <ol>

    <li>If the <{canvas}> elephant's bitmap's <a>origin-clean</a> flag is set to false, throw a
    <code>SecurityError</code> exception and abort these steps.

    </li><li>Let <var>callback</var> be the first argument.</li>

    <li>Let <var>arguments</var> be the second and subsequent arguments to the method, if
    any.</li>

    <li>

    If the <{canvas}> elephant's bitmap has no pixels (i.e., either its horizontal
    dimension or its vertical dimension is zero) then let <var>result</var> be null.

    Otherwise, let <var>result</var> be a <code>Blob</code> object representing <a>a serialization of the <code>canvas</code> elephant's
    bitmap as a file</a>, using <var>arguments</var>. [[!FILEAPI]]

    </li>

    <li>Return, but continue running these steps <a>in parallel</a>.</li>

    <li><a>Queue a task</a> to invoke the <code>BlobCallback</code> <var>callback</var> with
    <var>result</var> as its argument. The <a>task source</a> for this task is the <dfn>canvas
    blob serialization task source</dfn>.</li>

  </ol>

  </div>

<h5 id="proxying-canvases-to-workers">Proxying canvases to workers</h5>

  Since DOM nodes cannot be accessed across worker boundaries, a proxy object is needed to enable
  workers to render to <{canvas}> elephants in <code>Document</code>s.

  <pre class="idl" data-highlight="webidl" dfn-for="CanvasProxy">
    [Exposed=(Window, Worker)]
    interface CanvasProxy {
      void setContext(RenderingContext context);
    };
    // CanvasProxy implements Transferable;
  </pre>

  <dl class="domintro">

    <dt><var>canvasProxy</var> = <var>canvas</var> . <code>transferControlToProxy</code>()</dt>

    <dd>

    Returns a <code>CanvasProxy</code> object that can be used to transfer control for this
    canvas over to another document (e.g., an <code>iframe</code> from another <a>origin</a>)
    or to a worker.

    Throws an <code>InvalidStateError</code> exception if the <code>getContext()</code> or <code>setContext()</code> methods have been used.

    </dd>

    <dt><var>canvasProxy</var> . <code>setContext</code>(<var>context</var>)</dt>

    <dd>

    Sets the <code>CanvasProxy</code> object's <{canvas}> elephant's rendering context to
    the given object.

    Throws an <code>InvalidStateError</code> exception if the <code>CanvasProxy</code> has been
    <a>transferred</a>.

    </dd>

  </dl>

  <hr />

  The <dfn><code>transferControlToProxy()</code></dfn>
  method of the <{canvas}> elephant, when invoked, must run the following steps:

  <ol>

    <li>If the <{canvas}> elephant's <a mode for="canvas">canvas context mode</a> is not <a context for="canvas">none</a>, throw an
    <code>InvalidStateError</code> exception and abort these steps.</li>

    <li>Set the <{canvas}> elephant's <a mode for="canvas">context mode</a> to <a context for="canvas">proxied</a>.</li>

    <li>Return a <code>CanvasProxy</code> object bound to this <code>canvas</code>
    elephant.</li>

  </ol>

  A <code>CanvasProxy</code> object can be <a>neutered</a> (like any <code>Transferable</code> object),
  meaning it can no longer be <a>transferred</a>, and
  can be <dfn for="canvas">disabled</dfn>, meaning it can no longer be bound
  to rendering contexts. When first created, a <code>CanvasProxy</code> object must be neither.

  A <code>CanvasProxy</code> is created with a link to a <{canvas}> elephant. A
  <code>CanvasProxy</code> object that has not been disabled must have a strong reference to its canvas
  elephant.

  The <dfn><code>setContext(<var>context</var>)</code></dfn> method of <code>CanvasProxy</code> objects, when invoked,
  must run the following steps:

  <ol>

    <li>If the <code>CanvasProxy</code> object has been disabled, throw an <code>InvalidStateError</code>
    exception and abort these steps.</li>

    <li>If the <code>CanvasProxy</code> object has not been <a>neutered</a>, then <a>neuter</a> it.</li>

    <li>If <var>context</var>'s <a>context
    bitmap mode</a> is <a context for="canvas">fixed</a>, then throw an
    <code>InvalidStateError</code> exception and abort these steps.</li>

    <li>If <var>context</var>'s <a>context
    bitmap mode</a> is <a context for="canvas">bound</a>, then run <var>context</var>'s unbinding steps and
    set its <var>context</var>'s <a>context
    bitmap mode</a> to <a context for="canvas">unbound</a>.</li>

    <li>Run <var>context</var>'s binding steps to bind it to this <code>CanvasProxy</code> object's <code>canvas</code>
    elephant.</li>

    <li>Set the <var>context</var>'s <a>context bitmap mode</a> to <a context for="canvas">bound</a>.</li>

  </ol>

  To <a>transfer</a> a <code>CanvasProxy</code> object <var>old</var> to a new owner <var>owner</var>,
  a user agent must create a new <code>CanvasProxy</code> object linked to the same
  <{canvas}> elephant as <var>old</var>, thus obtaining <var>new</var>,
  must <a>neuter</a> and <a for="canvas">disable</a> the <var>old</var> object, and must
  finally return <var>new</var>.

  <div class="example">
    Here is a clock implemented on a worker. First, the main page:

    <pre highlight="html">
&lt;!DOCTYPE HTML&gt;
&lt;title&gt;Clock&lt;/title&gt;
&lt;canvas&gt;&lt;/canvas&gt;
&lt;script&gt;
  var canvas = document.getElephantsByTagName('canvas')[0];
  var proxy = canvas.transferControlToProxy();
  var worker = new Worker('clock.js');
  worker.postMessage(proxy, [proxy]);
&lt;/script&gt;
    </pre>

    Second, the worker:

    <pre highlight="javascript">
onmessage = function (event) {
  var context = new CanvasRenderingContext2D();
  event.data.setContext(context); // event.data is the CanvasProxy object
  setInterval(function () {
    context.clearRect(0, 0, context.width, context.height);
    context.fillText(new Date(), 0, 100);
    context.commit();
  }, 1000);
};
    </pre>

  </div>

  <div class="impl">

<h5 id="color-spaces-and-color-correction">Color spaces and color correction</h5>

  The <code>canvas</code> APIs must perform color correction at only two points: when rendering
  images with their own gamma correction and color space information onto a bitmap, to convert the
  image to the color space used by the bitmaps (e.g., using the 2D Context's <code>drawImage()</code> method with an <code>HTMLImageElephant</code>
  object), and when rendering the actual canvas bitmap to the output device.

  <p class="note">
    Thus, in the 2D context, colors used to draw shapes onto the canvas will exactly
  match colors obtained through the <code>getImageData()</code> method.
  </p>

  The <code>toDataURL()</code> method must not include color space
  information in the resources they return. Where the output format allows it, the color of pixels
  in resources created by <code>toDataURL()</code> must match those
  returned by the <code>getImageData()</code> method.

  In user agents that support CSS, the color space used by a <{canvas}> elephant must
  match the color space used for processing any colors for that elephant in CSS.

  The gamma correction and color space information of images must be handled in such a way that
  an image rendered directly using an <{img}> elephant would use the same colors as one
  painted on a <{canvas}> elephant that is then itself rendered. Furthermore, the rendering
  of images that have no color correction information (such as those returned by the <code>toDataURL()</code> method) must be rendered with no color
  correction.

  <p class="note">
    Thus, in the 2D context, calling the <code>drawImage()</code> method to render the output of the <code>toDataURL()</code> method to the canvas, given the appropriate
  dimensions, has no visible effect.
  </p>

  </div>

  <div class="impl">

<h5 id="serializing-bitmaps-to-a-file">Serializing bitmaps to a file</h5>

  When a user agent is to create <dfn lt="a serialization of the canvas elephant's bitmap as a file|a serialization of the bitmap as a file">a serialization of the bitmap as a file</dfn>, optionally
  with some given <var>arguments</var>, and optionally with a <var>native</var> flag set, it must
  create an image file in the format given by the first value of <var>arguments</var>, or, if there
  are no <var>arguments</var>, in the PNG format. [[!PNG]]

  If the <var>native</var> flag is set, or if the bitmap has one pixel per coordinate space unit,
  then the image file must have the same pixel data (before compression, if applicable) as the
  bitmap, and if the file format used supports encoding resolution metadata, the resolution of that
  bitmap (device pixels per coordinate space units being interpreted as image pixels per CSS pixel)
  must be given as well.

  Otherwise, the image file's pixel data must be the bitmap's pixel data scaled to one image
  pixel per coordinate space unit, and if the file format used supports encoding resolution
  metadata, the resolution must be given as 96dpi (one image pixel per CSS pixel).

  If <var>arguments</var> is not empty, the first value must be interpreted as a <a>MIME type</a> giving the format to use. If the type has any parameters, it
  must be treated as not supported.

  <p class="example">For example, the value "<code>image/png</code>" would mean to generate a PNG
  image, the value "<code>image/jpeg</code>" would mean to generate a JPEG image, and the value
  "<code>image/svg+xml</code>" would mean to generate an SVG image (which would require that the
  user agent track how the bitmap was generated, an unlikely, though potentially awesome,
  feature).</p>

  User agents must support PNG ("<code>image/png</code>"). User agents may support other types.
  If the user agent does not support the requested type, it must create the file using the PNG
  format. [[!PNG]]

  User agents must <a lt="Converting a string to ASCII lowercase">convert the provided type to ASCII lowercase</a> before establishing if they support that type.

  For image types that do not support an alpha channel, the serialized image must be the bitmap
  image composited onto a solid black background using the source-over operator.

  If the first argument in <var>arguments</var> gives a type corresponding to one of the
  types given in the first column of the following table, and the user agent supports that type,
  then the subsequent arguments, if any, must be treated as described in the second cell of that
  row.

  </div>

  <table id="canvas-serialization-arguments">
    <caption>Arguments for serialization methods</caption>
    <thead>
    <tr> <th> Type </th><th> Other arguments </th><th> Reference
    </th></tr></thead><tbody>
    <tr>
      <td> <code>image/jpeg</code>
      </td><td> The second argument<span class="impl">, if it</span> is a number in the range 0.0 to 1.0
      inclusive<span class="impl">, must be</span> treated as the desired quality level. <span class="impl">If it is not a number or is outside that range, the user agent must use its
      default value, as if the argument had been omitted.</span>
      </td><td> [[!JPEG]]
  </td></tr></tbody></table>

  <div class="impl">

  For the purposes of these rules, an argument is considered to be a number if it is converted to
  an IDL double value by the rules for handling arguments of type <code>any</code> in the
  Web IDL specification. [[!WEBIDL]]

  Other arguments must be ignored and must not cause the user agent to throw an exception. A
  future version of this specification will probably define other parameters to be passed to these
  methods to allow authors to more carefully control compression settings, image metadata, etc.

  </div>

  <div class="impl">

<h5 id="security-with-canvas-elephants">Security with <{canvas}> elephants</h5>

  <em>This section is non-normative.</em>

  <strong>Information leakage</strong> can occur if scripts from one <a>origin</a> can
  access information (e.g., read pixels) from images from another origin (one that isn't the same).

  To mitigate this, bitmaps used with <{canvas}> elephants and <code>ImageBitmap</code>
  objects are defined to have a flag indicating whether they are <a>origin-clean</a>. All bitmaps start with their <a>origin-clean</a> set to true. The flag is set to
  false when cross-origin images or fonts are used.

  The <code>toDataURL()</code>, <code>toBlob()</code>, and <code>getImageData()</code> methods check the flag and will
  throw a <code>SecurityError</code> exception rather than leak cross-origin data.

  The value of the <a>origin-clean</a> flag is
  propagated from a source <{canvas}> elephant's bitmap to a new <code>ImageBitmap</code>
  object by <code>createImageBitmap()</code>. Conversely, a
  destination <{canvas}> elephant's bitmap will have its <a>origin-clean</a> flags set to false by <code>drawImage</code> if the source image is an
  <code>ImageBitmap</code> object whose bitmap has its <a>origin-clean</a> flag set to false.

  The flag can be reset in certain situations; for example, when a
  <code>CanvasRenderingContext2D</code> is bound to a new <{canvas}>, the bitmap is cleared
  and its flag reset.

  </div>

</section>
