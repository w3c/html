<section>
<!--
████████  ████████   ███████  ██      ██  ██████  ████████ ████████   ██████
██     ██ ██     ██ ██     ██ ██  ██  ██ ██    ██ ██       ██     ██ ██    ██
██     ██ ██     ██ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██
████████  ████████  ██     ██ ██  ██  ██  ██████  ██████   ████████   ██████
██     ██ ██   ██   ██     ██ ██  ██  ██       ██ ██       ██   ██         ██
██     ██ ██    ██  ██     ██ ██  ██  ██ ██    ██ ██       ██    ██  ██    ██
████████  ██     ██  ███████   ███  ███   ██████  ████████ ██     ██  ██████
-->

<h2 id="browsers">Loading Web pages</h2>

  This section describes features that apply most directly to Web browsers. Having said that,
  except where specified otherwise, the requirements defined in this section <em>do</em> apply to
  all user agents, whether they are Web browsers or not.

<h3 id="sec-browsing-contexts">Browsing contexts</h3>

  A <dfn lt="browsing context|browsing contexts">browsing context</dfn> is an environment in which
  {{Document}} objects are presented to the user.

  <p class="note">A tab or window in a Web browser typically contains a <a>browsing context</a>, as
  does an <{iframe}> or <{frame}>s in a <{frameset}>.</p>

  A <a>browsing context</a> has a corresponding {{WindowProxy}} object.

  A <a>browsing context</a> has a <a>session history</a>, which lists the
  {{Document}} objects that the <a>browsing context</a> has presented, is
  presenting, or will present. At any time, one {{Document}} in each <a>browsing context</a>
  is designated the <dfn>active document</dfn>. A {{Document}}'s
  <a>browsing context</a> is that <a>browsing context</a> whose <a>session
  history</a> contains the {{Document}}, if any. (A {{Document}} created using
  an API such as {{DOMImplementation/createDocument()}} has no
  <a>browsing context</a>.) Each {{Document}} in a <a>browsing context</a> is
  <dfn lt="document associated with a window">associated</dfn> with
  a {{Window}} object.

  <p class="note">
  In general, there is a 1-to-1 mapping from the {{Window}} object to the
  {{Document}} object. There are two exceptions. First, a {{Window}} can be reused
  for the presentation of a second {{Document}} in the same <a>browsing context</a>,
  such that the mapping is then 1-to-2. This occurs when a <a>browsing context</a> is
  <a>navigated</a> from the initial <code>about:blank</code> {{Document}}
  to another, with <a>replacement enabled</a>. Second, a {{Document}} can end up
  being reused for several {{Window}} objects when the {{Document/open()|document.open()}} method is
  used, such that the mapping is then many-to-1.</p>

  <p class="note">A {{Document}} does not necessarily have a <a>browsing context</a>
  associated with it. In particular, data mining tools are likely to never instantiate browsing
  contexts.</p>

  <hr />

  A <a>browsing context</a> can have a <dfn>creator browsing context</dfn>, the
  <a>browsing context</a> that was responsible for its creation. If a <a>browsing context</a> has a
  <a>parent browsing context</a>, then that is its <a>creator browsing context</a>. Otherwise, if
  the <a>browsing context</a> has an <a>opener browsing context</a>, then <em>that</em> is its
  <a>creator browsing context</a>. Otherwise, the <a>browsing context</a> has no
  <a>creator browsing context</a>.

  If a <a>browsing context</a> <var>A</var> has a <a>creator browsing context</a>, then the
  <dfn>creator origin</dfn>, <dfn>creator URL</dfn>, and <dfn>creator base URL</dfn> are the
  <a for="concept">origin</a>, <a lt="document url">URL</a>, and <a>base URL</a>, respectively, of
  the {{Document}} that was the <a>active document</a> of that <a>creator browsing context</a> at
  the time <var>A</var> was created.

  To <dfn lt="creating a new browsing context|create a new browsing context">create a new browsing context</dfn>:

  1. Call the JavaScript <a>InitializeHostDefinedRealm</a>() abstract operation with the following
      customizations:
      * For the global object, create a new {{Window}} object <var>window</var>.
      * For the global <em>this</em> value, create a new {{WindowProxy}} object
         <var>windowProxy</var>, whose [[{{Window}}]] internal slot value is <var>window</var>.

         <p class="note">The internal slot value is updated when navigations occur.</p>
      * Let <var>realm execution context</var> be the created <a>JavaScript execution context</a>.
  2. Set the new <a>browsing context</a>'s associated {{WindowProxy}} to <var>windowProxy</var>.
  3. Let <var>document</var> be a new {{Document}}, whose <a for="url">URL</a> is
      <a scheme>about:blank</a>, which is marked as being an <a>HTML document</a>, whose
      <a>character encoding</a> is UTF-8, and which is both <a>ready for post-load tasks</a> and
      <a>completely loaded</a> immediately.
  4. Set the <a for="concept">origin</a> of <var>document</var>:
      * If the new <a>browsing context</a> has a <a>creator browsing context</a>, then the
         <a for="concept">origin</a> of <var>document</var> is the <a>creator origin</a>.
      * Otherwise, the <a for="concept">origin</a> of <var>document</var> is a unique
         <a>opaque origin</a> assigned when the new <a>browsing context</a> is created.
  5. If the new <a>browsing context</a> has a <a>creator browsing context</a>, then set
      <var>document</var>'s <a>referrer</a> to the <a>creator URL</a>.
  6. Ensure that <var>document</var> has a single child <{html}> node, which itself has two empty
      child nodes: a <{head}> element, and a <{body}> element.
  7. <a>Implement the sandboxing</a> for <var>document</var>.
  8. Add <var>document</var> to the new <a>browsing context</a>'s <a>session history</a>.
  9. Set <var>window</var>'s associated {{Document}} to <var>document</var>.
  10. <a>Set up a browsing context environment settings object</a> with
       <var>realm execution context</var>.

<h4 id="sec-nested-browsing-contexts"><dfn lt="nested browsing contexts|nested browsing context">Nested browsing contexts</dfn></h4>

  Certain elements (for example, <{iframe}> elements) can instantiate further <a>browsing contexts</a>. These are called nested browsing contexts. If a browsing context <var>P</var> has a
  {{Document}} <var>D</var> with an element <var>E</var> that nests
  another browsing context <var>C</var> inside it, then <var>C</var> is said to be
  <dfn lt="through which new document is nested|nested through">nested through</dfn> <var>D</var>, and <var>E</var> is said to be the <dfn>browsing context container</dfn> of <var>C</var>.
  If the <a>browsing context container</a> element <var>E</var> is <a>in the <code>Document</code></a> <var>D</var>, then <var>P</var> is
  said to be the <dfn>parent browsing context</dfn> of <var>C</var> and <var>C</var> is said to be a <dfn lt="child browsing context|child browsing contexts">child browsing context</dfn> of <var>P</var>.
  Otherwise, the <a>nested browsing context</a> <var>C</var> has no <a>parent
  browsing context</a>.

  A browsing context <var>A</var> is said to be an <dfn lt="ancestor browsing context|ancestor">ancestor</dfn> of a browsing context <var>B</var> if there exists a browsing
  context <var>A</var> that is a <a>child browsing context</a> of <var>A</var> and that is itself an <a>ancestor</a> of
  <var>B</var>, or if the browsing context <var>A</var> is the
  <a>parent browsing context</a> of <var>B</var>.

  A browsing context that is not a <a>nested browsing context</a> has no <a>parent
  browsing context</a>, and is the <dfn>top-level browsing context</dfn> of all the browsing
  contexts for which it is an <a>ancestor browsing context</a>.

  The transitive closure of <a>parent browsing contexts</a>
  for a <a>nested browsing context</a> gives the list of <a>ancestor browsing contexts</a>.

  The <dfn>list of the descendant browsing contexts</dfn> of a {{Document}} <var>d</var> is the (ordered) list returned by the following algorithm:

  <ol>

    <li>Let <var>list</var> be an empty list.</li>

    <li>

    For each <a>child browsing context</a> of <var>d</var> that is <a>nested through</a> an element that is <a>in the <code>Document</code></a> <var>d</var>, in the <a>tree
    order</a> of the elements nesting those <a>browsing
    contexts</a>, run these substeps:

    <ol>

      <li>Append that <a>child browsing context</a> to the list <var>list</var>.

      <li>Append the <a>list of the descendant browsing contexts</a> of the <a>active
      document</a> of that <a>child browsing context</a> to the list <var>list</var>.</li>

    </ol>

    </li>

    <li>Return the constructed <var>list</var>.</li>

  </ol>

  A {{Document}} is said to be <dfn>fully active</dfn> when it has a <a>browsing context</a> and it is the <a>active document</a> of
  that <a>browsing context</a>, and either its browsing context is a <a>top-level browsing context</a>, or it has a <a>parent browsing context</a> and the {{Document}}
  through which it is nested is itself <a>fully active</a>.

  Because they are nested through an element, <a>child browsing contexts</a> are always tied to a
  specific {{Document}} in their <a>parent browsing context</a>. User agents must not allow the user
  to interact with <a>child browsing contexts</a> of elements that are in {{Document}}s that are
  not themselves <a>fully active</a>.

  A <a>nested browsing context</a> can be put into a <dfn>delaying <code>load</code> events mode</dfn>. This is used when it is <a>navigated</a>, to <a>delay the load event</a> of the <a>browsing
  context container</a> before the new {{Document}} is created.

  The <dfn>document family</dfn> of a <a>browsing context</a> consists of the union of all
  the {{Document}} objects in that <a>browsing context</a>'s <a>session
  history</a> and the <a>document families</a> of all those
  {{Document}} objects. The <a>document family</a> of a {{Document}} object
  consists of the union of all the <a>document families</a> of the
  <a>browsing contexts</a> that are <a>nested through</a> the {{Document}} object.

<h5 id="navigating-nested-browsing-contexts-in-the-dom">Navigating nested browsing contexts in the DOM</h5>

  <dl class="domintro">

    <dt><var>window</var> . <code>top</code></dt>

    <dd>

    Returns the <code>WindowProxy</code> for the <a>top-level browsing context</a>.

    </dd>

    <dt><var>window</var> . <code>parent</code></dt>

    <dd>

    Returns the <code>WindowProxy</code> for the <a>parent browsing context</a>.

    </dd>

    <dt><var>window</var> . <code>frameElement</code></dt>

    <dd>

    Returns the {{Element}} for the <a>browsing context container</a>.

    Returns null if there isn't one, and in cross-origin situations.

    </dd>

  </dl>

  The <dfn><code>top</code></dfn> IDL attribute on the <code>Window</code> object
  of a {{Document}} in a <a>browsing context</a> <var>b</var> must return
  the <code>WindowProxy</code> object of its <a>top-level browsing context</a> (which would be
  its own <code>WindowProxy</code> object if it was a <a>top-level browsing context</a>
  itself), if it has one, or its own <code>WindowProxy</code> object otherwise (e.g., if it was a
  detached <a>nested browsing context</a>).

  The <dfn attribute for="Window"><code>parent</code></dfn> IDL attribute on the {{Window}} object
  of a {{Document}} that has a <a>browsing context</a> <var>b</var> must return the {{WindowProxy}}
  object of the <a>parent browsing context</a>, if there is one (i.e., if <var>b</var> is a
  <a>child browsing context</a>), or the {{WindowProxy}} object of the <a>browsing context</a>
  <var>b</var> itself, otherwise (i.e., if it is a <a>top-level browsing context</a> or a detached
  <a>nested browsing context</a>).

  The <dfn attribute for="Window"><code>frameElement</code></dfn> IDL attribute, on getting, must
  run the following algorithm:

  1. Let <var>d</var> be the {{Window}} object's
      <a lt="document associated with a window">associated <code>Document</code></a>.
  2. Let <var>context</var> be <var>d</var>'s <a>browsing context</a>.
  3. If <var>context</var> is not a <a>nested browsing context</a>, return null and abort these
      steps.
  4. Let <var>container</var> be <var>context</var>'s <a>browsing context container</a>.
  5. If <var>container</var>'s <a>node document</a>'s <a for="concept">origin</a> is not
      <a>same origin-domain</a> with the <a>entry settings object</a>'s <a for="concept">origin</a>,
      then return null and abort these steps.
  6. Return <var>container</var>.

<h4 id="sec-auxiliary-browsing-contexts"><dfn lt="auxiliary browsing contexts|auxiliary browsing context">Auxiliary browsing contexts</dfn></h4>

  It is possible to create new browsing contexts that are related to a <a>top-level browsing
  context</a> without being nested through an element. Such browsing contexts are called <a>auxiliary browsing contexts</a>. Auxiliary browsing contexts
  are always <a>top-level browsing contexts</a>.

  An <a>auxiliary browsing context</a> has an <dfn>opener browsing context</dfn>, which is
  the <a>browsing context</a> from which the <a>auxiliary browsing context</a> was
  created.

<h5 id="navigating-auxiliary-browsing-contexts-in-the-dom">Navigating auxiliary browsing contexts in the DOM</h5>

  The <dfn><code>opener</code></dfn> IDL attribute on the <code>Window</code>
  object, on getting, must return the <code>WindowProxy</code> object of the <a>browsing
  context</a> from which the current <a>browsing context</a> was created (its <a>opener
  browsing context</a>), if there is one, if it is still available, and if the current
  <a>browsing context</a> has not <i>disowned its opener</i>;
  otherwise, it must return null. On setting, if the new value is null then the current
  <a>browsing context</a> must <dfn>disown its opener</dfn>; if
  the new value is anything else then the user agent must
  call the \[[DefineOwnProperty]] internal method of the <code>Window</code> object, passing the
  property name "<code>opener</code>" as the property key, and the Property Descriptor {
  \[[Value]]: <var>value</var>, \[[Writable]]: true, \[[Enumerable]]: true,
  \[[Configurable]]: true } as the property descriptor,
  where <var>value</var> is the new value.

<h4 id="browsing-context-security">Security</h4>

  A <a>browsing context</a> <var>A</var> is <dfn>familiar
  with</dfn> a second <a>browsing context</a> <var>B</var> if one of the following
  conditions is true:

  <ul>

    <li>Either the <a for="concept">origin</a> of the <a>active document</a> of <var>A</var>
    is the same as the <a for="concept">origin</a> of the <a>active
    document</a> of <var>B</var>, or</li>

    <li>The browsing context <var>A</var> is a <a>nested browsing context</a> with a
    <a>top-level browsing context</a>, and its <a>top-level browsing context</a> is <var>B</var>, or</li>

    <li>The browsing context <var>B</var> is an <a>auxiliary browsing context</a> and
    <var>A</var> is familiar with <var>B</var>'s <a>opener
    browsing context</a>, or</li>

    <li>The browsing context <var>B</var> is not a <a>top-level browsing context</a>,
    but there exists an <a>ancestor browsing context</a> of <var>B</var> whose
    <a>active document</a> has the <a>same origin</a> as
    the <a>active document</a> of <var>A</var> (possibly in fact being <var>A</var> itself).</li>

  </ul>

  <hr />

  A <a>browsing context</a> <var>A</var> is <dfn>allowed to navigate</dfn> a
  second <a>browsing context</a> <var>B</var> if the following algorithm terminates
  positively:

  <ol>

    <li>If <var>A</var> is not the same <a>browsing context</a> as <var>B</var>, and <var>A</var> is not one of the <a>ancestor browsing contexts</a> of <var>B</var>, and <var>B</var>
    is not a <a>top-level browsing context</a>, and <var>A</var>'s <a>active
    document</a>'s <a>active sandboxing flag set</a> has its <a>sandboxed navigation
    browsing context flag</a> set, then abort these steps negatively.</li>

    <li>Otherwise, if <var>B</var> is a <a>top-level browsing context</a>, and is
    one of the <a>ancestor browsing contexts</a> of <var>A</var>, and <var>A</var>'s <a>active document</a>'s <a>active sandboxing
    flag set</a> has its <a>sandboxed top-level navigation browsing context flag</a> set,
    then abort these steps negatively.</li>

    <li>Otherwise, if <var>B</var> is a <a>top-level browsing context</a>, and is
    neither <var>A</var> nor one of the <a>ancestor
    browsing contexts</a> of <var>A</var>, and <var>A</var>'s
    {{Document}}'s <a>active sandboxing flag set</a> has its <a>sandboxed
    navigation browsing context flag</a> set, and <var>A</var> is not the <a>one
    permitted sandboxed navigator</a> of <var>B</var>, then abort these steps
    negatively.</li>

    <li>Otherwise, terminate positively!</li>

  </ol>

  <hr />

  An element has a <dfn>browsing context scope origin</dfn> if its {{Document}}'s
  <a>browsing context</a> is a <a>top-level browsing context</a> or if all of its
  {{Document}}'s <a>ancestor browsing contexts</a>
  all have <a>active documents</a> whose <a for="concept">origin</a> are the
  <a>same origin</a> as the element's <a>node document</a>'s <a for="concept">origin</a>. If an
  element has a <a>browsing context scope origin</a>, then its value is the
  <a for="concept">origin</a> of the element's <a>node document</a>.

<h4 id="groupings-of-browsing-contexts">Groupings of browsing contexts</h4>

  Each <a>browsing context</a> is defined as having a list of one or more
  <dfn>directly reachable browsing contexts</dfn>. These are:

  * The <a>browsing context</a> itself.
  * All the <a>browsing context</a>'s <a>child browsing contexts</a>.
  * The <a>browsing context</a>'s <a>parent browsing context</a>.
  * All the <a>browsing contexts</a> that have the <a>browsing context</a> as their
     <a>opener browsing context</a>.
  * The <a>browsing context</a>'s <a>opener browsing context</a>.

  The transitive closure of all the <a>browsing contexts</a> that are
  <a>directly reachable browsing contexts</a> forms a <dfn>unit of related browsing contexts</dfn>.

  Each <a>unit of related browsing contexts</a> is then further divided into the smallest number of
  groups such that every member of each group has an <a>active document</a> with an
  <a for="concept">origin</a> that, through appropriate manipulation of the
  {{Document/domain|document.domain}} attribute, could be made to be <a>same origin-domain</a> with
  other members of the group, but could not be made the same as members of any other group. Each
  such group is a
  <dfn lt="units of related similar-origin browsing contexts|unit of related similar-origin browsing contexts">unit of related similar-origin browsing contexts</dfn>.

  <p class="note">There is also at most one <a>event loop</a> per
  <a>unit of related similar-origin browsing contexts</a> (though several
  <a>units of related similar-origin browsing contexts</a> can have a shared <a>event loop</a>).</p>

<h4 id="browsing-context-names">Browsing context names</h4>

  Browsing contexts can have a <dfn>browsing context name</dfn>. By default, a browsing context
  has no name (its name is not set).

  A <dfn>valid browsing context name</dfn> is any string with at least one character that does
  not start with a U+005F LOW LINE character. (Names starting with an underscore are reserved for
  special keywords.)

  A <dfn lt="valid browsing context names or keywords|valid browsing context name or keyword">valid browsing context name or keyword</dfn> is any string that is either a <a>valid
  browsing context name</a> or that is an <a>ASCII case-insensitive</a> match for one of:
  <code>_blank</code>, <code>_self</code>, <code>_parent</code>, or <code>_top</code>.

  These values have different meanings based on whether the page is sandboxed or not, as summarized
  in the following (non-normative) table. In this table, "current" means the <a>browsing context</a>
  that the link or script is in, "parent" means the <a>parent browsing context</a> of the one the
  link or script is in, "top" means the <a>top-level browsing context</a> of the one the link or
  script is in, "new" means a new <a>top-level browsing context</a> or
  <a>auxiliary browsing context</a> is to be created, subject to various user preferences and user
  agent policies, "none" means that nothing will happen, and "maybe new" means the same as "new" if
  the "<code>allow-popups</code>" keyword is also specified on the <{iframe/sandbox}> attribute
  (or if the user overrode the sandboxing), and the same as "none" otherwise.

  <table>
    <thead>
    <tr>
      <th rowspan=2>Keyword
      <th rowspan=2>Ordinary effect
      <th colspan=2>Effect in an <code>iframe</code> with...
    <tr>
      <th><code>sandbox=""</code>
      <th><code>sandbox="allow-top-navigation"</code>
    <tbody>
    <tr>
      <td>none specified, for links and <a>form submissions</a>
      <td>current
      <td>current
      <td>current

    <tr>
      <td>empty string
      <td>current
      <td>current
      <td>current

    <tr>
      <td><code>_blank</code>
      <td>new
      <td>maybe new
      <td>maybe new

    <tr>
      <td><code>_self</code>
      <td>current
      <td>current
      <td>current

    <tr>
      <td><code>_parent</code> if there isn't a parent
      <td>current
      <td>current
      <td>current

    <tr>
      <td><code>_parent</code> if parent is also top
      <td>parent/top
      <td>none
      <td>parent/top

    <tr>
      <td><code>_parent</code> if there is one and it's not top
      <td>parent
      <td>none
      <td>none

    <tr>
      <td><code>_top</code> if top is current
      <td>current
      <td>current
      <td>current

    <tr>
      <td><code>_top</code> if top is not current
      <td>top
      <td>none
      <td>top

    <tr>
      <td>name that doesn't exist
      <td>new
      <td>maybe new
      <td>maybe new

    <tr>
      <td>name that exists and is a descendant
      <td>specified descendant
      <td>specified descendant
      <td>specified descendant

    <tr>
      <td>name that exists and is current
      <td>current
      <td>current
      <td>current

    <tr>
      <td>name that exists and is an ancestor that is top
      <td>specified ancestor
      <td>none
      <td>specified ancestor/top

    <tr>
      <td>name that exists and is an ancestor that is not top
      <td>specified ancestor
      <td>none
      <td>none

    <tr>
      <td>other name that exists with common top
      <td>specified
      <td>none
      <td>none

    <tr>
      <td>name that exists with different top, if familiar and <a>one permitted sandboxed navigator</a>
      <td>specified
      <td>specified
      <td>specified

    <tr>
      <td>name that exists with different top, if familiar but not <a>one permitted sandboxed navigator</a>
      <td>specified
      <td>none
      <td>none

    <tr>
      <td>name that exists with different top, not familiar
      <td>new
      <td>maybe new
      <td>maybe new

  </table>

  <small>Most of the restrictions on sandboxed browsing contexts are applied by
  other algorithms, e.g., the <a>navigation</a> algorithm, not <a>the rules
  for choosing a browsing context given a browsing context name</a> given below.</small>

  <div class="impl">

  <hr />

  An algorithm is <dfn>allowed to show a popup</dfn> if any of the following conditions is
  true:

  <ul>

    <li>The <a>task</a> in which the algorithm is running is currently
    processing an <a>activation behavior</a> whose <code>click</code> event
    was <a>trusted</a>.</li>

    <li>

    The <a>task</a> in which the algorithm is running is currently
    running the event listener for a <a>trusted</a> event whose
    type is in the following list:

    <ul class="brief">
      <li><code>change</code></li>
      <li><code>click</code></li>
      <li><code>dblclick</code></li>
      <li><code>mouseup</code></li>
      <li><code>reset</code></li>
      <li><code>submit</code></li>
    </ul>

    </li>

    <li>

    The <a>task</a> in which the algorithm is running was <a>queued</a> by an algorithm that was <a>allowed to show a popup</a>,
    and the chain of such algorithms started within a user-agent defined timeframe.

    <p class="example">
  For example, if a user clicked a button, it might be acceptable for a popup
    to result from that after 4 seconds, but it would likely not be acceptable for a popup to result
    from that after 4 hours.
  </p>

    </li>

  </ul>

  <hr />

  <dfn>The rules for choosing a browsing context given a browsing context name</dfn> are as
  follows. The rules assume that they are being applied in the context of a <a>browsing
  context</a>, as part of the execution of a <a>task</a>.

  <ol>

    <li>If the given browsing context name is the empty string or <code>_self</code>, then
    the chosen browsing context must be the current one.</li>

    <li>If the given browsing context name is <code>_parent</code>, then the chosen
    browsing context must be the <a><em>parent</em> browsing context</a> of the current one,
    unless there isn't one, in which case the chosen browsing context must be the current browsing
    context.</li>

    <li>If the given browsing context name is <code>_top</code>, then the chosen browsing
    context must be the <a>top-level browsing context</a> of the current one, if there is one,
    or else the current browsing context.</li>

    <li>If the given browsing context name is not <code>_blank</code> and there exists a
    browsing context whose <a lt="browsing context name">name</a> is the same as the given
    browsing context name, and the current browsing context is familiar with that
    browsing context, and the user agent determines that the two browsing contexts are related
    enough that it is ok if they reach each other, then that browsing context must be the chosen
    one. If there are multiple matching browsing contexts, the user agent should select one in some
    arbitrary consistent manner, such as the most recently opened, most recently focused, or more
    closely related.</li>

    <li>
    Otherwise, a new browsing context is being requested, and what happens depends on the user
    agent's configuration and abilities &mdash; it is determined by the rules given for the first
    applicable option from the following list:

    <dl class="switch">

      <dt>If the algorithm is not <a>allowed to show a popup</a> and the
      user agent has been configured to not show popups (i.e., the user agent has a "popup blocker"
      enabled)</dt>

      <dd>

      There is no chosen browsing context. The user agent may inform the user that a popup has
      been blocked.

      </dd>

      <dt><dfn lt="prevents content from creating new auxiliary browsing contexts"></dfn>If the current browsing context's <a>active document</a>'s
      <a>active sandboxing flag set</a> has the <a>sandboxed auxiliary navigation browsing
      context flag</a> set.</dt>

      <dd>

      Typically, there is no chosen browsing context.

      The user agent may offer to create a new <a>top-level browsing context</a> or reuse
      an existing <a>top-level browsing context</a>. If the user picks one of those options,
      then the designated browsing context must be the chosen one (the browsing context's name isn't
      set to the given browsing context name). The default behavior (if the user agent doesn't
      offer the option to the user, or if the user declines to allow a browsing context to be used)
      must be that there must not be a chosen browsing context.

      <p class="warning">If this case occurs, it means that an author has explicitly sandboxed the
      document that is trying to open a link.</p>

      </dd>

      <dt><dfn lt="causes the opener attribute to remain null"></dfn>If the user agent has been configured such that in this instance it will
      create a new browsing context, and the browsing context is being requested as part of <a>following a hyperlink</a> whose <a>link
      types</a> include the <code>noreferrer</code> keyword</dt>

      <dd>A new <a>top-level browsing context</a> must be created. If the given browsing
      context name is not <code>_blank</code>, then the new top-level browsing context's
      name must be the given browsing context name (otherwise, it has no name). The chosen browsing
      context must be this new browsing context. The creation of such a <a>browsing context</a>
      is <dfn>a new start for session storage</dfn>.

      <p class="note">
  If it is immediately <a>navigated</a>, then the
      navigation will be done with <a>replacement enabled</a>.
  </p></dd>

      <dt>If the user agent has been configured such that in this instance it will create a new
      browsing context, and the <code>noreferrer</code> keyword doesn't
      apply</dt>

      <dd>A new <a>auxiliary browsing context</a> must be created, with the <a>opener
      browsing context</a> being the current one. If the given browsing context name is not <code>_blank</code>, then the new auxiliary browsing context's name must be the given
      browsing context name (otherwise, it has no name). The chosen browsing context must be this new
      browsing context.

      <p class="note">
  If it is immediately <a>navigated</a>, then the
      navigation will be done with <a>replacement enabled</a>.
  </p></dd>

      <dt>If the user agent has been configured such that in this instance it will reuse the current
      browsing context</dt>

      <dd>The chosen browsing context is the current browsing context.</dd>

      <dt>If the user agent has been configured such that in this instance it will not find a
      browsing context</dt>

      <dd>There must not be a chosen browsing context.</dd>

    </dl>

    User agent implementors are encouraged to provide a way for users to configure the user agent
    to always reuse the current browsing context.

    If the current browsing context's <a>active document</a>'s <a>active sandboxing flag
    set</a> has both the <a>sandboxed navigation browsing context flag</a> and
    <a>sandbox propagates to auxiliary browsing contexts flag</a> set, and the chosen browsing
    context picked above, if any, is a new browsing context, then all the flags that are set in the
    current browsing context's <a>active document</a>'s <a>active sandboxing flag
    set</a> when the new browsing context is created must be set in the new browsing context's
    <a>popup sandboxing flag set</a>, and the current browsing context must be set as the new
    browsing context's <a>one permitted sandboxed navigator</a>.

    </li>

  </ol>

  </div>

<h4 id="script-settings-for-browsing-contexts">Script settings for browsing contexts</h4>

  When the user agent is required to
  <dfn>set up a browsing context environment settings object</dfn>, given a JavaScript execution
  context <var>execution context</var>, it must run the following steps:

  1. Let <var>realm</var> be the value of <var>execution context</var>'s Realm component.
  2. Let <var>window</var> be <var>realm</var>'s <a>global object</a>.
  3. Let <var>url</var> be a copy of the <a for="url">URL</a> of the {{Document}} with which
      <var>window</var> is associated.
  4. Let <var>settings object</var> be a new <a>environment settings object</a> whose algorithms are
      defined as follows:
      : The <a>realm execution context</a>
      :: Return <var>execution context</var>.

      : The <a>responsible browsing context</a>
      :: Return the <a>browsing context</a> with which <var>window</var> is associated.

      : The <a>responsible event loop</a>
      :: Return the <a>event loop</a> that is associated with the
          <a>unit of related similar-origin browsing contexts</a> to which <var>window</var>'s
          <a>browsing context</a> belongs.

      : The <a>responsible document</a>
      :: Return the {{Document}} with which <var>window</var> is currently associated.

      : The <a>API URL character encoding</a>
      :: Return the current <a>character encoding</a> of the {{Document}} with which
          <var>window</var> is currently associated.

      : The <a>API base URL</a>
      :: Return the current <a>base URL</a> of the {{Document}} with which <var>window</var> is
          currently associated.

      : The <a for="concept">origin</a>
      :: Return the <a for="concept">origin</a> of the {{Document}} with which <var>window</var> is
          currently associated.

      : The <a>creation URL</a>
      :: Return <var>url</var>.

      : The <a for="settings">HTTPS state</a>
      :: Return the <a for="document">HTTPS state</a> of the {{Document}} with which
          <var>window</var> is currently associated.
  5. Set <var>realm</var>'s \[[HostDefined]] field to <var>settings object</var>.
  6. Return <var>settings object</var>.

<h3 id="security-infrastructure-for-window-windowproxy-location">Security infrastructure for <code>Window</code>, <code>WindowProxy</code>, and {{Location}} objects</h3>

  Although typically objects cannot be accessed across origins, the web platform would not be true
  to itself if it did not have some legacy exceptions to that rule that the web depends upon.

<h4 id="integration-with-idl">Integration with IDL</h4>

  When <a>perform a security check</a> is invoked, with a <var>platformObject</var>,
  <var>realm</var>, <var>identifier</var>, and <var>type</var>, run these steps:

  1. If <var>platformObject</var> is a {{Window}} or {{Location}} object, then:
      1. Repeat for each <var>e</var> that is an element of
          <a>CrossOriginProperties</a>(<var>platformObject</var>):
          1. If <a>SameValue</a>(<var>e</var>.\[[Property]], <var>identifier</var>) is true, then:
              1. If <var>type</var> is "<code>method</code>" and <var>e</var> has neither
                  \[[NeedsGet]] nor \[[NeedsGet]], then return.
              2. Otherwise, if <var>type</var> is "<code>getter</code>" and
                  <var>e</var>.\[[NeedsGet]] is true, then return.
              3. Otherwise, if <var>type</var> is "<code>setter</code>" and
                  <var>e</var>.\[[NeedsSet]] is true, then return.
  2. If <a>IsPlatformObjectSameOrigin</a>(<var>platformObject</var>) is false, then throw a
      "{{SecurityError}}" {{DOMException}}.

<h4 id="shared-internal-slot-crossoriginpropertydescriptormap">Shared internal slot: \[[CrossOriginPropertyDescriptorMap]]</h4>

  {{Window}} and {{Location}} objects both have a [[<dfn>CrossOriginPropertyDescriptorMap</dfn>]]
  internal slot, whose value is initially an empty map.

  <p class="note">The [[<a>CrossOriginPropertyDescriptorMap</a>]] internal slot contains a map with
  entries whose keys are (currentOrigin, objectOrigin, propertyKey)-tuples and values are property
  descriptors, as a memoization of what is visible to scripts when currentOrigin inspects a
  {{Window}} or {{Location}} object from objectOrigin. It is filled lazily by
  <a>CrossOriginGetOwnPropertyHelper</a>, which consults it on future lookups.</p>

  User agents should allow a value held in the map to be garbage collected along with its
  corresponding key when nothing holds a reference to any part of the value. That is, as long as
  garbage collection is not observable.

  <div class="example">
  For example, with
  <pre highlight="javascript">const href = Object.getOwnPropertyDescriptor(crossOriginLocation, "href").set</pre>
  the value and its corresponding key in the map cannot be garbage collected as that would be
  observable.
  </div>

  User agents may have an optimization whereby they remove key-value pairs from the map when
  {{Document/domain|document.domain}} is set. This is not observable as
  {{Document/domain|document.domain}} cannot revisit an earlier value.

  <div class="example">
  For example, setting {{Document/domain|document.domain}} to "<code>example.com</code>" on
  <code>www.example.com</code> means user agents can remove all key-value pairs from the map where
  part of the key is <code>www.example.com</code>, as that can never be part of the origin again and
  therefore the corresponding value could never be retrieved from the map.
  </div>

<h4 id="shared-abstract-operations">Shared abstract operations</h4>

<h5 id="crossoriginproperties-algorithm"><dfn>CrossOriginProperties</dfn> ( <var>O</var> )</h5>

  1. Assert: <var>O</var> is a {{Location}} or {{Window}} object.
  2. If <var>O</var> is a {{Location}} object, then return <pre>
      « {
          [[Property]]: "href",
          [[NeedsGet]]: false,
          [[NeedsSet]]: true
        },
        {
          [[Property]]: "replace"
        } »</pre>
  3. Let <var>crossOriginWindowProperties</var> be <pre>
      « {
          [[Property]]: "window",
          [[NeedsGet]]: true,
          [[NeedsSet]]: false
        },
        {
          [[Property]]: "self",
          [[NeedsGet]]: true,
          [[NeedsSet]]: false
        },
        {
          [[Property]]: "location",
          [[NeedsGet]]: true,
          [[NeedsSet]]: true
        },
        {
          [[Property]]: "close"
        },
        {
          [[Property]]: "closed",
          [[NeedsGet]]: true,
          [[NeedsSet]]: false
        },
        {
          [[Property]]: "focus"
        },
        {
          [[Property]]: "blur"
        },
        {
          [[Property]]: "frames",
          [[NeedsGet]]: true,
          [[NeedsSet]]: false
        },
        {
          [[Property]]: "length",
          [[NeedsGet]]: true,
          [[NeedsSet]]: false
        },
        {
          [[Property]]: "top",
          [[NeedsGet]]: true,
          [[NeedsSet]]: false
        },
        {
          [[Property]]: "opener",
          [[NeedsGet]]: true,
          [[NeedsSet]]: false
        },
        {
          [[Property]]: "parent",
          [[NeedsGet]]: true,
          [[NeedsSet]]: false
        },
        {
          [[Property]]: "postMessage"
        } »</pre>
  4. Repeat for each <var>e</var> that is an element of the
      <a>child browsing context name property set</a>:
      1. Add { \[[Property]]: <var>e</var> } as the last element of <var>crossOriginWindowProperties</var>.
  5. Return <var>crossOriginWindowProperties</var>.

  <p class="note">Indexed properties do not need to be safelisted as they are handled directly by
  the {{WindowProxy}} object.</p>

<h5 id="isplatformobjectsameorigin-algorithm"><dfn>IsPlatformObjectSameOrigin</dfn> ( <var>O</var> )</h5>

  1. Return true if the <a>current settings object</a>'s <a for="concept">origin</a> is
      <a>same origin-domain</a> with <var>O</var>'s <a>relevant settings object</a>'s
      <a for="concept">origin</a>, and false otherwise.

<h5 id="crossorigingetownpropertyhelper-algorithm"><dfn>CrossOriginGetOwnPropertyHelper</dfn> ( <var>O</var>, <var>P</var> )</h5>

  <p class="note">If this abstract operation returns undefined and there is no custom behavior, the
  caller needs to throw a "{{SecurityError}}" {{DOMException}}.</p>

  1. If <var>P</var> is <a>@@toStringTag</a>, <a>@@hasInstance</a>, or <a>@@isConcatSpreadable</a>,
      then return <a>PropertyDescriptor</a>
      { \[[Value]]: undefined, \[[Writable]]: false, \[[Enumerable]]: false,
      \[[Configurable]]: true }.
  2. Let <var>crossOriginKey</var> be a tuple consisting of the <a>current settings object</a>'s
      <a for="concept">origin</a>'s <a>effective domain</a>, <var>O</var>'s relevant settings
      object's <a for="concept">origin</a>'s <a>effective domain</a>, and <var>P</var>.
  3. Repeat for each <var>e</var> that is an element of <a>CrossOriginProperties</a>(<var>O</var>):
     1. If <a>SameValue</a>(<var>e</var>.\[[Property]], <var>P</var>) is true, then:
         1. If the value of the [[<a>CrossOriginPropertyDescriptorMap</a>]] internal slot of
             <var>O</var> contains an entry whose key is <var>crossOriginKey</var>, then return that
             entry's value.
         2. Let <var>originalDesc</var> be <a>OrdinaryGetOwnProperty</a>(<var>O</var>,
             <var>P</var>).
         3. Let <var>crossOriginDesc</var> be <a>CrossOriginPropertyDescriptor</a>(<var>e</var>,
             <var>originalDesc</var>).
         4. Create an entry in the value of the [[<a>CrossOriginPropertyDescriptorMap</a>]]
             internal slot of <var>O</var> with key <var>crossOriginKey</var> and value
             <var>crossOriginDesc</var>.
         5. Return <var>crossOriginDesc</var>.
  4. Return undefined.

<h6 id="crossoriginpropertydescriptor-algorithm"><dfn>CrossOriginPropertyDescriptor</dfn> ( <var>crossOriginProperty</var>, <var>originalDesc</var> )</h6>

  1. If <var>crossOriginProperty</var>.\[[NeedsGet]] and
      <var>crossOriginProperty</var>.\[[NeedsSet]] are absent, then:
      1. Let <var>value</var> be <var>originalDesc</var>.\[[Value]].
      2. If <a>IsCallable</a>(<var>value</var>) is true, set <var>value</var> to
          <a>CrossOriginFunctionWrapper</a>(true, <var>value</var>).
      3. Return <a>PropertyDescriptor</a>{ \[[Value]]: <var>value</var>, \[[Enumerable]]: false,
          \[[Writable]]: false, \[[Configurable]]: true }.
  2. Otherwise:
      1. Let <var>crossOriginGet</var> be
          <a>CrossOriginFunctionWrapper</a>(<var>crossOriginProperty</var>.\[[NeedsGet]],
          <var>originalDesc</var>.\[[Get]]).
      2. Let <var>crossOriginSet</var> be
          <a>CrossOriginFunctionWrapper</a>(<var>crossOriginProperty</var>.\[[NeedsSet]],
          <var>originalDesc</var>.\[[Set]]).
      3. Return <a>PropertyDescriptor</a>{ \[[Get]]: <var>crossOriginGet</var>,
          \[[Set]]: <var>crossOriginSet</var>, \[[Enumerable]]: false, \[[Configurable]]: true }.

<h6 id="crossoriginfunctionwrapper-algorithm"><dfn>CrossOriginFunctionWrapper</dfn> ( <var>needsWrapping</var>, <var>functionToWrap</var> )</h6>

  1. If <var>needsWrapping</var> is false, then return undefined.
  2. Return a new <a>cross-origin wrapper function</a> whose \[[Wrapped]] internal slot is
      <var>functionToWrap</var>.

  A <dfn>cross-origin wrapper function</dfn> is an anonymous built-in function that has a
  \[[Wrapped]] internal slot.

  When a <a>cross-origin wrapper function</a> <var>F</var> is called with a list of arguments
  <var>argumentsList</var>, the following steps are taken:

  1. Assert: <var>F</var> has a \[[Wrapped]] internal slot that is a function.
  2. Let <var>wrappedFunction</var> be the \[[Wrapped]] internal slot of <var>F</var>.
  3. Return <a>Call</a>(<var>wrappedFunction</var>, this, <var>argumentsList</var>).

  <p class="note">Due to this being invoked from a different <a for="concept">origin</a>, a
  <a>cross-origin wrapper function</a> will have a different value for
  <code>Function.prototype</code> from the function being wrapped. This follows from how JavaScript
  creates anonymous built-in functions.</p>

<h5 id="crossoriginget-algorithm"><dfn>CrossOriginGet</dfn> ( <var>O</var>, <var>P</var>, <var>Receiver</var> )</h5>

  1. Let <var>desc</var> be <var>O</var>.\[[GetOwnProperty]](<var>P</var>).
  2. Assert: <var>desc</var> is not undefined.
  3. If <a>IsDataDescriptor</a>(<var>desc</var>) is true, then return <var>desc</var>.\[[Value]].
  4. Assert: <a>IsAccessorDescriptor</a>(<var>desc</var>) is true.
  5. Let <var>getter</var> be <var>desc</var>.\[[Get]].
  6. If <var>getter</var> is undefined, throw a "{{SecurityError}}" {{DOMException}}.
  7. Return <a>Call</a>(<var>getter</var>, <var>Receiver</var>).

<h5 id="crossoriginset-algorithm"><dfn>CrossOriginSet</dfn> ( <var>O</var>, <var>P</var>, V, <var>Receiver</var> )</h5>

  1. Let <var>desc</var> be <var>O</var>.\[[GetOwnProperty]](<var>P</var>).
  2. Assert: <var>desc</var> is not undefined.
  3. If <a>IsAccessorDescriptor</a>(<var>desc</var>) is true, then:
      1. Let <var>setter</var> be <var>desc</var>.\[[Set]].
      2. If <var>setter</var> is undefined, return false.
      3. Perform <a>Call</a>(<var>setter</var>, <var>Receiver</var>, «V»).
      4. Return true.
  4. Return false.

<h5 id="crossoriginownpropertykeys-algorithm"><dfn>CrossOriginOwnPropertyKeys</dfn> ( <var>O</var> )</h5>

  1. Let <var>keys</var> be a new empty <a for="ecma">List</a>.
  2. Repeat for each <var>e</var> that is an element of <a>CrossOriginProperties</a>(<var>O</var>):
      1. Add <var>e</var>.\[[Property]] as the last element of <var>keys</var>.
  3. Return <var>keys</var>.

<h3 id="the-window-object">The <code>Window</code> object</h3>

  <pre class="idl" data-highlight="webidl" dfn-for="Window">
    [PrimaryGlobal, LegacyUnenumerableNamedProperties]
    /*sealed*/ interface Window : EventTarget {
    // the current browsing context
    [Unforgeable] readonly attribute WindowProxy window;
    [Replaceable] readonly attribute WindowProxy self;
    [Unforgeable] readonly attribute Document document;
    attribute DOMString name;
    [PutForwards=href, Unforgeable] readonly attribute Location location;
    readonly attribute History history;
    [Replaceable] readonly attribute BarProp locationbar;
    [Replaceable] readonly attribute BarProp menubar;
    [Replaceable] readonly attribute BarProp personalbar;
    [Replaceable] readonly attribute BarProp scrollbars;
    [Replaceable] readonly attribute BarProp statusbar;
    [Replaceable] readonly attribute BarProp toolbar;
    attribute DOMString status;
    void close();
    readonly attribute boolean closed;
    void stop();
    void focus();
    void blur();

    // other browsing contexts
    [Replaceable] readonly attribute WindowProxy frames;
    [Replaceable] readonly attribute unsigned long length;
    [Unforgeable] readonly attribute WindowProxy top;
    attribute any opener;
    [Replaceable] readonly attribute WindowProxy parent;
    readonly attribute Element? frameElement;
    WindowProxy open(optional DOMString url = "about:blank", optional DOMString target = "_blank", [TreatNullAs=EmptyString] optional DOMString features = "", optional boolean replace = false);
    getter WindowProxy (unsigned long index);
    getter object (DOMString name);

    // the user agent
    readonly attribute Navigator navigator;
    [Replaceable, SameObject] readonly attribute External external;

    // user prompts
    void alert();
    void alert(DOMString message);
    boolean confirm(optional DOMString message = "");
    DOMString? prompt(optional DOMString message = "", optional DOMString default = "");
    void print();
    any showModalDialog(DOMString url, optional any argument); // deprecated

    unsigned long requestAnimationFrame(FrameRequestCallback callback);
    void cancelAnimationFrame(unsigned long handle);
    };
    Window implements GlobalEventHandlers;
    Window implements WindowEventHandlers;

    callback <dfn>FrameRequestCallback</dfn> = void (DOMHighResTimeStamp time);
  </pre>

  <dl class="domintro">

    <dt><var>window</var> . <code>window</code></dt>
    <dt><var>window</var> . <code>frames</code></dt>
    <dt><var>window</var> . <code>self</code></dt>

    <dd>

    These attributes all return <var>window</var>.

    </dd>

    <dt><var>window</var> . <code>document</code></dt>

    <dd>

    Returns the {{Document}} associated with <var>window</var>.

    </dd>

    <dt><var>document</var> . <code>defaultView</code></dt>

    <dd>

    Returns the <code>Window</code> object of the <a>active document</a>.

    </dd>

  </dl>

  The <dfn attribute for="Window"><code>window</code></dfn>,
  <dfn attribute for="Window"><code>frames</code></dfn>, and
  <dfn attribute for="Window"><code>self</code></dfn>
  IDL attributes must all return the {{Window}} object's <a>browsing context</a>'s {{WindowProxy}}
  object.

  The <dfn attribute for="Window"><code>document</code></dfn> IDL attribute must return
  <a lt="document associated with a window">the <code>Window</code> object's newest <code>Document</code> object</a>.

  <p class="note">The {{Document}} object associated with a <code>Window</code> object can change in
  exactly one case: when the <a>navigate</a> algorithm initializes a new {{Document}} object for the
  first page loaded in a <a>browsing context</a>. In that specific case, the {{Window}} object of
  the original <a scheme>about:blank</a> page is reused and gets a new {{Document}} object.</p>

  The <dfn attribute for="Window"><code>defaultView</code></dfn> IDL attribute of the {{Document}}
  interface must return the {{Document}}'s <a>browsing context</a>'s {{WindowProxy}} object, if
  there is one, or null otherwise.

  <hr />

  For historical reasons, {{Window}} objects must also have a writable, configurable,
  non-enumerable property named <dfn><code>HTMLDocument</code></dfn> whose value is the
  {{Document}} interface object.

<h4 id="apis-for-creating-and-navigating-browsing-contexts-by-name">APIs for creating and navigating browsing contexts by name</h4>

  <dl class="domintro">

    <dt><var>window</var> = <var>window</var> . <code>open</code>( [ <var>url</var> [, <var>target</var> [, <var>features</var> [, <var>replace</var> ] ] ] ] )</dt>

    <dd>

    Opens a window to show <var>url</var> (defaults to <code>about:blank</code>), and
    returns it. The <var>target</var> argument gives the name of the new window. If a
    window exists with that name already, it is reused. The <var>replace</var> attribute,
    if true, means that whatever page is currently open in that window will be removed from the
    window's session history. The <var>features</var> argument can be used to influence the rendering of the new window.

    </dd>

    <dt><var>window</var> . <code>name</code> [ = <var>value</var> ]</dt>

    <dd>

    Returns the name of the window.

    Can be set, to change the name.

    </dd>

    <dt><var>window</var> . <code>close</code>()</dt>

    <dd>

    Closes the window.

    </dd>

    <dt><var>window</var> . <code>closed</code></dt>

    <dd>

    Returns true if the window has been closed, false otherwise.

    </dd>

    <dt><var>window</var> . <code>stop</code>()</dt>

    <dd>

    Cancels the document load.

    </dd>

  </dl>

  <div class="impl">

  The <dfn method for="Window"><code>open()</code></dfn> method on <code>Window</code> objects
  provides a mechanism for <a>navigating</a> an existing <a>browsing
  context</a> or opening and navigating an <a>auxiliary browsing context</a>.

  When the method is invoked, the user agent must run the following steps:

  <ol>

    <li>Let <var>entry settings</var> be the <a>entry settings object</a> when the method
    was invoked.</li>

    <li>Let <var>url</var> be the first argument.</li>

    <li>Let <var>target</var> be the second argument.</li>

    <li>Let <var>features</var> be the third argument.</li>

    <li>Let <var>replace</var> be the fourth argument.</li>

    <li>Let <var>source browsing context</var> be the <a>responsible browsing context</a>
    specified by <var>entry settings</var>.</li>

    <li>If <var>target</var> is the empty string, let it be the string "<code>_blank</code>" instead.</li>

    <li>

    If the user has indicated a preference for which <a>browsing context</a> to navigate,
    follow these substeps:

    <ol>

      <li>Let <var>target browsing context</var> be the <a>browsing context</a> indicated by
      the user.</li>

      <li>If <var>target browsing context</var> is a new <a>top-level browsing context</a>,
      let the <var>source browsing context</var> be set as <var>target browsing context</var>'s
      <a>one permitted sandboxed navigator</a>.</li>

    </ol>

    <p class="example">
  For example, suppose there is a user agent that supports control-clicking a
    link to open it in a new tab. If a user clicks in that user agent on an element whose <code>onclick</code> handler uses the <code>window.open()</code> API to open a page in an iframe, but, while doing so,
    holds the control key down, the user agent could override the selection of the target browsing
    context to instead target a new tab.
  </p>

    Otherwise, apply <a>the rules for choosing a browsing context given a browsing context
    name</a> using <var>target</var> as the name and <var>source browsing context</var> as the
    context in which the algorithm is executed. If this results in there not being a chosen browsing
    context, then throw an <code>InvalidAccessError</code> exception and abort these steps.
    Otherwise, let <var>target browsing context</var> be the <a>browsing context</a> so
    obtained.

    </li>

    <li>If <var>target browsing context</var> was just created, either as part of <a>the rules
    for choosing a browsing context given a browsing context name</a> or due to the user
    indicating a preference for navigating a new <a>top-level browsing context</a>, then let
    <var>new</var> be true. Otherwise, let it be false.</li>

    <li>Interpret <var>features</var> as defined in the CSSOM View specification. [[!CSSOM-VIEW]]</li>

    <li>

    If <var>url</var> is the empty string, run the appropriate steps from the following list:

    <dl>

      <dt>If <var>new</var> is false</dt>

      <dd>Jump to the step labeled <i>end</i>.</dd>

      <dt>If <var>new</var> is true</dt>

      <dd>Let <var>resource</var> be the <a for="url">URL</a> "<code>about:blank</code>".</dd>

    </dl>

    Otherwise, <a>parse</a> <var>url</var> relative to <var>entry settings</var>, and let
    <var>resource</var> be
    the <a>resulting URL record</a>, if any. If the <a>parse a URL</a> algorithm
    failed, then run one of the following two steps instead:

    <ul>

      <li>Let <var>resource</var> be a resource representing an inline error page.</li>

      <li>If <var>new</var> is false, jump to the step labeled <i>end</i>, otherwise, let
      <var>resource</var> be the <a for="url">URL</a> "<code>about:blank</code>".</li>

    </ul>

    </li>

    <li>

    If <var>resource</var> is "<code>about:blank</code>" and <var>new</var> is true, <a>queue
    a task</a> to <a>fire a simple event</a> named <code>load</code> at
    <var>target browsing context</var>'s <code>Window</code> object, with <i>target override</i> set to <var>target browsing
    context</var>'s <code>Window</code> object's
    {{Document}} object.

    Otherwise, <a>navigate</a> <var>target browsing context</var>
    to <var>resource</var>, with the <a>exceptions enabled flag</a> set. If <var>new</var> is true, then
    <a>replacement must be enabled</a> also. The <a>source
    browsing context</a> is <var>source browsing context</var>.

    </li>

    <li><i>End</i>: Return the <code>WindowProxy</code> object of <var>target browsing
    context</var>.</li>

  </ol>

  <hr />

  The <dfn attribute for="Window"><code>name</code></dfn> attribute of the <code>Window</code> object
  must, on getting, return the current <a lt="browsing context name">name</a> of the
  <a>browsing context</a>, if one is set, or the empty string otherwise; and, on setting, set
  the <a lt="browsing context name">name</a> of the <a>browsing context</a> to the
  new value.

  <p class="note">
  The name <a>gets reset</a> when the browsing context is
  navigated to another domain.
  </p>

  <hr />

  The <dfn method for="Window"><code>close()</code></dfn> method on <code>Window</code>
  objects should, if all the following conditions are met, <a lt="close a browsing context">close</a> the <a>browsing context</a> <var>A</var>:

  <ul class="brief">

    <li>The corresponding <a>browsing context</a> <var>A</var> is
    <a>script-closable</a>.</li>

    <li>The <a>responsible browsing context</a> specified by the <a>incumbent settings
    object</a> is familiar with the <a>browsing context</a> <var>A</var>.</li>

    <li>The <a>responsible browsing context</a> specified by the
    <a>incumbent settings object</a> is <a>allowed to navigate</a> the <a>browsing
    context</a> <var>A</var>.</li>

  </ul>

  A <a>browsing context</a> is <dfn>script-closable</dfn> if it is an <a>auxiliary
  browsing context</a> that was created by a script (as opposed to by an action of the user), or
  if it is a <a>top-level browsing context</a> whose <a>session history</a> contains
  only one {{Document}}.

  The <dfn attribute for="Window"><code>closed</code></dfn> attribute on <code>Window</code>
  objects must return true if the <code>Window</code> object's <a>browsing context</a> has
  been <a>discarded</a>, and false otherwise.

  The <dfn method for="Window"><code>stop()</code></dfn> method on <code>Window</code>
  objects should, if there is an existing attempt to <a>navigate</a> the <a>browsing
  context</a> and that attempt is not currently running the <a>unload a document</a>
  algorithm, cancel that <a>navigation</a>; then, it must <a>abort</a> the <a>active document</a> of the <a>browsing
  context</a> of the <code>Window</code> object on which it was invoked.

  </div>

<h4 id="accessing-other-browsing-contexts">Accessing other browsing contexts</h4>

  <dl class="domintro">
    <dt><var>window</var> . {{Window/length}}</dt>
    <dd>Returns the <a>number of child browsing contexts</a>.</dd>

    <dt><var>window</var>[<var>index</var>]</dt>
    <dd>Returns the indicated <a>child browsing context</a>.</dd>
  </dl>

  The <dfn>number of child browsing contexts</dfn> of a {{Window}} object <var>W</var> is the number
  of <a>child browsing contexts</a> that are <a>nested through</a> elements that are in a
  {{Document}} that is the <a>active document</a> of the {{Window}} object's
  <a lt="document associated with a window">associated</a> {{Document}} object's
  <a>browsing context</a>.

  The <dfn attribute for="Window"><code>length</code></dfn> IDL attribute's getter must return the
  <a>number of child browsing contexts</a> of this {{Window}} object.

  <p class="note">Indexed access to <a>child browsing contexts</a> is defined through the
  <a lt="windowproxy getownproperty">\[[GetOwnProperty]]</a> internal method of the {{WindowProxy}}
  object.</p>

<h4 id="named-access-on-the-window-object">Named access on the <code>Window</code> object</h4>

  <dl class="domintro">
    <dt><var>window</var>[<var>name</var>]</dt>
    <dd>Returns the indicated element or collection of elements.

    As a general rule, relying on this will lead to brittle code. Which IDs end up mapping to
    this API can vary over time, as new features are added to the Web platform, for example. Instead
    of this, use {{NonElementParentNode/getElementById()|document.getElementById()}} or
    <code>document.querySelector()</code>.
    </dd>
  </dl>

  The <dfn>child browsing context name property set</dfn> consists of the
  <a>browsing context names</a> of any <a>child browsing context</a> of the <a>active document</a>
  whose name is not the empty string, with duplicates omitted.

  The <code>Window</code> interface <a lt="support named properties">supports named properties</a>.
  The <a>supported property names</a> at any moment consist of the following, in <a>tree order</a>,
  ignoring later duplicates:

  * the <a>child browsing context name property set</a>.
  * the value of the <code>name</code> content attribute for all <{a}>, <{applet}>, <{area}>,
     <{embed}>, <{form}>, <{frameset}>, <{img}>, and <{object}> elements in the
     <a>active document</a> that have a non-empty <code>name</code> content attribute, and
  * the value of the <code>id</code> content attribute of any <a>HTML element</a> in the
     <a>active document</a> with a non-empty <code>id</code> content attribute.

  To <a spec="webidl">determine the value of a named property</a> <var>name</var> when
  <dfn>the <code>Window</code> object is indexed for property retrieval</dfn>, the user agent must
  return the value obtained using the following steps:

  <ol>

    <li>

    Let <var>objects</var> be the list of <a>named objects</a> with the name <var>name</var>
    in the <a>active document</a>.

    <p class="note">
  There will be at least one such object, by definition.

    </li>

    <li>

    If <var>objects</var> contains a <a>nested browsing context</a>, then return
    the <code>WindowProxy</code> object of the <a>nested browsing context</a> corresponding to
    the first <a>browsing context container</a> in <a>tree order</a> whose
    <a>browsing context</a> is in <var>objects</var>, and abort these steps.

    </li>

    <li>

    Otherwise, if <var>objects</var> has only one element, return that element and
    abort these steps.

    </li>

    <li>

    Otherwise return an <code>HTMLCollection</code> rooted at the {{Document}} node,
    whose filter matches only <a>named objects</a> with
    the name <var>name</var>. (By definition, these will all be elements.)

    </li>

  </ol>

  <dfn>Named objects</dfn> with the name <var>name</var>, for the purposes of the above algorithm, are those that are either:

  <ul>

    <li><a>child browsing contexts</a> of the <a>active
    document</a> whose name is <var>name</var>,</li>

    <li><{a}>, <{applet}>, <{area}>, <{embed}>,
    <{form}>, <{frameset}>, <{img}>, or <{object}> elements that
    have a <code>name</code> content attribute whose value is <var>name</var>, or</li>

    <li><a>html elements</a> that have an <code>id</code> content attribute
    whose value is <var>name</var>.</li>

  </ul>

  <div class="impl">

<h4 id="garbage-collection-and-browsing-contexts">Garbage collection and browsing contexts</h4>

  A <a>browsing context</a> has a strong reference to each of its {{Document}}s
  and its <code>WindowProxy</code> object, and the user agent itself has a strong reference to its
  <a>top-level browsing contexts</a>.

  A {{Document}} has a strong reference to its <code>Window</code> object.

  <p class="note">A <code>Window</code> object has a strong reference to its {{Document}} object through its <code>document</code> attribute. Thus, references from other scripts to either of
  those objects will keep both alive. Similarly, both {{Document}} and <code>Window</code>
  objects have <a>implied strong references</a> to the
  <code>WindowProxy</code> object.
  </p>

  Each <a for="concept">script</a> has a strong reference to its <a>settings
  object</a>, and each <a>environment settings object</a> has strong references to its
  <a>global object</a>, <a>responsible browsing context</a>, and <a>responsible
  document</a> (if any).

  When a <a>browsing context</a> is to <dfn lt="discard the document|discard a document">discard a <code>Document</code></dfn>, the user
  agent must run the following steps:

  <ol>

    <li>Set the {{Document}}'s <i>salvageable</i> state to false.</li>

    <li>Run any <a>unloading document cleanup steps</a> for the {{Document}} that
    are defined by this specification and <a lt="applicable specification">other applicable specifications</a>.</li>

    <li><a>Abort the <code>Document</code></a>.</li>

    <li>Remove any <a>tasks</a> associated with the
    {{Document}} in any <a>task source</a>, without running those tasks.</li>

    <li><a>Discard</a> all the <a>child browsing contexts</a> of the {{Document}}.</li>

    <li>Lose the strong reference from the {{Document}}'s <a>browsing context</a>
    to the {{Document}}.</li>

  </ol>

  <p class="note">
  Whenever a {{Document}} object is <a>discarded</a>, it is also removed from the list of the worker's
  <code>Documents</code> of each worker whose list contains that {{Document}}.
  </p>

  When <dfn lt="a browsing context is discarded|discard|discarded">a <em>browsing context</em> is discarded</dfn>, the strong reference from the user
  agent itself to the <a>browsing context</a> must be severed, and all the
  {{Document}} objects for all the entries in the <a>browsing context</a>'s session
  history must be <a>discarded</a> as well.

  User agents may <a>discard</a> <a>top-level browsing contexts</a> at any time (typically, in
  response to user requests, e.g., when a user force-closes a window containing one or more <a>top-level browsing contexts</a>). Other <a>browsing contexts</a> must be discarded once their
  <code>WindowProxy</code> object is eligible for garbage collection.

  </div>

<h4 id="closing-browsing-contexts">Closing browsing contexts</h4>

  When the user agent is required to <dfn>close a browsing context</dfn>, it must run the
  following steps:

  <ol>

    <li>Let <var>specified browsing context</var> be the <a>browsing context</a>
    being closed.</li>

    <li><a>Prompt to unload</a> the <a>active
    document</a> of the <var>specified browsing context</var>. If the user <a>refused
    to allow the document to be unloaded</a>, then abort these steps.</li>

    <li><a>Unload</a> the <a>active document</a> of the <var>specified browsing context</var> with the <var>recycle</var> parameter set to
    false.</li>

    <li>Remove the <var>specified browsing context</var> from the user interface (e.g.,
    close or hide its tab in a tabbed browser).</li>

    <li><a>Discard</a> the <var>specified
    browsing context</var>.</li>

  </ol>

  User agents should offer users the ability to arbitrarily <a lt="close a browsing context">close</a> any <a>top-level browsing context</a>.

<h4 id="browser-interface-elements">Browser interface elements</h4>

  To allow Web pages to integrate with Web browsers, certain Web browser interface elements are
  exposed in a limited way to scripts in Web pages.

  Each interface element is represented by a <code>BarProp</code> object:

  <pre class="idl" data-highlight="webidl" dfn-for="BarProp">
    interface BarProp {
      readonly attribute boolean visible;
    };
  </pre>

  <dl class="domintro">

    <dt><var>window</var> . <code>locationbar</code> . <code>visible</code></dt>
    <dd>
    Returns true if the location bar is visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>menubar</code> . <code>visible</code></dt>
    <dd>
    Returns true if the menu bar is visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>personalbar</code> . <code>visible</code></dt>

    <dd>
    Returns true if the personal bar is visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>scrollbars</code> . <code>visible</code></dt>
    <dd>
    Returns true if the scroll bars are visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>statusbar</code> . <code>visible</code></dt>
    <dd>
    Returns true if the status bar is visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>toolbar</code> . <code>visible</code></dt>
    <dd>
    Returns true if the toolbar is visible; otherwise, returns false.
    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="BarProp">visible</dfn> attribute, on getting, must return either
  true or a value determined by the user agent to most accurately represent the visibility state of
  the user interface element that the object represents, as described below.

  The following <code>BarProp</code> objects exist for each {{Document}} object in a
  <a>browsing context</a>. Some of the user interface elements represented by these objects
  might have no equivalent in some user agents; for those user agents, except when otherwise
  specified, the object must act as if it was present and visible (i.e., its <code>visible</code> attribute must return true).

  <dl>

    <dt><dfn>The location bar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface element that contains a control that displays the
    <a for="url">URL</a> of the <a>active document</a>, or some similar interface concept.</dd>

    <dt><dfn>The menu bar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface element that contains a list of commands in menu form, or some
    similar interface concept.</dd>

    <dt><dfn>The personal bar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface element that contains links to the user's favorite pages, or
    some similar interface concept.</dd>

    <dt><dfn>The scrollbar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface element that contains a scrolling mechanism, or some similar
    interface concept.</dd>

    <dt><dfn>The status bar <code>BarProp</code> object</dfn></dt>

    <dd>Represents a user interface element found immediately below or after the document, as
    appropriate for the user's media, which typically provides information about ongoing network
    activity or information about elements that the user's pointing device is current indicating. If
    the user agent has no such user interface element, then the object may act as if the
    corresponding user interface element was absent (i.e., its <code>visible</code> attribute may return false).</dd>

    <dt><dfn>The toolbar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface element found immediately above or before the document, as
    appropriate for the user's media, which typically provides <a>session history</a> traversal
    controls (back and forward buttons, reload buttons, etc). If the user agent has no such user
    interface element, then the object may act as if the corresponding user interface element was
    absent (i.e., its <code>visible</code> attribute may return
    false).</dd>

  </dl>

  The <dfn attribute for="Window"><code>locationbar</code></dfn> attribute must return
  <a>the location bar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>menubar</code></dfn> attribute must return <a>the
  menu bar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>personalbar</code></dfn> attribute must return
  <a>the personal bar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>scrollbars</code></dfn> attribute must return
  <a>the scrollbar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>statusbar</code></dfn> attribute must return
  <a>the status bar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>toolbar</code></dfn> attribute must return <a>the
  toolbar <code>BarProp</code> object</a>.

  <hr />

  For historical reasons, the <dfn attribute for="Window"><code>status</code></dfn> attribute
  on the <code>Window</code> object must, on getting, return the last string it was set to, and on
  setting, must set itself to the new value. When the <code>Window</code> object is created, the
  attribute must be set to the empty string. It does not do anything else.

  </div>

<h4 id="the-windowproxy-object">The <code>WindowProxy</code> object</h4>

  A <dfn interface><code>WindowProxy</code></dfn> is an exotic object that wraps a {{Window}}
  ordinary object, indirecting most operations through to the wrapped object. Each
  <a>browsing context</a> has an associated {{WindowProxy}} object. When the <a>browsing context</a>
  is <a>navigated</a>, the {{Window}} object wrapped by the <a>browsing context</a>'s associated
  {{WindowProxy}} object is changed.

  There is no {{WindowProxy}} interface object.

  Every {{WindowProxy}} object has a [[<dfn lt="window slot">Window</dfn>]] internal slot
  representing the wrapped {{Window}} object.

  <p class="note">Although {{WindowProxy}} is named as a "proxy", it does not do polymorphic
  dispatch on its target's internal methods as a real proxy would, due to a desire to reuse
  machinery between {{WindowProxy}} and {{Location}} objects. As long as the {{Window}} object
  remains an ordinary object this is unobservable and can be implemented either way.</p>

  <div class="example">
    In the following example, the variable <var>x</var> is set to the {{WindowProxy}} object
    returned by the {{Window/window}} accessor on the <a>global object</a>. All of the
    expressions following the assignment return true, because the {{WindowProxy}} object passes
    most operations through to the underlying ordinary {{Window}} object.

    <pre highlight="javascript">
      var x = window;
      x instanceof Window; // true
      x === this; // true
    </pre>
  </div>

<h5 id="windowproxy-internal-methods">The <code>WindowProxy</code> internal methods</h5>

  The {{WindowProxy}} object internal methods are described in the subsections below.

<h6 id="windowproxy-getprototypeof-algorithm">[[<dfn lt="windowproxy getprototypeof">GetPrototypeOf</dfn>]] ( )</h6>

  1. Let <var>W</var> be the value of the [[<a lt="window slot">Window</a>]] internal slot of
      <em>this</em>.
  2. If <a>IsPlatformObjectSameOrigin</a>(<var>W</var>) is true, then return !
      <a>OrdinaryGetPrototypeOf</a>(<var>W</var>).
  3. Return null.

<h6 id="windowproxy-setprototypeof-algorithm">[[<dfn lt="windowproxy setprototypeof">SetPrototypeOf</dfn>]] ( V )</h6>

  1. Return false.

<h6 id="windowproxy-isextensible-algorithm">[[<dfn lt="windowproxy isextensible">IsExtensible</dfn>]] ( )</h6>

  1. Return true.

<h6 id="windowproxy-preventextensions-algorithm">[[<dfn lt="windowproxy preventextensions">PreventExtensions</dfn>]] ( )</h6>

  1. Return false.

<h6 id="windowproxy-getownproperty-algorithm">[[<dfn lt="windowproxy getownproperty">GetOwnProperty</dfn>]] ( <var>P</var> )</h6>

  1. Let <var>W</var> be the value of the [[<a lt="window slot">Window</a>]] internal slot of
      <em>this</em>.
  2. If <var>P</var> is an <a>array index property name</a>, then:
      1. Let <var>index</var> be <a>ToUint32</a>(<var>P</var>).
      2. Let <var>maxProperties</var> be the <a>number of child browsing contexts</a> of
          <var>W</var>.
      3. Let <var>value</var> be undefined.
      4. If <var>maxProperties</var> is greater than 0 and <var>index</var> is less than
          <var>maxProperties</var>, then:
          1. Set <var>value</var> to the {{WindowProxy}} object of the <var>index</var>th
              <a>child browsing context</a> of the {{Document}} that is
              <a>nested through</a> an element that is in <var>W</var>'s {{Document}}, sorted in the
              order that the elements nesting those <a>browsing contexts</a> were most recently
              inserted into the {{Document}}, the {{WindowProxy}} object of the most recently
              inserted <a>browsing context container</a>'s <a>nested browsing context</a> being
              last.
      5. Return <a>PropertyDescriptor</a>{ \[[Value]]: <var>value</var>, \[[Writable]]: false,
          \[[Enumerable]]: false, \[[Configurable]]: true }.
  3. If <a>IsPlatformObjectSameOrigin</a>(<var>W</var>) is true, then return
      <a>OrdinaryGetOwnProperty</a>(<var>W</var>, <var>P</var>).

      <p class="note">This violates JavaScript's internal method invariants.</p>
  4. Let <var>property</var> be <a>CrossOriginGetOwnPropertyHelper</a>(<var>W</var>, <var>P</var>).
  5. If <var>property</var> is not undefined, return <var>property</var>.
  6. If <var>property</var> is undefined and <var>P</var> is in the
      <a>child browsing context name property set</a>, then:
      1. Let <var>value</var> be the {{WindowProxy}} object of the <a>named object</a> with the name
          <var>P</var>.
      2. Return <a>PropertyDescriptor</a>{ \[[Value]]: <var>value</var>, \[[Enumerable]]: false,
          \[[Writable]]: false, \[[Configurable]]: true }.
  7. Throw a "{{SecurityError}}" {{DOMException}}.

<h6 id="windowproxy-defineownproperty-algorithm">[[<dfn lt="windowproxy defineownproperty">DefineOwnProperty</dfn>]] ( <var>P</var>, <var>Desc</var> )</h6>

  1. If <var>P</var> is an <a>array index property name</a>, return false.
  2. Let <var>W</var> be the value of the [[<a lt="window slot">Window</a>]] internal slot of
      <em>this</em>.
  3. If <a>IsPlatformObjectSameOrigin</a>(<var>W</var>) is true, then return
      <a>OrdinaryDefineOwnProperty</a>(<var>W</var>, <var>P</var>, <var>Desc</var>).

      <p class="note">See above about how this violates JavaScript's internal method invariants.</p>
  4. Return false.

<h6 id="windowproxy-get-algorithm">[[<dfn lt="windowproxy get">Get</dfn>]] ( <var>P</var>, <var>Receiver</var> )</h6>

  1. Let <var>W</var> be the value of the [[<a lt="window slot">Window</a>]] internal slot of
      <em>this</em>.
  2. If <a>IsPlatformObjectSameOrigin</a>(<var>W</var>) is true, then return
      <a>OrdinaryGet</a>(this, <var>P</var>, <var>Receiver</var>).
  3. Return ? <a>CrossOriginGet</a>(this, <var>P</var>, <var>Receiver</var>).

<h6 id="windowproxy-set-algorithm">[[<dfn lt="windowproxy set">Set</dfn>]] ( <var>P</var>, V, <var>Receiver</var> )</h6>

  1. Let <var>W</var> be the value of the [[<a lt="window slot">Window</a>]] internal slot of
      <em>this</em>.
  2. If <a>IsPlatformObjectSameOrigin</a>(<var>W</var>) is true, then return
      <a>OrdinarySet</a>(<var>W</var>, this, <var>Receiver</var>).
  3. Return <a>CrossOriginSet</a>(this, <var>P</var>, V, <var>Receiver</var>).

<h6 id="windowproxy-delete-algorithm">[[<dfn lt="windowproxy delete">Delete</dfn>]] ( <var>P</var> )</h6>

  1. If <var>P</var> is an <a>array index property name</a>, return false.
  2. Let <var>W</var> be the value of the [[<a lt="window slot">Window</a>]] internal slot of
      <em>this</em>.
  3. If <a>IsPlatformObjectSameOrigin</a>(<var>W</var>) is true, then return
      <a>OrdinaryDelete</a>(<var>W</var>, <var>P</var>).
  4. Return false.

<h6 id="windowproxy-ownpropertykeys-algorithm">[[<dfn lt="windowproxy ownpropertykeys">OwnPropertyKeys</dfn>]] ( )</h6>

  1. Let <var>W</var> be the value of the [[<a lt="window slot">Window</a>]] internal slot of
      <em>this</em>.
  2. Let <var>keys</var> be a new empty <a for="ecma">List</a>.
  3. Let <var>maxProperties</var> be the <a>number of child browsing contexts</a> of <var>W</var>.
  4. Let <var>index</var> be 0.
  5. Repeat while <var>index</var> < <var>maxProperties</var>,
      1. Add ! <a>ToString</a>(<var>index</var>) as the last element of <var>keys</var>.
      2. Increment <var>index</var> by 1.
  6. If <a>IsPlatformObjectSameOrigin</a>(<var>W</var>) is true, then return the concatenation of
      <var>keys</var> and ! OrdinaryOwnPropertyKeys(<var>W</var>).
  7. Return the concatenation of <var>keys</var> and !
      <a>CrossOriginOwnPropertyKeys</a>(<var>W</var>).

<h3 id="section-origin">Origin</h3>

  Origins are the fundamental currency of the Web's security model. Two actors in the Web
  platform that share an origin are assumed to trust each other and to have the same authority.
  Actors with differing origins are considered potentially hostile versus each other, and are
  isolated from each other to varying degrees.

  <p class="example">For example, if Example Bank's Web site, hosted at
  <code>bank.example.com</code>, tries to examine the DOM of Example Charity's Web site, hosted at
  <code>charity.example.org</code>, a "{{SecurityError}}" {{DOMException}} will be raised.
  </p>

  <hr />

  An <dfn for="concept" lt="cross-origin|origin|origins">origin</dfn> is one of the following:

  : An <dfn>opaque origin</dfn>
  :: An internal value, with no serialisation, for which the only meaningful operation is testing
      for equality.

  : A <dfn lt="tuple origin|tuple">tuple origin</dfn>
  :: A <a>tuple</a> consists of:

      * A <dfn lt="origin scheme">scheme</dfn> (a <a for="url">scheme</a>).
      * A <dfn lt="origin host">host</dfn> (a <a for="url">host</a>).
      * A <dfn lt="origin port">port</dfn> (a <a for="url">port</a>).
      * A <dfn lt="origin domain">domain</dfn> (null or a <a for="url">domain</a>). Null unless
          stated otherwise.

  <p class="note">Origins can be shared, e.g., among multiple {{Document}} objects. Furthermore,
  <a for="concept">origins</a> are generally immutable. Only the <a lt="origin domain">domain</a> of a
  <a>tuple origin</a> can be changed, and only through the {{Document/domain|document.domain}} API.
  </p>

  The <dfn>effective domain</dfn> of an <a for="concept">origin</a> <var>origin</var> is computed as
  follows:

  1. If <var>origin</var> is an <a>opaque origin</a>, then return <var>origin</var>.
  2. If <var>origin</var>'s <a lt="origin domain">domain</a> is non-null, then return
      <var>origin</var>'s <a lt="origin domain">domain</a>.
  3. Return <var>origin</var>'s <a lt="origin host">host</a>.

  Various specification objects are defined to have an <a for="concept">origin</a>. These
  <a for="concept">origins</a> are determined as follows:

  : For {{Document}} objects
  ::
      <dl class="switch">
        <dt><dfn lt="forces content into a unique origin"></dfn>If the {{Document}}'s
        <a>active sandboxing flag set</a> has its <a>sandboxed origin browsing context flag</a>
        set</dt>
        <dd>A unique <a>opaque origin</a> is assigned when the {{Document}} is created.</dd>

        <dt>If the {{Document}}'s <a for="url">URL</a>'s <a for="url">scheme</a> is a
        <a>network scheme</a></dt>
        <dd>A copy of the {{Document}}'s <a for="url">URL</a>'s <a for="url">origin</a> assigned
        when the {{Document}} is created.

        <p class="note">The {{Document/open()|document.open()}} method can change the {{Document}}'s
        <a for="url">URL</a> to "<code>about:blank</code>". Therefore the
        <a for="concept">origin</a> is assigned when the {{Document}} is created.</p>
        </dd>

        <dt>If the {{Document}} is the initial "<code>about:blank</code>" document</dt>
        <dd><a lt="create a new browsing context">The one it was assigned when its browsing context
        was created</a>.</dd>

        <dt>If the {{Document}} is a non-initial "<code>about:blank</code>" document</dt>
        <dt>If the {{Document}} was generated from a <a scheme lt="data:"><code>data:</code> URL</a>
        found in another {{Document}} or in a script</dt>
        <dd>The <a for="concept">origin</a> of the <a>incumbent settings object</a> when the
        <a>navigate</a> algorithm was invoked, or, if no <a for="concept">script</a> was involved,
        of the <a>node document</a> of the element that initiated the <a>navigation</a> to that
        <a for="url">URL</a>.</dd>

        <dt>If the {{Document}} was created as part of the processing for
        <a><code>javascript:</code> URLs</a></dt>
        <dd>The <a for="concept">origin</a> of the <a>active document</a> of the
        <a>browsing context</a> being navigated when the <a>navigate</a> algorithm was invoked.</dd>

        <dt>If the {{Document}} is
        <a lt="iframe srcdoc document">an <code>iframe</code> <code>srcdoc</code> document</a></dt>
        <dd>The <a for="concept">origin</a> of the {{Document}}'s <a>browsing context</a>'s
        <a>browsing context container</a>'s <a>node document</a>.</dd>

        <dt>If the {{Document}} was obtained in some other manner (e.g., a
        <a scheme lt="data:"><code>data:</code> URL</a> typed in by the user or that was returned as
        the location of a redirect, a {{Document}} created using the
        {{DOMImplementation/createDocument()}} API, etc)</dt>
        <dd>The default behavior as defined in the DOM standard applies. [[!DOM]].

        <p class="note">The <a for="concept">origin</a> is a unique <a>opaque origin</a> assigned
        when the {{Document}} is created.</p>
        </dd>
      </dl>
  : For images of <{img}> elements
  ::
      <dl class="switch">
        <dt>If the image data is <a>CORS-cross-origin</a></dt>
        <dd>A unique <a>opaque origin</a> assigned when the image is created.</dd>

        <dt>If the image data is <a>CORS-same-origin</a></dt>
        <dd>The <{img}> element's <a>node document</a>'s <a for="concept">origin</a>.</dd>
      </dl>
  : For <{audio}> and <{video}> elements
  ::
      <dl class="switch">
        <dt>If the <a>media data</a> is <a>CORS-cross-origin</a></dt>
        <dd>A unique <a>opaque origin</a> assigned when the <a>media data</a> is fetched.</dd>

        <dt>If the <a>media data</a> is <a>CORS-same-origin</a></dt>
        <dd>The <a lt="media elements">media element</a>'s <a>node document</a>'s
        <a for="concept">origin</a>.
        </dd>
      </dl>
  : For fonts
  :: For a downloadable Web font it is a copy of the <a for="url">origin</a> of the
      <a>URL record</a> used to obtain the font (after any redirects). [[!CSS-FONTS-3]]
      [[CSS-FONT-LOADING-3]]

      For a locally installed system font it is the <a for="concept">origin</a> of the {{Document}}
      in which that font is being used.

  Other specifications can override the above definitions by themselves specifying the origin of
  a particular {{Document}} object, image, <a lt="media elements">media element</a>, or font.

  <hr />

  The <dfn lt="unicode serialization|unicode serialization of an origin">Unicode serialization of an origin</dfn>
  is the string obtained by applying the following algorithm to the given
  <a for="concept">origin</a> <var>origin</var>:

  1. If <var>origin</var> is an <a>opaque origin</a>, then return "<code>null</code>".
  2. Let <var>host</var> be <var>origin</var>'s <a lt="origin host">host</a>.
  3. Let <var>unicodeHost</var> be <var>host</var> if <var>host</var> is not a
      <a for="url">domain</a>, and the result of applying <a>domain to Unicode</a> to
      <var>host</var> otherwise.
  4. Let <var>unicodeOrigin</var> be a new <a>tuple origin</a> consisting <var>origin</var>'s
      <a lt="origin scheme">scheme</a>, <var>unicodeHost</var>, and <var>origin</var>'s
      <a lt="origin port">port</a>.
  5. Return the <a>ASCII serialization of an origin</a>, given <var>unicodeOrigin</var>.

      <p class="note">The name <a>ASCII serialization of an origin</a> is misleading, as it merely
      serialises an origin, which are all ASCII by default due to the <a>URL parser</a>.</p>

  <div class="example">
  The <a>Unicode serialization</a> of ("<code>https</code>", "<code>xn--maraa-rta.example</code>",
  null, null) is "<code>https://maraña.example</code>".
  </div>

  The <dfn>ASCII serialization of an origin</dfn> is the string obtained by applying the
  following algorithm to the given <a for="concept">origin</a> <var>origin</var>:

  1. If <var>origin</var> is an <a>opaque origin</a>, then return "<code>null</code>".
  2. Otherwise, let <var>result</var> be <var>origin</var>'s <a lt="origin scheme">scheme</a>.
  3. Append "<code>://</code>" to <var>result</var>.
  4. Append <var>origin</var>'s <a lt="origin host">host</a>, <a>serialized</a>, to
      <var>result</var>.
  5. If <var>origin</var>'s <a lt="origin port">port</a> is non-null, append a
      U+003A COLON character (:), and <var>origin</var>'s <a lt="origin port">port</a>,
      <a>serialized</a>, to <var>result</var>.
  6. Return <var>result</var>.

  Two <a for="concept">origins</a> <var>A</var> and <var>B</var> are said to be
  <dfn lt="same origin|comparing origins|cors-same-origin">same origin</dfn> if the following
  algorithm returns true:

  1. If <var>A</var> and <var>B</var> are the same <a>opaque origin</a>, then return true.
  2. If <var>A</var> and <var>B</var> are both <a>tuple origins</a>, and their
      <a lt="origin scheme">schemes</a>, <a lt="origin host">hosts</a>, and
      <a lt="origin port">ports</a> are identical, then return true.
  3. Return false.

  Two <a for="concept">origins</a> <var>A</var> and <var>B</var> are said to be
  <dfn>same origin-domain</dfn> if the following algorithm returns true:

  1. If <var>A</var> and <var>B</var> are the same <a>opaque origin</a>, then return true.
  2. If <var>A</var> and <var>B</var> are both <a>tuple origins</a>, run these substeps:
      1. If <var>A</var> and <var>B</var>'s <a lt="origin scheme">schemes</a> are identical, and
          their <a lt="origin domain">domains</a> are identical and non-null, then return true.
      2. Otherwise, if <var>A</var> and <var>B</var> are <a>same origin</a> and their
          <a lt="origin domain">domains</a> are identical and null, then return true.
  3. Return false.

  <div class="example">
  The following table shows how <var>A</var> and <var>B</var> are related:

  <table>
    <thead>
      <tr>
        <th>A
        <th>B
        <th><a>same origin</a>
        <th><a>same origin-domain</a>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>("<code>https</code>", "<code>example.org</code>", null, null)
        <td>("<code>https</code>", "<code>example.org</code>", null, null)
        <td>✅
        <td>✅
      </tr>
      <tr>
        <td>("<code>https</code>", "<code>example.org</code>", 314, "<code>example.org</code>")
        <td>("<code>https</code>", "<code>example.org</code>", 420, "<code>example.org</code>")
        <td>❌
        <td>✅
      </tr>
      <tr>
        <td>("<code>https</code>", "<code>example.org</code>", null, null)
        <td>("<code>https</code>", "<code>example.org</code>", null, "<code>example.org</code>")
        <td>✅
        <td>❌
      </tr>
      <tr>
        <td>("<code>https</code>", "<code>example.org</code>", null, "<code>example.org</code>")
        <td>("http", "<code>example.org</code>", null, "<code>example.org</code>")
        <td>❌
        <td>❌
      </tr>
    </tbody>
  </table>
  </div>

<h4 id="relaxing-the-same-origin-restriction">Relaxing the same-origin restriction</h4>

  <dl class="domintro">
    <dt><var>document</var> . {{Document/domain}} [ = <var>domain</var> ]</dt>
    <dd>Returns the current domain used for security checks.

    Can be set to a value that removes subdomains, to change the <a for="concept">origin</a>'s
    <a lt="origin domain">domain</a> to allow pages on other subdomains of the same domain (if they
    do the same thing) to access each other. (Can't be set in sandboxed <{iframe}>s.)
    </dd>
  </dl>

  The <dfn attribute for="Document"><code>domain</code></dfn> attribute's getter must run these
  steps:

  1. If this {{Document}} object does not have a <a>browsing context</a>, then return the empty
      string.
  2. Let <var>effectiveDomain</var> be this {{Document}}'s <a for="concept">origin</a>'s
     <a>effective domain</a>.
  3. If <var>effectiveDomain</var> is an <a>opaque origin</a>, then return the empty string.
  4. Return <var>effectiveDomain</var>, <a lt="host serializer">serialised</a>.

  The {{Document/domain}} attribute on setting must run these steps:

  1. If this {{Document}} object has no <a>browsing context</a>, throw a
      "{{SecurityError}}" {{DOMException}}.
  2. If this {{Document}} object's <a>active sandboxing flag set</a> has its
      <a>sandboxed <code>document.domain</code> browsing context flag</a> set, then throw a
      "{{SecurityError}}" {{DOMException}}.
  3. If the given value is the empty string, then throw a "{{SecurityError}}" {{DOMException}}.
  4. Let <var>host</var> be the result of <a lt="host parser">parsing</a> the given value.
  5. If <var>host</var> is failure, then throw a "{{SecurityError}}" {{DOMException}}.
  6. Let <var>effectiveDomain</var> be this {{Document}} object's <a for="concept">origin</a>'s
      <a>effective domain</a>.
  7. If <var>host</var> is not <a lt="host equals">equal</a> to <var>effectiveDomain</var>, then run
      these substeps:
      1. If <var>host</var> or <var>effectiveDomain</var> is not <a for="url">domain</a>, then throw
          a "{{SecurityError}}" {{DOMException}}.

          <p class="note">This is meant to exclude <a lt="origin hosts">hosts</a> that are an
          <a lt="ipv4">IPv4 address</a> or an <a lt="ipv6">IPv6 address</a>.
      2. If <var>host</var>, prefixed by a U+002E FULL STOP (.), does not exactly match
          the <var>effectiveDomain</var>, then throw a "{{SecurityError}}" {{DOMException}}.
      3. If <var>host</var> matches a suffix in the Public Suffix List, or, if <var>host</var>,
          prefixed by a U+002E FULL STOP (.), matches the end of a suffix in the Public Suffix List,
          then throw a "{{SecurityError}}" {{DOMException}}. [[!PSL]]

          Suffixes must be compared after applying the <a>host parser</a> algorithm. [[!URL]]
  8. Set <var>origin</var>'s <a lt="origin domain">domain</a> to <var>host</var>.

  <p class="note">The {{Document/domain|document.domain}} attribute is used to enable pages on
  different hosts of a domain to access each others' DOMs.</p>

  <p class="warning">Do not use the {{Document/domain|document.domain}} attribute when using shared
  hosting. If an untrusted third party is able to host an HTTP server at the same IP address but on
  a different port, then the same-origin protection that normally protects two different sites on
  the same host will fail, as the ports are ignored when comparing origins after the
  {{Document/domain|document.domain}} attribute has been used.</p>

<h3 id="sandboxing">Sandboxing</h3>

  A <dfn>sandboxing flag set</dfn> is a set of zero or more of the following flags, which are
  used to restrict the abilities that potentially untrusted resources have:

  <dl>

    <dt>The <dfn>sandboxed navigation browsing context flag</dfn></dt>

    <dd>

    This flag <a lt="navigating">prevents content from navigating browsing contexts other
    than the sandboxed browsing context itself</a> (or browsing contexts further nested inside it),
    <a>auxiliary browsing contexts</a> (which are protected
    by the <a>sandboxed auxiliary navigation browsing context flag</a> defined next), and the
    <a>top-level browsing context</a> (which is protected by the <a>sandboxed top-level
    navigation browsing context flag</a> defined below).

    If the <a>sandboxed auxiliary navigation browsing context flag</a> is not set, then in
    certain cases the restrictions nonetheless allow popups (new <a>top-level browsing contexts</a>) to be opened. These <a>browsing contexts</a> always have <dfn>one permitted sandboxed navigator</dfn>, set
    when the browsing context is created, which allows the <a>browsing context</a> that
    created them to actually navigate them. (Otherwise, the <a>sandboxed navigation browsing
    context flag</a> would prevent them from being navigated even if they were opened.)

    </dd>

    <dt>The <dfn>sandboxed auxiliary navigation browsing context flag</dfn></dt>

    <dd>

    This flag <a>prevents content from creating new auxiliary browsing
    contexts</a>, e.g., using the <code>target</code> attribute, the
    <code>window.open()</code> method, or the <code>showModalDialog()</code> method.

    </dd>

    <dt>The <dfn>sandboxed top-level navigation browsing context flag</dfn></dt>

    <dd>

    This flag <a lt="navigated">prevents content from navigating their top-level
    browsing context</a> and <a method for="Window" lt="close()">prevents content from closing their
    top-level browsing context</a>.

    When the <a>sandboxed top-level navigation browsing context flag</a> is <em>not</em>
    set, content can navigate its <a>top-level browsing context</a>, but other <a>browsing contexts</a> are still protected by the <a>sandboxed
    navigation browsing context flag</a> and possibly the <a>sandboxed auxiliary navigation
    browsing context flag</a>.

    </dd>

    <dt>The <dfn>sandboxed plugins browsing context flag</dfn></dt>

    <dd>

    This flag prevents content from instantiating <a>plugins</a>, whether
    using <span>the <{embed}> element</span>, <span>the <{object}> element</span>, <span>the <{applet}> element</span>, or through <a>navigation</a> of a <a>nested browsing context</a>, unless
    those <a>plugins</a> can be <a>secured</a>.

    </dd>

    <dt>The <dfn lt="sandboxed into a unique origin|sandboxed origin browsing context flag">sandboxed origin browsing context flag</dfn></dt>

    <dd>

    This flag <a>forces content into a unique origin</a>, thus preventing
    it from accessing other content from the same <a for="concept">origin</a>.

    This flag also <a lt="cookie-averse">prevents script from reading from or writing to the
    <code>document.cookie</code> IDL attribute</a>, and blocks access to
    <code>localStorage</code>. [[!WEBSTORAGE]]

    </dd>

    <dt>The <dfn>sandboxed forms browsing context flag</dfn></dt>

    <dd>

    This flag <a lt="submitted">blocks form submission</a>.

    </dd>

    <dt>The <dfn>sandboxed pointer lock browsing context flag</dfn></dt>

    <dd>

    This flag disables the Pointer Lock API. [[!POINTERLOCK]]

    </dd>

    <dt>The <dfn>sandboxed scripts browsing context flag</dfn></dt>

    <dd>

    This flag <a lt="Scripting is enabled">blocks script execution</a>.

    </dd>

    <dt>The <dfn>sandboxed automatic features browsing context flag</dfn></dt>

    <dd>

    This flag blocks features that trigger automatically, such as <a element-attr for="media" lt="autoplay">automatically playing a video</a> or <a element-attr for="formelements" lt="autofocus">automatically focusing a form control</a>.

    </dd>

    <dt>The <dfn>sandboxed storage area URLs flag</dfn></dt>

    <dd>

    This flag prevents URL schemes that use storage areas from being able to access the origin's
    data.

    </dd>

    <dt>The <dfn>sandboxed fullscreen browsing context flag</dfn></dt>

    <dd>

    This flag prevents content from using the <code>requestFullscreen()</code> method.

    </dd>

    <dt>The <dfn>sandboxed <code>document.domain</code> browsing context flag</dfn></dt>

    <dd>This flag prevents content from using the {{Document/domain|document.domain}} setter.</dd>

    <dt>The <dfn>sandbox propagates to auxiliary browsing contexts flag</dfn></dt>

    <dd>

    This flag prevents content from escaping the sandbox by ensuring that any
    <a>auxiliary browsing context</a> it creates inherits the content's
    <a>active sandboxing flag set</a>.

    </dd>

    <dt>The <dfn>sandboxed modals flag</dfn></dt>

    <dd>

    This flag prevents content from using any of the following features to produce modal
    dialogs:

    <ul>
      <li><code>window.alert()</code></li>
      <li><code>window.confirm()</code></li>
      <li><code>window.print()</code></li>
      <li><code>window.prompt()</code></li>
      <li><code>window.showModalDialog()</code></li>
      <li>the <code>beforeunload</code> event</li>
    </ul>

    </dd>

  </dl>

  When the user agent is to <dfn lt="parse the sandboxing directive|parse a sandboxing directive">parse a sandboxing directive</dfn>, given a string <var>input</var>, a <a>sandboxing flag set</a> <var>output</var>, and
  optionally an <var>allow fullscreen flag</var>, it must run the following steps:

  <ol>

    <li><a lt="split a string on spaces">Split <var>input</var> on spaces</a>,
    to obtain <var>tokens</var>.</li>

    <li>Let <var>output</var> be empty.</li>

    <li>

    Add the following flags to <var>output</var>:

    <ul>

      <li>The <a>sandboxed navigation browsing context flag</a>.</li>

      <li>The <a>sandboxed auxiliary navigation browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-popups</code></dfn> keyword.</li>

      <li>The <a>sandboxed top-level navigation browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-top-navigation</code></dfn>
      keyword.</li>

      <li>The <a>sandboxed plugins browsing context flag</a>.</li>

      <li>

      The <a>sandboxed origin browsing context flag</a>, unless the <var>tokens</var> contains the <dfn><code>allow-same-origin</code></dfn>
      keyword.

      <div class="note">

        The <code>allow-same-origin</code> keyword
        is intended for two cases.

        First, it can be used to allow content from the same site to be sandboxed to disable
        scripting, while still allowing access to the DOM of the sandboxed content.

        Second, it can be used to embed content from a third-party site, sandboxed to prevent that
        site from opening pop-up windows, etc, without preventing the embedded page from
        communicating back to its originating site, using the database APIs to store data, etc.

      </div>

      </li>

      <li>The <a>sandboxed forms browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-forms</code></dfn> keyword.</li>

      <li>The <a>sandboxed pointer lock browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-pointer-lock</code></dfn>
      keyword.</li>

      <li>The <a>sandboxed scripts browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-scripts</code></dfn> keyword.</li>

      <li>

      The <a>sandboxed automatic features browsing context flag</a>, unless <var>tokens</var> contains the <code>allow-scripts</code> keyword (defined above).

      <p class="note">
  This flag is relaxed by the same keyword as scripts, because when scripts are
      enabled these features are trivially possible anyway, and it would be unfortunate to force
      authors to use script to do them when sandboxed rather than allowing them to use the
      declarative features.
  </p>

      </li>

      <li>The <a>sandboxed storage area URLs flag</a>.</li>

      <li>The <a>sandboxed fullscreen browsing context flag</a>, unless the <var>allow fullscreen flag</var> was passed to the <a>parse a sandboxing
      directive</a> flag.</li>

      <li>The <a>sandboxed <code>document.domain</code> browsing
      context flag</a>.</li>

      <li>The <a>sandbox propagates to auxiliary browsing contexts flag</a>, unless
      <var>tokens</var> contains the <dfn><code>allow-popups-to-escape-sandbox</code></dfn>
      keyword.</li>

      <li>The <a>sandboxed modals flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-modals</code></dfn> keyword.</li>

    </ul>

    </li>

  </ol>

  <hr />

  Every <a>top-level browsing context</a> has a <dfn>popup sandboxing flag set</dfn>, which
  is a <a>sandboxing flag set</a>. When a <a>browsing context</a> is created, its
  <a>popup sandboxing flag set</a> must be empty. It is populated by <a>the rules for
  choosing a browsing context given a browsing context name</a>.

  Every <a>nested browsing context</a> has an <dfn><code>iframe</code> sandboxing flag
  set</dfn>, which is a <a>sandboxing flag set</a>. Which flags in a
  <a>nested browsing context</a>'s <a><code>iframe</code> sandboxing flag set</a> are set at any
  particular time is determined by the <{iframe}> element's <{iframe/sandbox}> attribute.

  Every {{Document}} has an <dfn>active sandboxing flag set</dfn>, which is a
  <a>sandboxing flag set</a>. When the {{Document}} is created, its <a>active
  sandboxing flag set</a> must be empty. It is populated by the <a>navigation
  algorithm</a>.

  Every resource that is obtained by the <a>navigation algorithm</a> has a
  <dfn>forced sandboxing flag set</dfn>, which is a <a>sandboxing flag set</a>. A resource by
  default has no flags set in its <a>forced sandboxing flag set</a>, but other specifications
  can define that certain flags are set.

  <p class="note">
  In particular, the <a>forced sandboxing flag set</a> is used by the Content
  Security Policy specification. [[!CSP3]]
  </p>

  <hr />

  When a user agent is to <dfn>implement the sandboxing</dfn> for a {{Document}}, it
  must populate {{Document}}'s <a>active sandboxing flag set</a> with the union of
  the flags that are present in the following <a>sandboxing flag
  sets</a> at the time the {{Document}} object is created:

  <ul>

    <li>If the {{Document}}'s <a>browsing context</a> is a <a>top-level browsing
    context</a>, then: the flags set on the <a>browsing context</a>'s <a>popup sandboxing
    flag set</a>.</li>

    <li>If the {{Document}}'s <a>browsing context</a> is a <a>nested browsing context</a>, then: the flags set on the <a>browsing context</a>'s
    <a><code>iframe</code> sandboxing flag set</a>.</li>

    <li>If the {{Document}}'s <a>browsing context</a> is a <a>nested browsing context</a>, then: the flags set on the <a>browsing context</a>'s <a>parent browsing
    context</a>'s <a>active document</a>'s <a>active sandboxing flag set</a>.</li>

    <li>The flags set on the {{Document}}'s resource's <a>forced sandboxing flag
    set</a>, if it has one.</li>

  </ul>

<h3 id="session-history-and-navigation">Session history and navigation</h3>

<h4 id="the-session-history-of-browsing-contexts">The session history of browsing contexts</h4>

  The sequence of {{Document}}s in a <a>browsing context</a> is its <dfn>session
  history</dfn>. Each <a>browsing context</a>, including <a>nested browsing contexts</a>, has a distinct session history. A <a>browsing
  context</a>'s session history consists of a flat list of <a>session history entries</a>. Each <dfn>session history entry</dfn> consists, at a
  minimum, of a <a for="url">URL</a>, and each entry may in addition have a <a>state object</a>, a
  title, a {{Document}} object, form data, a <a>scroll restoration mode</a>, a scroll
  position, and other information associated with it.

  <p class="note">
  Each entry, when first created, has a {{Document}}. However, when a
  {{Document}} is not <a lt="fully active">active</a>, it's possible for it to be
  <a>discarded</a> to free resources. The <a for="url">URL</a> and
  other data in a <a>session history entry</a> is then used to bring a new
  {{Document}} into being to take the place of the original, should the user agent find
  itself having to reactivate that {{Document}}.
  </p>

  <p class="note">
  Titles associated with <a>session history
  entries</a> need not have any relation with the current <code>title</code> of the
  {{Document}}. The title of a <a>session history entry</a> is intended to explain
  the state of the document at that point, so that the user can navigate the document's history.
  </p>

  URLs without associated <a>state objects</a> are added to the
  session history as the user (or script) navigates from page to page.

  <hr />

  Each {{Document}} object in a <a>browsing context</a>'s <a>session
  history</a> is associated with a unique <code>History</code> object which must all model the
  same underlying <a>session history</a>.

  <div class="impl">
    The <dfn attribute for="Window"><code>history</code></dfn> attribute of the <code>Window</code> interface must return
    the object implementing the <code>History</code> interface for that {{Window}}
    object's newest {{Document}}.
  </div>

  <hr />

  A <dfn>state object</dfn> is an object representing a user interface state.

  Pages can <a method for="History" lt="pushState()">add</a> <a>state
  objects</a> to the session history. These are then <a attribute for="WindowEventHandlers" lt="onpopstate">returned to the
  script</a> when the user (or script) goes back in the history, thus enabling authors to use the
  "navigation" metaphor even in one-page applications.

  <div class="note">
    <a>State objects</a> are intended to be used for two main purposes:
    first, storing a preparsed description of the state in the <a for="url">URL</a> so that in the simple
    case an author doesn't have to do the parsing (though one would still need the parsing for
    handling <a for="url">URLs</a> passed around by users, so it's only a minor
    optimization), and second, so that the author can store state that one wouldn't store in the URL
    because it only applies to the current {{Document}} instance and it would have to be
    reconstructed if a new {{Document}} were opened.

    An example of the latter would be something like keeping track of the precise coordinate from
    which a pop-up <code>div</code> was made to animate, so that if the user goes back, it can be
    made to animate to the same location. Or alternatively, it could be used to keep a pointer into a
    cache of data that would be fetched from the server based on the information in the
    <a for="url">URL</a>, so that when going back and forward, the information doesn't have to be fetched
    again.
  </div>

  <hr />

  At any point, one of the entries in the session history is the <dfn>current entry</dfn>. This
  is the entry representing the <a>active document</a> of the <a>browsing context</a>.
  Which entry is the <a>current entry</a> is changed by the algorithms defined in this
  specification, e.g., during <a>session history traversal</a>.

  <p class="note">
    The <a>current entry</a> is usually an entry for the <a>address</a> of the
    {{Document}}. However, it can also be one of the entries for <a>state objects</a> added
    to the history by that document.
  </p>

  <dfn>An entry with persisted user state</dfn> is one that also has user-agent defined state.
  This specification does not specify what kind of state can be stored.

  <p class="example">
  For example, some user agents might want to persist the scroll position, or the
  values of form controls.
  </p>

  <p class="note">
  User agents that persist the value of form controls are encouraged to also persist
  their directionality (the value of the element's <code>dir</code> attribute).
  This prevents values from being displayed incorrectly after a history traversal when the user had
  originally entered the values with an explicit, non-default directionality.
  </p>

  An entry's <dfn>scroll restoration mode</dfn> indicates whether the user agent should restore the
  persisted scroll position (if any) when traversing to it. The scroll restoration
  mode may be one of the following:</p>

  <dl>
   <dt>"<dfn value for="scrollRestorationMode"><code>auto</code></dfn>"</dt>
   <dd>The user agent is responsible for restoring the scroll position upon navigation.</dd>
   <dt>"<dfn value for="scrollRestorationMode"><code>manual</code></dfn>"</dt>
   <dd>The page is responsible for restoring the scroll position and the user agent does not
   attempt to do so automatically</dd>
  </dl>

  <p>If unspecified, the <a>scroll restoration mode</a> of a new entry must be set to
  "<code>auto</code>".</p>

  Entries that consist of <a>state objects</a> share the same
  {{Document}} as the entry for the page that was active when they were added.

  Contiguous entries that differ just by fragment identifier also share the same
  {{Document}}.

  <p class="note">
  All entries that share the same {{Document}} (and that are therefore
  merely different states of one particular document) are contiguous by definition.
  </p>

  Each {{Document}} in a <a>browsing context</a> can also have a <dfn>latest
  entry</dfn>. This is the entry for that {{Document}} to which the <a>browsing
  context</a>'s <a>session history</a> was most recently traversed. When a
  {{Document}} is created, it initially has no <a>latest entry</a>.

  <div class="impl">

  User agents may <a>discard</a> the {{Document}}
  objects of entries other than the <a>current entry</a> that are not referenced from any
  script, reloading the pages afresh when the user or script navigates back to such pages. This
  specification does not specify when user agents should discard {{Document}} objects and
  when they should cache them.

  Entries that have had their {{Document}} objects discarded must, for the purposes of
  the algorithms given below, act as if they had not. When the user or script navigates back or
  forwards to a page which has no in-memory DOM objects, any other entries that shared the same
  {{Document}} object with it must share the new object as well.

  </div>

<h4 id="the-history-interface">The <code>History</code> interface</h4>

  <pre class="idl" data-highlight="webidl" dfn-for="ScrollRestoration">
    enum ScrollRestoration { "auto", "manual" };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="History">
    interface History {
      readonly attribute unsigned long length;
      attribute ScrollRestoration scrollRestoration;
      readonly attribute any state;
      void go(optional long delta = 0);
      void back();
      void forward();
      void pushState(any data, DOMString title, optional DOMString? url = null);
      void replaceState(any data, DOMString title, optional DOMString? url = null);
    };
  </pre>

  <dl class="domintro">

    <dt><var>window</var> . <code>history</code> . <code>length</code></dt>

    <dd>

    Returns the number of entries in the <a>joint session history</a>.

    </dd>

   <dt><var>window</var> . <code>history</code> . <code>scrollRestoration</code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the <a>scroll restoration mode</a> of the current entry in the <a>session history</a>.</p>

    <p>Can be set, to change the <a>scroll restoration mode</a> of the current entry in the <a>session history</a>.</p>
   </dd>

    <dt><var>window</var> . <code>history</code> . <code>state</code></dt>

    <dd>

    Returns the current <a>state object</a>.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>go</code>( [ <var>delta</var> ] )</dt>

    <dd>

    Goes back or forward the specified number of steps in the <a>joint session history</a>.

    A zero delta will reload the current page.

    If the delta is out of range, does nothing.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>back</code>()</dt>

    <dd>

    Goes back one step in the <a>joint session history</a>.

    If there is no previous page, does nothing.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>forward</code>()</dt>

    <dd>

    Goes forward one step in the <a>joint session history</a>.

    If there is no next page, does nothing.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>pushState</code>(<var>data</var>, <var>title</var> [, <var>url</var> ] )</dt>

    <dd>

    Pushes the given data onto the session history, with the given title, and, if provided and
    not null, the given URL.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>replaceState</code>(<var>data</var>, <var>title</var> [, <var>url</var> ] )</dt>

    <dd>

    Updates the current entry in the session history to have the given data, title, and, if
    provided and not null, URL.

    </dd>

  </dl>

  The <dfn>joint session history</dfn> of a <a>top-level browsing context</a> is the union
  of all the <a>session histories</a> of all <a>browsing contexts</a> of all the <a>fully active</a> {{Document}}
  objects that share that <a>top-level browsing context</a>, with all the entries that are
  <a>current entries</a> in their respective <a>session histories</a> removed except for the <a>current entry of the joint session
  history</a>.

  The <dfn>current entry of the joint session history</dfn> is the entry that most recently
  became a <a>current entry</a> in its <a>session history</a>.

  Entries in the <a>joint session history</a> are ordered chronologically by the time they
  were added to their respective <a>session histories</a>. Each entry
  has an index; the earliest entry has index 0, and the subsequent entries are numbered with
  consecutively increasing integers (1, 2, 3, etc).

  <p class="note">
  Since each {{Document}} in a <a>browsing context</a> might have a
  different <a>event loop</a>, the actual state of the <a>joint session history</a> can
  be somewhat nebulous. For example, two sibling <{iframe}> elements could both <a>traverse</a> from one unique origin to another at the same time,
  so their precise order might not be well-defined; similarly, since they might only find out about
  each other later, they might disagree about the length of the <a>joint session
  history</a>.
  </p>

  <div class="impl">

  The <dfn attribute for="History"><code>length</code></dfn> attribute of the
  <code>History</code> interface, on getting, must return the number of entries in the
  <a>top-level browsing context</a>'s <a>joint session history</a>. If this
  <code>History</code> object is associated with a {{Document}} that is not
  <a>fully active</a>, getting must instead throw a "{{SecurityError}}" {{DOMException}}.

  The actual entries are not accessible from script.

  <p>The <dfn attribute for="History"><code>scrollRestoration</code></dfn> attribute
  of the History interface, on getting, must return the <a>scroll restoration mode</a> of the
  current entry in the <a>session history</a>. On setting, the <a>scroll restoration mode</a> of the current entry in the <a>session history</a> must be set to the new
  value. If this <code>History</code> object is associated with a {{Document}} that is
  not <a>fully active</a>, both getting and setting must instead throw a
  "{{SecurityError}}" {{DOMException}}.</p>

  The <dfn attribute for="History"><code>state</code></dfn> attribute of the
  <code>History</code> interface, on getting, must return the last value it was set to by the user
  agent. If this <code>History</code> object is associated with a {{Document}} that is
  not <a>fully active</a>, getting must instead throw a {{SecurityError}} {{DOMException}}.
  Initially, its value must be null.

  When the <dfn method for="History"><code>go(<var>delta</var>)</code></dfn> method is
  invoked, if <var>delta</var> is zero, the user agent must act as if the
  <code>location.reload()</code> method was called instead. Otherwise,
  the user agent must <a>traverse the history by a delta</a> whose value is
  <var>delta</var> If this <code>History</code> object is associated with a {{Document}}
  that is not <span>fully active</span>, invoking must instead throw a
  "{{SecurityError}}" {{DOMException}}.

  When the <dfn method for="History"><code>back()</code></dfn> method is invoked, the user
  agent must <a>traverse the history by a delta</a> &#x2212;1. If this <code>History</code>
  object is associated with a {{Document}} that is not <a>fully active</a>,
  invoking must instead throw a "{{SecurityError}}" {{DOMException}}.

  When the <dfn method for="History"><code>forward()</code></dfn>method is invoked, the
  user agent must <a>traverse the history by a delta</a> +1. If this <code>History</code>
  object is associated with a {{Document}} that is not <a>fully active</a>,
  invoking must instead throw a "{{SecurityError}}" {{DOMException}}.

  <hr />

  Each <a>top-level browsing context</a> has a <dfn>session history traversal queue</dfn>,
  initially empty, to which <a>tasks</a> can be added.

  Each <a>top-level browsing context</a>, when created, must begin running
  the following algorithm, known as the <dfn>session history event loop</dfn> for that
  <a>top-level browsing context</a>, <a>in parallel</a>:

  <ol>

    <li>Wait until this <a>top-level browsing context</a>'s <a>session history traversal
    queue</a> is not empty.</li>

    <li>Pull the first <a>task</a> from this <a>top-level browsing
    context</a>'s <a>session history traversal queue</a>, and execute it.</li>

    <li>Return to the first step of this algorithm.

  </ol>

  The <a>session history event loop</a> helps coordinate cross-browsing-context transitions
  of the <a>joint session history</a>: since each <a>browsing context</a> might, at any
  particular time, have a different <a>event loop</a> (this can happen if the user agent has
  more than one <a>event loop</a> per <a>unit of related browsing contexts</a>),
  transitions would otherwise have to involve cross-event-loop synchronization.

  <hr />

  To <dfn lt="explicitly going back or forwards in the session history|traverse the history by a delta">traverse the history by a delta</dfn> <var>delta</var>, the user agent must
  append a <a>task</a> to this <a>top-level browsing context</a>'s
  <a>session history traversal queue</a>, the <a>task</a>
  consisting of running the following steps:

  <ol>

    <li>If the index of the <a>current entry of the joint session history</a> plus <var>delta</var> is less than zero or greater than or equal to the number of items in the
    <a>joint session history</a>, then abort these steps.

    <li>Let <var>specified entry</var> be the entry in the <a>joint session
    history</a> whose index is the sum of <var>delta</var> and the index of the
    <a>current entry of the joint session history</a>.</li>

    <li>Let <var>specified browsing context</var> be the <a>browsing context</a> of
    the <var>specified entry</var>.</li>

    <li>If the <var>specified browsing context</var>'s <a>active document</a>'s
    <a>unload a document</a> algorithm is currently running, abort these steps.</li>

    <li>

    <a>Queue a task</a> that consists of running the following substeps. The relevant
    <a>event loop</a> is that of the <var>specified browsing context</var>'s
    <a>active document</a>. The <a>task source</a> for the queued task is the
    <a>history traversal task source</a>.

    <ol>

      <li>If there is an ongoing attempt to navigate <var>specified browsing context</var>
      that has not yet <a>matured</a> (i.e., it has not passed the
      point of making its {{Document}} the <a>active document</a>), then cancel that
      attempt to navigate the <a>browsing context</a>.</li>

      <li>

      If the <var>specified browsing context</var>'s <a>active document</a> is not
      the same {{Document}} as the {{Document}} of the <var>specified
      entry</var>, then run these substeps:

      <ol>

        <li><a>Prompt to unload</a> the <a>active
        document</a> of the <var>specified browsing context</var>. If the user
        <a>refused to allow the document to be unloaded</a>, then abort these steps.</li>

        <li><a>Unload</a> the <a>active document</a> of the
        <var>specified browsing context</var> with the <var>recycle</var> parameter
        set to false.</li>

      </ol>

      </li>

      <li><a>Traverse the history</a> of the <var>specified browsing context</var> to
      the <var>specified entry</var>.

    </ol>

    </li>

  </ol>

  When the user navigates through a <a>browsing context</a>, e.g., using a browser's back
  and forward buttons, the user agent must <a>traverse the history by a delta</a> equivalent
  to the action specified by the user.

  <hr />

  The <dfn method for="History"><code>pushState()</code></dfn> method adds a state object entry to
  the history.

  The <dfn method for="History"><code>replaceState()</code></dfn> method updates the state object,
  title, and optionally the <a for="url">URL</a> of the <a>current entry</a> in the history.

  When either of these methods is invoked, the user agent must run the following steps:

  1. If this {{History}} object is associated with a {{Document}} that is not <a>fully active</a>,
      throw a "{{SecurityError}}" {{DOMException}}.
  2. Optionally, abort these steps. (For example, the user agent might disallow calls to these
      methods that are invoked on a timer, or from event listeners that are not triggered in
      response to a clear user action, or that are invoked in rapid succession.)
  3. Let <var>targetRealm</var> be this {{History}} object's <a>relevant settings object</a>'s
      <a>Realm</a>.
  4. Let <var>cloned data</var> be a <a>StructuredClone</a>(<var>data</var>,
      <var>targetRealm</var>). Rethrow any exceptions.
  5. If the third argument is not null, run these substeps:
      1. <a>Parse</a> the value of the third argument, relative to the <a>entry settings object</a>.
      2. If that fails, throw a "{{SecurityError}}" {{DOMException}} and abort these steps.
      3. Let <var>new URL</var> be the <a>resulting URL record</a>.
      4. Compare <var>new URL</var> to the document's <a for="url">URL</a>. If any component of
          these two <a>URL records</a> differ other than the <a>path</a>,
          <a for="url">query</a>, and <a for="url">fragment</a> components, then throw a
          "{{SecurityError}}" {{DOMException}} and abort these steps.
      5. If the <a for="url">origin</a> of <var>new URL</var> is not the same as the
          <a for="concept">origin</a> of the <a>responsible document</a> specified by the
          <a>entry settings object</a>, and either the <a>path</a> or <a for="url">query</a>
          components of the two <a>URL records</a> compared in the previous step differ, throw a
          "{{SecurityError}}" {{DOMException}} and abort these steps. (This prevents
          sandboxed content from spoofing other pages on the same origin.)
  6. If the third argument is null, then let <var>new URL</var> be the <a for="url">URL</a> of the
      <a>current entry</a>.
  7. If the method invoked was the {{History/pushState()}} method:
      1. Remove all the entries in the <a>browsing context</a>'s <a>session history</a> after the
          <a>current entry</a>. If the <a>current entry</a> is the last entry in the session
          history, then no entries are removed.

          <p class="note">This <a>doesn't necessarily have to affect</a> the user agent's user
          interface.</p>
      2. Remove any <a>tasks</a> queued by the <a>history traversal task source</a> that are
          associated with any {{Document}} objects in the <a>top-level browsing context</a>'s
          <a>document family</a>.
      3. If appropriate, update the <a>current entry</a> to reflect any state that the user agent
          wishes to persist. The entry is then said to be <a>an entry with persisted user state</a>.
      4. Add a <a>state object</a> entry to the session history, after the <a>current entry</a>,
          with <var>cloned data</var> as the <a>state object</a>, the given <var>title</var> as the
          title, <var>new URL</var> as the <a for="url">URL</a> of the entry, and the
          <a>scroll restoration mode</a> of the current entry in the <a>session history</a> as the
          scroll restoration mode.
      5. Update the <a>current entry</a> to be this newly added entry.

      Otherwise, if the method invoked was the {{History/replaceState()}} method:

      1. Update the <a>current entry</a> in the session history so that <var>cloned data</var> is
          the entry's new state object, the given <var>title</var> is the new title, and
          <var>new URL</var> is the entry's new <a for="url">URL</a>.
  8. If the <a>current entry</a> in the session history represents a non-GET request (e.g., it was
      the result of a POST submission) then update it to instead represent a GET request.
  9. Set the document's <a for="url">URL</a> to <var>new URL</var>.

      <p class="note">Since this is neither a <a>navigation</a> of the <a>browsing context</a> nor a
      <a>history traversal</a>, it does not cause a <code>hashchange</code> event to be fired.</p>
  10. Let <var>targetRealm</var> be this {{History}} object's <a>relevant settings object</a>'s
       <a>Realm</a>.
  11. Set {{History/state|history.state}} to <a>StructuredClone</a>(<var>cloned data</var>,
       <var>targetRealm</var>).
  12. Let the <a>latest entry</a> of the {{Document}} of the <a>current entry</a> be the
       <a>current entry</a>.

  <p class="note">The <var>title</var> is purely advisory. User agents might use the title in the
  user interface.</p>

  User agents may limit the number of state objects added to the session history per page. If a
  page hits the user agent-defined limit, user agents must remove the entry immediately after the
  first entry for that {{Document}} object in the session history after having added the new
  entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for
  navigation.)

  </div>

  <div class="example">
    Consider a game where the user can navigate along a line, such that the user is always at some
    coordinate, and such that the user can bookmark the page corresponding to a particular
    coordinate, to return to it later.

    A static page implementing the x=5 position in such a game could look like the following:

    <pre highlight="html">
  &lt;!DOCTYPE HTML>
  &lt;!-- this is https://example.com/line?x=5 -->
  &lt;title>Line Game - 5&lt;/title>
  &lt;p>You are at coordinate 5 on the line.&lt;/p>
  &lt;p>
  &lt;a href="?x=6">Advance to 6&lt;/a> or
  &lt;a href="?x=4">retreat to 4&lt;/a>?
  &lt;/p>
  </pre>

    The problem with such a system is that each time the user clicks, the whole page has to be
    reloaded. Here instead is another way of doing it, using script:

    <pre highlight="html">
  &lt;!DOCTYPE HTML>
  &lt;!-- this starts off as https://example.com/line?x=5 -->
  &lt;title>Line Game - 5&lt;/title>
  &lt;p>You are at coordinate &lt;span>5&lt;/span> on the line.&lt;/p>
  &lt;p>
  &lt;a href="?x=6" onclick="go(1); return false;">Advance to 6&lt;/a> or
  &lt;a href="?x=4" onclick="go(-1); return false;">retreat to 4&lt;/a>?
  &lt;/p>
  &lt;script>
  var currentPage = 5; // prefilled by server
  function go(d) {
    setupPage(currentPage + d);
    history.pushState(currentPage, document.title, '?x=' + currentPage);
  }
  onpopstate = function(event) {
    setupPage(event.state);
  }
  function setupPage(page) {
    currentPage = page;
    document.title = 'Line Game - ' + currentPage;
    document.getElementById('coord').textContent = currentPage;
    document.links[0].href = '?x=' + (currentPage+1);
    document.links[0].textContent = 'Advance to ' + (currentPage+1);
    document.links[1].href = '?x=' + (currentPage-1);
    document.links[1].textContent = 'retreat to ' + (currentPage-1);
  }
  &lt;/script>
  </pre>

    In systems without script, this still works like the previous example. However, users that
    <em>do</em> have script support can now navigate much faster, since there is no network access
    for the same experience. Furthermore, contrary to the experience the user would have with just a
    na&iuml;ve script-based approach, bookmarking and navigating the session history still work.

    In the example above, the <var>data</var> argument to the <code>pushState()</code> method is the same information as would be sent
    to the server, but in a more convenient form, so that the script doesn't have to parse the URL
    each time the user navigates.
  </div>

  <div class="example">
    Applications might not use the same title for a <a>session history entry</a> as the
    value of the document's <a element for="html"><code>title</code></a> element at that time. For example, here is a simple
    page that shows a block in the <a element for="html"><code>title</code></a> element. Clearly, when navigating backwards to
    a previous state the user does not go back in time, and therefore it would be inappropriate to
    put the time in the session history title.

    <pre highlight="html">
  &lt;!DOCTYPE HTML>
  &lt;TITLE>Line&lt;/TITLE>
  &lt;SCRIPT>
  setInterval(function () { document.title = 'Line - ' + new Date(); }, 1000);
  var i = 1;
  function inc() {
    set(i+1);
    history.pushState(i, 'Line - ' + i);
  }
  function set(newI) {
    i = newI;
    document.forms.F.I.value = newI;
  }
  &lt;/SCRIPT>
  &lt;BODY ONPOPSTATE="set(event.state)">
  &lt;FORM NAME=F>
  State: &lt;OUTPUT NAME=I>1&lt;/OUTPUT> &lt;INPUT VALUE="Increment" TYPE=BUTTON ONCLICK="inc()">
  &lt;/FORM>
  </pre>
  </div>

  <div class="example">
    Most applications want to use the same <a>scroll restoration mode</a> value for all of
    their history entries. To achieve this they should set the <code>scrollRestoration</code> attribute as soon as possible
    (e.g., in the first <code>script</code> element in the document's <{head}> element) to
    ensure that any entry added to the history session gets the desired scroll restoration mode.

    <pre highlight="html">
      &lt;head&gt;
        &lt;script&gt;
          if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
        &lt;/script&gt;
      &lt;/head&gt;
    </pre>
  </div>

<h4 id="sec-implementation-notes-for-session-history"><dfn lt="doesn't necessarily have to affect|Implementation notes for session history">Implementation notes for session history</dfn></h4>

  <em>This section is non-normative</em>.

  The {{History}} interface is not meant to place restrictions on how implementations represent the
  session history to the user.

  For example, session history could be implemented in a tree-like manner, with each page having
  multiple "forward" pages. This specification doesn't define how the linear list of pages in the
  {{Window/history}} object are derived from the actual session history as seen from the user's
  perspective.

  Similarly, a page containing two <{iframe}>s has a {{Window/history}} object distinct from the
  <{iframe}>s' {{Window/history}} objects, despite the fact that typical Web browsers present the
  user with just one "Back" button, with a session history that interleaves the navigation of the
  two inner frames and the outer page.

  <em>Security<em>: It is suggested that to avoid letting a page "hijack" the history navigation
  facilities of a UA by abusing {{History/pushState()}}, the UA provide the user with a way to jump
  back to the previous page (rather than just going back to the previous state). For example, the
  back button could have a drop down showing just the pages in the session history, and not showing
  any of the states. Similarly, an aural browser could have two "back" commands, one that goes back
  to the previous state, and one that jumps straight back to the previous page.

  For both {{History/pushState()}} and {{History/replaceState()}}, user agents are encouraged to
  prevent abuse of these APIs via too-frequent calls or over-large state objects. As detailed above,
  the algorithm explicitly allows user agents to ignore any such calls when appropriate.

<h4 id="the-location-interface">The <code>Location</code> interface</h4>

  Each {{Window}} object is associated with a unique instance of a {{Location}} object, allocated
  when the {{Window}} object is created.

  To create a {{Location}} object, run these steps:

  1. Let <var>location</var> be a new {{Location}} <a>platform object</a>.
  2. Perform ! <var>location</var>.\[[DefineOwnProperty]]("<code>toString</code>", {
      \[[Value]]: <a>%ObjProto_toString%</a>, \[[Writable]]: false, \[[Enumerable]]: false,
      \[[Configurable]]: false }).
  3. Perform ! <var>location</var>.\[[DefineOwnProperty]]("<code>toJSON</code>", {
      \[[Value]]: undefined, \[[Writable]]: false, \[[Enumerable]]: false,
      \[[Configurable]]: false }).
  4. Perform ! <var>location</var>.\[[DefineOwnProperty]]("<code>valueOf</code>", {
      \[[Value]]: <a>%ObjProto_valueOf%</a>, \[[Writable]]: false, \[[Enumerable]]: false,
      \[[Configurable]]: false }).
  5. Perform ! <var>location</var>.\[[DefineOwnProperty]](<a>@@toPrimitive</a>, {
      \[[Value]]: undefined, \[[Writable]]: false, \[[Enumerable]]: false,
      \[[Configurable]]: false }).
  6. Set the value of the [[<a>DefaultProperties</a>]] internal slot of <var>location</var> to
      <var>location</var>.\[[OwnPropertyKeys]]().
  7. Return <var>location</var>.

  <dl class="domintro">
    <dt><var>document</var> . {{Document/location}} [ = <var>value</var> ]</dt>
    <dt><var>window</var> . {{Window/location}} [ = <var>value</var> ]</dt>
    <dd>Returns a {{Location}} object with the current page's location.

    Can be set, to navigate to another page.
    </dd>
  </dl>

  The <dfn attribute for="Document"><code>location</code></dfn> attribute of the {{Document}}
  interface must return the {{Location}} object for that {{Document}} object's <a>global object</a>,
  if it has a <a>browsing context</a>, and null otherwise.

  The <dfn attribute for="Window"><code>location</code></dfn> attribute of the {{Window}} interface
  must return the {{Location}} object for that {{Window}} object.

  {{Location}} objects provide a representation of the <a for="url">URL</a> of the
  <a>active document</a> of their {{Document}}'s <a>browsing context</a>, and allow the
  <a>current entry</a> of the <a>browsing context</a>'s session history to be changed, by adding or
  replacing entries in the {{Window/history}} object.

  <pre class="idl" data-highlight="webidl" dfn-for="Location">
    [Unforgeable]
    interface Location {
      stringifier attribute USVString href;
      readonly attribute USVString origin;
      attribute USVString protocol;
      attribute USVString host;
      attribute USVString hostname;
      attribute USVString port;
      attribute USVString pathname;
      attribute USVString search;
      attribute USVString hash;

      void assign(USVString url);
      void replace(USVString url);
      void reload();

      [SameObject] readonly attribute USVString[] ancestorOrigins;
    };
  </pre>

  <dl class="domintro">
    <dt><var>location</var> . <code>toString()</code></dt>
    <dt><var>location</var> . {{Location/href}}</dt>
    <dd>Returns the {{Location}} object's URL.

    Can be set, to navigate to the given URL.
    </dd>

    <dt><var>location</var> . {{Location/origin}}</dt>
    <dd>Returns the {{Location}} object's URL's origin.</dd>

    <dt><var>location</var> . {{Location/protocol}}</dt>
    <dd>Returns the {{Location}} object's URL's scheme.

    Can be set, to navigate to the same URL with a changed scheme.
    </dd>

    <dt><var>location</var> . {{Location/host}}</dt>
    <dd>Returns the {{Location}} object's URL's host and port (if different from the default port
    for the scheme).

    Can be set, to navigate to the same URL with a changed host and port.
    </dd>

    <dt><var>location</var> . {{Location/hostname}}</dt>
    <dd>Returns the {{Location}} object's URL's host.

    Can be set, to navigate to the same URL with a changed host.
    </dd>

    <dt><var>location</var> . {{Location/port}}</dt>
    <dd>Returns the {{Location}} object's URL's port.

    Can be set, to navigate to the same URL with a changed port.
    </dd>

    <dt><var>location</var> . {{Location/pathname}}</dt>
    <dd>Returns the {{Location}} object's URL's path.

    Can be set, to navigate to the same URL with a changed path.
    </dd>

    <dt><var>location</var> . {{Location/search}}</dt>
    <dd>Returns the {{Location}} object's URL's query (includes leading "<code>?</code>" if
    non-empty).

    Can be set, to navigate to the same URL with a changed query (ignores leading "<code>?</code>").
    </dd>

    <dt><var>location</var> . {{Location/hash}}</dt>
    <dd>Returns the {{Location}} object's URL's fragment (includes leading "<code>#</code>" if
    non-empty).

    Can be set, to navigate to the same URL with a changed fragment (ignores leading
    "<code>#</code>").
    </dd>

    <dt><var>location</var> . {{Location/assign(<var>url</var>)}}</dt>
    <dd>Navigates to the given URL.</dd>

    <dt><var>location</var> . {{Location/replace(<var>url</var>)}}</dt>
    <dd>Removes the current page from the session history and navigates to the given URL.</dd>

    <dt><var>location</var> . {{Location/reload()}}</dt>
    <dd>Reloads the current page.</dd>

    <dt><var>location</var> . {{Location/ancestorOrigins}}</dt>
    <dd>Returns an array whose values are the origins of the ancestor <a>browsing contexts</a>, from
    the <a>parent browsing context</a> to the <a>top-level browsing context</a>.</dd>
  </dl>

  A {{Location}} object has an associated <dfn>relevant <code>Document</code></dfn>, which is this
  {{Location}} object's associated {{Document}} object's <a>browsing context</a>'s
  <a>active document</a>.

  A {{Location}} object has an associated <dfn for="Location">url</dfn>, which is this {{Location}}
  object's <a>relevant <code>Document</code></a>'s <a lt="document url">URL</a>.

  A {{Location}} object has an associated <dfn>ancestor origins array</dfn>. When a {{Location}}
  object is created, its <a>ancestor origins array</a> must be set to a array created from the list
  of strings that the following steps would produce:

  1. Let <var>output</var> be an empty ordered list of strings.
  2. Let <var>current</var> be the <a>browsing context</a> of the {{Document}} with which the
      {{Location}} object is associated.
  3. <var>Loop</var>: If <var>current</var> has no <a>parent browsing context</a>, jump to
    the step labeled <var>End</var>.
  4. Let <var>current</var> be <var>current</var>'s <a>parent browsing context</a>.
  5. Append the <a>Unicode serialization</a> of <var>current</var>'s <a>active document</a>'s
      <a for="concept">origin</a> to <var>output</var> as a new value.
  6. Return to the step labeled <var>Loop</var>.
  7. <var>End</var>: Return <var>output</var>.

  A {{Location}} object has an associated <dfn><code>Location</code>-object-setter navigate</dfn>
  algorithm, which given a <var>url</var>, runs these steps:

  1. If any of the following conditions are met, let <var>replacement flag</var> be unset;
      otherwise, let it be set:

      * This {{Location}} object's <a>relevant <code>Document</code></a> has
         <a>completely loaded</a>, or
      * In the <a>task</a> in which the algorithm is running, an <a>activation behavior</a> is
         currently being processed whose <code>click</code> event was <a>trusted</a>, or
      * In the <a>task</a> in which the algorithm is running, the event listener for a
         <a>trusted</a> <code>click</code> event is being handled.
  2. <a><code>Location</code>-object navigate</a>, given <var>url</var> and
      <var>replacement flag</var>.

  To <dfn><code>Location</code>-object navigate</dfn>, given a <var>url</var> and
  <var>replacement flag</var>, run these steps:

  1. The <a>source browsing context</a> is the <a>responsible browsing context</a> specified by the
      <a>incumbent settings object</a>.
  2. <a>Navigate</a> the <a>browsing context</a> to <var>url</var>, with the
      <a>exceptions enabled flag</a> set. Rethrow any exceptions.

      If the <var>replacement flag</var> is set or the <a>browsing context</a>'s
      <a>session history</a> contains only one {{Document}}, and that was the
      <code>about:blank</code> {{Document}} created when the <a>browsing context</a> was created,
      then the navigation must be done with <a>replacement enabled</a>.

  The <dfn attribute for="Location"><code>href</code></dfn> attribute's getter must return this
  {{Location}} object's <a for="url">URL</a>, serialized.

  The <code>href</code> attribute's setter must run these steps:

  <ol>
    <li>Let <var>newURL</var> be the <a>resulting URL string</a> of <a>parsing</a> the given value relative to the <a>entry settings object</a>'s
    <a>API base URL</a>.</li>

    <li>If that aborted with an error, throw a <code>TypeError</code> exception.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>newURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>origin</code></dfn> attribute's getter must return
  the <a>Unicode serialization</a> of this
  {{Location}} object's <a for="url">URL</a>'s <a for="concept">origin</a>.

  <p class="note">It returns the Unicode rather than the ASCII serialization for
  compatibility with <code>MessageEvent</code>.

  The <dfn attribute for="Location"><code>protocol</code></dfn> attribute's getter must
  return this {{Location}} object's <a for="url">URL</a>'s <a for="url">scheme</a>, followed by "<code>:</code>".

  The {{Location/protocol}} attribute's setter must run these
  steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this {{Location}} object's <a for="url">URL</a>.</li>

    <li>Let <var>possibleFailure</var> be the result of <a lt="basic url parser">basic URL parsing</a> the given value, followed by "<code>:</code>", with <var>copyURL</var>
    as <var>url</var> and <a>scheme start state</a> as <var>state override</var>.</li>

    <li>If <var>possibleFailure</var> is failure, throw a <code>TypeError</code>
    exception.</li>

    <li>If <var>copyURL</var>'s <a for="url">scheme</a> is not "<code>http</code>" or "<code>https</code>", terminate these steps.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>host</code></dfn> attribute's getter must run these
  steps:

  <ol>
    <li>Let <var>url</var> be this {{Location}} object's <a for="url">URL</a>.</li>

    <li>If <var>url</var>'s <a for="url">host</a> is null, return the empty
    string.</li>

    <li>If <var>url</var>'s <a for="url">port</a> is null, return
    <var>url</var>'s <a for="url">host</a>, serialized.</li>

    <li>Return <var>url</var>'s <a for="url">host</a>, serialized, followed by "<code>:</code>" and <var>url</var>'s <a for="url">port</a>, serialized.</li>
  </ol>

  The <code>host</code> attribute's setter must run these steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this {{Location}} object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a>non-relative flag</a> is set, terminate these
    steps.</li>

    <li><a lt="basic url parser">Basic URL parse</a> the given value, with
    <var>copyURL</var> as <var>url</var> and <a>host state</a> as <var>state
    override</var>.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>hostname</code></dfn> attribute's getter must
  run these steps:

  <ol>
    <li>If this {{Location}} object's <a for="url">URL</a>'s
    <a for="url">host</a> is null, return the empty string.</li>

    <li>Return this {{Location}} object's <a for="url">URL</a>'s <a for="url">host</a>, serialized.</li>
  </ol>

  The <code>hostname</code> attribute's setter must run these
  steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this {{Location}} object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a>non-relative flag</a> is set, terminate these
    steps.</li>

    <li><a lt="url parser">Basic URL parse</a> the given value, with
    <var>copyURL</var> as <var>url</var> and <a>hostname state</a> as <var>state
    override</var>.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>port</code></dfn> attribute's getter must run these
  steps:

  <ol>
    <li>If this {{Location}} object's <a for="url">URL</a>'s
    <a for="url">port</a> is null, return the empty string.</li>

    <li>Return this {{Location}} object's <a for="url">URL</a>'s <a for="url">port</a>, serialized.</li>
  </ol>

  The <code>port</code> attribute's setter must run these steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this {{Location}} object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a for="url">host</a> is null,
    <var>copyURL</var>'s <a>non-relative flag</a> is set, or <var>copyURL</var>'s <a for="url">scheme</a> is "<code>file</code>", terminate these
    steps.</li>

    <li><a lt="url parser">Basic URL parse</a> the given value, with
    <var>copyURL</var> as <var>url</var> and <a>port state</a> as <var>state
    override</var>.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>pathname</code></dfn> attribute's getter must
  run these steps:

  <ol>
    <li>Let <var>url</var> be this {{Location}} object's <a for="url">URL</a>.</li>

    <li>If <var>url</var>'s <a>non-relative flag</a> is set, return the first string in
    <var>url</var>'s <a>path</a>.</li>

    <li>Return "<code>/</code>", followed by the strings in <var>url</var>'s <a>path</a> (including empty strings), separated from each other by
    "<code>/</code>".</li>
  </ol>

  The <code>pathname</code> attribute's setter must run these
  steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this {{Location}} object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a>non-relative flag</a> is set, terminate these
    steps.</li>

    <li>Set <var>copyURL</var>'s <a>path</a> to the empty
    list.</li>

    <li><a lt="url parser">Basic URL parse</a> the given value, with
    <var>copyURL</var> as <var>url</var> and <a>path start state</a> as <var>state
    override</var>.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>search</code></dfn> attribute's getter must run
  these steps:

  <ol>
    <li>If this {{Location}} object's <a for="url">URL</a>'s
    <a for="url">query</a> is either null or the empty string, return the
    empty string.</li>

    <li>Return "<code>?</code>", followed by this {{Location}} object's <a for="url">URL</a>'s <a for="url">query</a>.</li>
  </ol>

  The <code>search</code> attribute's setter must run these
  steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this {{Location}} object's <a for="url">URL</a>.</li>

    <li>If the given value is the empty string, set <var>copyURL</var>'s <a for="url">query</a> to null.

    <li>
    Otherwise, run these substeps:

    <ol>
      <li>Let <var>input</var> be the given value with a single leading "<code>?</code>"
      removed, if any.</li>

      <li>Set <var>copyURL</var>'s <a for="url">query</a> to the empty
      string.</li>

      <li><a lt="url parser">Basic URL parse</a> <var>input</var>, with
      <var>copyURL</var> as <var>url</var> and <a>query state</a> as <var>state override</var>,
      and the <a>relevant <code>Document</code></a>'s <a>document's character
      encoding</a> as <var>encoding override</var>.</li>
    </ol>
    </li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>hash</code></dfn> attribute's getter must run these
  steps:

  <ol>
    <li>If this {{Location}} object's <a for="url">URL</a>'s
    <a for="url">fragment</a> is either null or the empty string, return
    the empty string.</li>

    <li>Return "<code>#</code>", followed by this {{Location}} object's <a for="url">URL</a>'s <a for="url">fragment</a>.</li>
  </ol>

  The <code>hash</code> attribute's setter must run these steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this {{Location}} object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a for="url">scheme</a> is "<code>javascript</code>", terminate these steps.</li>

    <li>If the given value is the empty string, set <var>copyURL</var>'s <a for="url">fragment</a> to null.

    <li>
    Otherwise, run these substeps:

    <ol>
      <li>Let <var>input</var> be the given value with a single leading "<code>#</code>"
      removed, if any.</li>

      <li>Set <var>copyURL</var>'s <a for="url">fragment</a> to the
      empty string.</li>

      <li><a lt="url parser">Basic URL parse</a> <var>input</var>, with
      <var>copyURL</var> as <var>url</var> and <a>fragment state</a> as <var>state
      override</var>.</li>
    </ol>
    </li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  <hr />

  When the <dfn method for="Location" lt="assign()|assign(url)"><code>assign(<var>url</var>)</code></dfn>
  method is invoked, the user agent must run the following steps:

  <ol>

    <li>

    <a>Parse</a> <var>url</var>, relative to the
    <a>API base URL</a> specified by the <a>entry settings object</a> and let
    <var>parsedURL</var> be the <a>resulting URL string</a>.

    If this is not successful, throw a "{{SyntaxError}}" {{DOMException}} and abort these
    steps.

    </li>

    <li><a><code>Location</code>-object navigate</a> to <var>parsedURL</var>.</li>

  </ol>

  When the <dfn method for="Location" lt="replace()|replace(url)"><code>replace(<var>url</var>)</code></dfn>
  method is invoked, the user agent must run the following steps:

  <ol>

    <li>

    <a>Parse</a> <var>url</var>, relative to the
    <a>API base URL</a> specified by the <a>entry settings object</a> and let
    <var>parsedURL</var> be the <a>resulting URL string</a>.

    If this is not successful, throw a "{{SyntaxError}}" {{DOMException}} and abort these
    steps.

    </li>

    <li><a><code>Location</code>-object navigate</a> to <var>parsedURL</var> with the
    <var>replacement flag</var> set.</li>

  </ol>

  When the <dfn method for="Location"><code>reload()</code></dfn> method is invoked, the
  user agent must run the appropriate steps from the following list:

  <dl class="switch">

    <dt>If the currently executing <a>task</a> is the dispatch of a <code>resize</code> event in response to the user resizing the <a>browsing
    context</a></dt>

    <dd>Repaint the <a>browsing context</a> and abort these steps.</dd>

    <dt>If the <a>browsing context</a>'s <a>active document</a> is <a lt="iframe srcdoc document">an
    <code>iframe</code> <code>srcdoc</code> document</a></dt>

    <dd><a>Reprocess the <code>iframe</code>
    attributes</a> of the <a>browsing context</a>'s <a>browsing context
    container</a>.</dd>

    <dt>If the <a>browsing context</a>'s <a>active document</a> has its <a>reload
    override flag</a> set</dt>

    <dd>Perform <a>an overridden reload</a>, with the <a>browsing context</a> being
    navigated as the <a>responsible browsing context</a>.</dd>

    <dt>Otherwise</dt>

    <dd><a>Navigate</a> the <a>browsing context</a> to the document's <a lt="document url">URL</a>
    with the <a>exceptions enabled flag</a> set and <a>replacement enabled</a>.
    The <a>source browsing context</a> must be the <a>browsing context</a> being navigated. This is
    a <a>reload-triggered navigation</a>. Rethrow any exceptions.</dd>

  </dl>

  When a user requests that the <a>active document</a> of a <a>browsing context</a>
  be reloaded through a user interface element, the user agent should <a>navigate</a> the <a>browsing context</a> to the same resource as that
  {{Document}}, with <a>replacement enabled</a>. In the case of non-idempotent
  methods (e.g., HTTP POST), the user agent should prompt the user to confirm the operation first,
  since otherwise transactions (e.g., purchases or database modifications) could be repeated. User
  agents may allow the user to explicitly override any caches when reloading. If <a>browsing
  context</a>'s <a>active document</a>'s <a>reload override flag</a> is set, then the
  user agent may instead perform <a>an overridden reload</a> rather than the navigation
  described in this paragraph (with the <a>browsing context</a> being reloaded as the
  <a>source browsing context</a>).

  The <dfn attribute for="Location"><code>ancestorOrigins</code></dfn> attribute's getter must run
  these steps:

  1. If this {{Location}} object's <a>relevant <code>Document</code></a>'s
      <a for="concept">origin</a> is not <a>same origin-domain</a> with the
      <a>entry settings object</a>'s <a for="concept">origin</a>, then throw a
      "{{SecurityError}}" {{DOMException}}.
  2. Otherwise, return this {{Location}} object's <a>ancestor origins array</a>.

  The {{Location}} object requires additional logic beyond IDL for security purposes. The internal
  slot and internal methods {{Location}} objects must implement are defined below.

  Every {{Location}} object has a [[<dfn>DefaultProperties</dfn>]] internal slot representing its
  own properties at time of its creation.



<h3 id="browsing-the-web">Browsing the Web</h3>

  <div class="impl">

<h4 id="navigating-across-documents">Navigating across documents</h4>

  Certain actions cause the <a>browsing context</a> to <i>navigate</i> to
  a new resource. A user agent may provide various ways for the user to explicitly cause a browsing
  context to navigate, in addition to those defined in this specification.

  <p class="example">
  For example, <a>following a hyperlink</a>,
  [[#forms-form-submission]], and the <code>window.open()</code> and <code>location.assign()</code> methods can all cause a browsing context to
  navigate.
  </p>

  <p class="note">
  A <i>resource</i> has a URL, but that might not be the only information necessary
  to identify it. For example, a <a>form submission</a> that uses HTTP POST would also have the HTTP method
  and payload. Similarly, <a lt="iframe srcdoc document">an <code>iframe</code> <code>srcdoc</code> document</a> needs to know the data it is to use.
  </p>

  Navigation always involves <dfn>source browsing context</dfn>, which is the browsing context which
  was responsible for starting the navigation.

  When a browsing context is <dfn lt="navigated|navigate|navigation|navigating|navigation algorithm|navigating a browsing context|processing model for navigating across documents">navigated</dfn> to a new resource, the user
  agent must run the following steps:

  <ol>

    <li>

    If the <a>source browsing context</a> is not <a>allowed to navigate</a> the
    <a>browsing context</a> being navigated, then abort these steps.

    If these steps are aborted here, the user agent may instead offer to open the new resource in
    a new <a>top-level browsing context</a> or in the <a>top-level browsing context</a>
    of the <a>source browsing context</a>, at the user's option, in which case the user agent
    must <a>navigate</a> that designated <a>top-level
    browsing context</a> to the new resource as if the user had requested it independently.

    <p class="note">
  Doing so, however, can be dangerous, as it means that the user is overriding the
    author's explicit request to sandbox the content.
  </p>

    If the <a>navigate</a> algorithm was invoked optionally with an
    <dfn>exceptions enabled flag</dfn>, and it
    is aborted on this step, then in addition to aborting this algorithm, the user agent must also
    throw a "{{SecurityError}}" {{DOMException}}.

    </li>

    <li>If there is a preexisting attempt to navigate the <a>browsing context</a>, and the
    <a>source browsing context</a> is the same as the <a>browsing context</a> being
    navigated, and that attempt is currently running the <a>unload a document</a> algorithm,
    and the <a for="concept">origin</a> of the <a for="url">URL</a> of the resource being loaded in
    that navigation is not the <a>same origin</a> as the <a for="concept">origin</a> of the
    <a for="url">URL</a> of the resource being loaded in <em>this</em> navigation, then abort these
    steps without affecting the preexisting attempt to navigate the <a>browsing context</a>.</li>

    <li>If a <a>task</a> queued by the <a>traverse the history by a
    delta</a> algorithm is running the <a>unload a document</a> algorithm for the
    <a>active document</a> of the <a>browsing context</a> being navigated, then abort
    these steps without affecting the <a>unload a document</a> algorithm or the aforementioned
    history traversal task.</li>

    <li>If the <a>prompt to unload a document</a> algorithm is being run for the
    <a>active document</a> of the <a>browsing context</a> being navigated, then abort
    these steps without affecting the <a>prompt to unload a document</a> algorithm.</li>

    <li>

    Let <var>gone async</var> be false.

    <p class="note">
  The <i>handle redirects</i> step later in
    this algorithm can in certain cases jump back to the step labeled <a><i>fragment identifiers</i></a>. Since, between those two steps,
    this algorithm goes from operating immediately in the context of the calling <a>task</a> to operating <a>in parallel</a> independent of the <a>event loop</a>, some of the intervening steps need to be able to handle both being run as part of a <a>task</a> and
    running <a>in parallel</a>. The <var>gone async</var> flag is thus used to make these steps
    aware of which mode they are operating in.
  </p>

    </li>

    <li><dfn lt="the step labeled fragment identifiers"></dfn><i>Fragment identifiers</i>: If this is not a
    <dfn>reload-triggered navigation</dfn>: apply the <a>URL parser</a> algorithm to the
    <a>absolute URL</a> of the new resource and the <a>address</a> of the <a>active document</a> of the <a>browsing context</a>
    being navigated; if all the components of the resulting <a>parsed
    URLs</a>, ignoring any <a for="url">fragment</a> components, are
    identical, and the new resource is to be fetched using <code>GET</code>, and the
    <a>URL record</a> of the new resource has a <a for="url">fragment</a> component that is not null (even if it is empty),
    then <a lt="fragment identifier">navigate to that fragment identifier</a> and abort these
    steps.</li>

    <li>If <var>gone async</var> is false, cancel any preexisting but not yet <a>mature</a> attempt to navigate the <a>browsing
    context</a>, including canceling any instances of the <a>fetch</a> algorithm started by those attempts. If one of those attempts
    has already created and initialized a new {{Document}} object, <a>abort</a> that
    {{Document}} also. (Navigation attempts that have <a>matured</a> already have session history entries, and are
    therefore handled during the <a>update the session history with the new page</a> algorithm,
    later.)</li>

    <li>If the new resource is to be handled using a mechanism that does not affect the browsing
    context, e.g., ignoring the navigation request altogether because the specified scheme is not one
    of the supported protocols, then abort these steps and <a>proceed with that mechanism instead</a>.</li>

    <li>

    If <var>gone async</var> is false, <a>prompt
    to unload</a> the {{Document}} object. If the user <a>refused to allow the
    document to be unloaded</a>, then abort these steps.

    If this instance of the <a>navigation</a> algorithm gets canceled
    while this step is running, the <a>prompt to unload a document</a> algorithm must
    nonetheless be run to completion.

    </li>

    <li>If <var>gone async</var> is false, <a>abort</a>
    the <a>active document</a> of the <a>browsing context</a>.</li>

    <li>

    If the new resource is to be handled by displaying some sort of inline content, e.g., an error
    message because the specified scheme is not one of the supported protocols, or an inline prompt
    to allow the user to select <a>a registered
    handler</a> for the given scheme, then <a>display the inline
    content</a> and abort these steps.

    <p class="note">
    In the case of a registered handler being used, the algorithm will be reinvoked
    with a new URL to handle the request.
    </p>

    </li>

    <li>

    If the <a>browsing context</a> being navigated is a <a>nested browsing context</a>, then put it in the <a>delaying <code>load</code> events
    mode</a>.

    The user agent must take this <a>nested browsing context</a> out of the <a>delaying
    <code>load</code> events mode</a> when this <a>navigation</a> algorithm later matures, or when it terminates (whether due to having
    run all the steps, or being canceled, or being aborted), whichever happens first.

    </li>

    <li>

    This is the step that attempts to obtain the resource, if necessary. Jump to the first
    appropriate substep:

    <dl>

      <dt>If the resource has already been obtained (e.g., because it is being used to populate an
      <{object}> element's new <a>child browsing context</a>)</dt>

      <dd>Skip this step. The data is already available.</dd>

      <dt>If the new resource is a <a for="url">URL</a> whose <a for="url">scheme</a> is <code>javascript</code></dt>

      <dd>

      <a>Queue a task</a> to run
      <dfn lt="javascript: urls|javascript: url|dereferencing a javascript: url">these "<code>javascript:</code> URL" steps</dfn>,
      associated with the <a>active document</a> of the <a>browsing context</a> being navigated:

      1. If the <a for="concept">origin</a> of the <a>source browsing context</a> is not the <a>same origin</a> as
          the <a for="concept">origin</a> of the <a>active document</a> of the <a>browsing context</a> being
          navigated, then let <var>result</var> be undefined, and jump to the step labeled
          <i>process results</i> below.
      2. Let <var>urlRecord</var> be the result of running the <a>URL parser</a> on the
          <a for="url">URL</a> of the new resource.
      3. Let <var>script source</var> be the empty string.
      4. Append the first string of <var>urlRecord</var>'s <a>path</a> component to <var>script
          source</var>.
      5. If <var>urlRecord</var>'s <a for="url">query</a> component is not null, then first
          append a U+003F QUESTION MARK character (?) to <var>script source</var>, and then append
          <var>urlRecord</var>'s <a for="url">query</a> component to <var>script source</var>.
      6. If <var>urlRecord</var>'s <a for="url">fragment</a> component is not null, then first
          append a U+0023 NUMBER SIGN character (#) to <var>script source</var>, and then append
          <var>urlRecord</var>'s <a for="url">fragment</a> component to <var>script
          source</var>.
      7. Replace <var>script source</var> with the result of applying the
          <a>percent decode</a> algorithm to <var>script source</var>.
      8. Replace <var>script source</var> with the result of applying the <a>UTF-8 decode</a>
          algorithm to <var>script source</var>.
      9. Let <var>address</var> be the <a>address</a> of the <a>active document</a> of the
          <a>browsing context</a> being navigated.
      10. Let <var>settings</var> be the <a>relevant settings object</a> of the <a>browsing
           context</a> being navigated.
      11. Let <var>script</var> be the result of <a>creating a classic script</a> given
           <var>script source</var> and <var>settings</var>.
      12. Let <var>result</var> be the result of <a>running the classic script</a>
           <var>script</var>. If evaluation was unsuccessful, let <var>result</var> be undefined
           instead. (The result will also be undefined if <a>scripting is disabled</a>.)
      13. <em>Process results</em>: If <a for="ecma">Type</a>(<var>result</var>) is not
           <code>String</code>, then the result of obtaining the resource for the URL is a
           <a>response</a> whose <a>status</a> is <code>204</code>.

           Otherwise, the result of obtaining the resource for the URL is a <a>response</a> whose
           <a for="response">header list</a> consists of
           <code>Content-Type</code>/<a href="#text-html"><code>text/html</code></a> and whose
           <a for="response">body</a> is <var>result</var>, and whose
           <a for="response">HTTPS state</a> is <var>settings</var>'s
           <a for="settings">HTTPS state</a>.

           When it comes time to <a>set the document's address</a> in the
           <a>navigation algorithm</a>, use <var>address</var> as the <a>override URL</a>.

      The <a>task source</a> for this <a>task</a> is the
      <a>DOM manipulation task source</a>.

      <div class="example">
        So for example a <a><code>javascript:</code> URL</a> in
        an <{links/href}> attribute of an <{a}> element
        would only be evaluated when the link was followed, while such a URL in the <code>src</code> attribute of an <{iframe}> element would be
        evaluated in the context of the <code>iframe</code>'s own <a>nested browsing context</a> when the <code>iframe</code> is being set up; once evaluated, its return value
        (if it was not void) would replace that <a>browsing context</a>'s {{Document}}, thus also
        changing the <code>Window</code> object of that <a>browsing context</a>.
      </div>

      </dd>

      <dt>Otherwise</dt>

      <dd>

      <ol>
        <li>Let <var>request</var> be the new resource.</li>

        <li>If <var>request</var> is a URL, set <var>request</var> to a new <a>request</a> whose <a for="url">URL</a>
        is <var>request</var>.</li>

        <li>Set <var>request</var>'s <a>client</a> to the
        <a>source browsing context</a>'s <a>active document</a>'s <code>Window</code>
        object's <a>environment settings object</a>, <a>target browsing context</a> to the
        <a>browsing context</a> being navigated, <a>destination</a> to "<code>document</code>",
        mode to "<code>navigate</code>", <a>credentials mode</a> to "<code>include</code>", <a>use-URL-credentials flag</a>, and <a>redirect mode</a> to "<code>manual</code>".</li>

        <li>Set <var>request</var>'s <a>omit-<code>Origin</code>-header flag</a>.

        <li>If <var>request</var>'s <a for="request">method</a> is not
        <code>GET</code>, or, if the <a>navigation algorithm</a>
        was invoked as a result of the <a>form submission
        algorithm</a>, then if there is an <a for="concept">origin</a> of the <a>active document</a>
        of the <a>source browsing context</a>, unset <var>request</var>'s
        <a>omit-<code>Origin</code>-header flag</a>.</li>

        <li>Otherwise, if the <a>browsing context</a> being navigated is a <a>child
        browsing context</a>, and the <a>browsing context container</a> of the
        <a>browsing context</a> being navigated has a <a>browsing context scope
        origin</a>, set <var>request</var>'s <a for="request">origin</a>
        to that <a>browsing context scope origin</a> and unset <var>request</var>'s
        <a>omit-<code>Origin</code>-header flag</a>.</li>

        <li><a>Fetch</a> <var>request</var>.</li>
      </ol>

      </dd>

    </dl>

    </li>

    <li>

    If <var>gone async</var> is false, return to whatever algorithm invoked the
    navigation steps and continue running these steps <a>in parallel</a>.

    </li>

    <li>Let <var>gone async</var> be true.</li>

    <li>Wait for one or more bytes to be available or for the user agent to establish that the
    resource in question is empty. During this time, the user agent may allow the user to cancel this
    navigation attempt or start other navigation attempts.</li>

    <li>

    <i>Handle redirects</i>: If fetching the resource results in a redirect, and either the
    <a for="url">URL</a> of the target of the redirect has the <a>same origin</a> as the original
    resource, or the resource is being obtained using the POST method or a safe method (in HTTP
    terms), return to <a>the step labeled <i>fragment
    identifiers</i></a> with the new resource, except that if the <a for="url">URL</a> of the target of
    the redirect does not have a fragment identifier and the <a for="url">URL</a> of the resource that
    led to the redirect does, then the fragment identifier of the resource that led to the redirect
    must be propagated to the <a for="url">URL</a> of the target of the redirect.

    <p class="example">
  So for instance, if the original URL was "<code>https://example.com/#!sample</code>" and "<code>https://example.com/</code>" is
    found to redirect to "<code>https://example.com/</code>", the URL of the new resource
    will be "<code>https://example.com/#!sample</code>".
  </p>

    Otherwise, if fetching the resource results in a redirect but the <a for="url">URL</a> of the
    target of the redirect does not have the <a>same origin</a> as the original resource and
    the resource is being obtained using a method that is neither the POST method nor a safe method
    (in HTTP terms), then abort these steps. The user agent may indicate to the user that the
    navigation has been aborted for security reasons.

    </li>

    <li>

    <i>Resource handling</i>: If the resource's out-of-band metadata (e.g., HTTP headers), not
    counting any <a>type information</a> (such as the Content-Type HTTP
    header), requires some sort of processing that will not affect the browsing context, then
    perform that processing and abort these steps.

    <div class="note">
      Such processing might be triggered by, amongst other things, the following:
      <ul class="brief">
      <li>HTTP status codes (e.g., 204 No Content or 205 Reset Content)</li>
      <li>Network errors (e.g., the network interface being unavailable)</li>
      <li>Cryptographic protocol failures (e.g., an incorrect TLS certificate)</li>

      </ul>
    </div>

    Responses with HTTP <code>Content-Disposition</code>
    headers specifying the <code>attachment</code> disposition type must be handled
    <a>as a download</a>.

    HTTP 401 responses that do not include a challenge recognized by the user agent must be
    processed as if they had no challenge, e.g., rendering the entity body as if the response had
    been 200 OK.

    User agents may show the entity body of an HTTP 401 response even when the response does
    include a recognized challenge, with the option to login being included in a non-modal fashion,
    to enable the information provided by the server to be used by the user before authenticating.
    Similarly, user agents should allow the user to authenticate (in a non-modal fashion) against
    authentication challenges included in other responses such as HTTP 200 OK responses, effectively
    allowing resources to present HTTP login forms without requiring their use.

    </li>

    <li>Let <var>type</var> be the computed type of the resource.</li>

    <li>If the user agent has been configured to process resources of the given <var>type</var> using some mechanism other than rendering the content in a <a>browsing
    context</a>, then skip this step. Otherwise, if the <var>type</var> is one of the
    following types, jump to the appropriate entry in the following list, and process the resource as
    described there:

    <dl class="switch">

      <dt>an <a>HTML MIME type</a></dt>
      <dd>Follow the steps given in the <a>HTML document</a> section,
      and then, once they have completed, abort this <a>navigate</a> algorithm.</dd>

      <dt>an <a>XML MIME type</a> that is not an <a>explicitly supported XML
      type</a></dt>

      <dd>Follow the steps given in the <a>XML document</a> section. If
      that section determines that the content is <em>not</em> to be displayed as a generic XML
      document, then proceed to the next step in this overall set of steps. Otherwise, once the steps
      given in the <a>XML document</a> section have completed, abort this
      <a>navigate</a> algorithm.</dd>

      <dt>a <a>JavaScript MIME type</a></dt>
      <dt>a <a>JSON MIME type</a> that is not an <a>explicitly supported JSON type</a></dt>
      <dt>"<code>text/css</code>"</dt>
      <dt>"<code>text/plain</code>"</dt>
      <dt>"<code>text/vtt</code>"</dt>
      <dd>Follow the steps given in the <a>plain text file</a> section,
      and then, once they have completed, abort this <a>navigate</a> algorithm.</dd>

      <dt>"<code>multipart/x-mixed-replace</code>"</dt>
      <dd>Follow the steps given in the [[#multipart-x-mixed-replace]] section, and then,
      once they have completed, abort this <a>navigate</a> algorithm.</dd>

      <dt>A supported image, video, or audio type</dt>
      <dd>Follow the steps given in the <a>media</a> section, and then,
      once they have completed, abort this <a>navigate</a> algorithm.</dd>

      <dt>A type that will use an external application to render the content in the <a>browsing
      context</a></dt>
      <dd>Follow the steps given in the <a>plugin</a> section, and then,
      once they have completed, abort this <a>navigate</a> algorithm.</dd>

    </dl>

    An <dfn>explicitly supported XML type</dfn> is one for which the user agent is configured to
    use an external application to render the content (either a <a>plugin</a> rendering
    directly in the <a>browsing context</a>, or a separate application), or one for which the
    user agent has dedicated processing rules (e.g., a Web browser with a built-in Atom feed viewer
    would be said to explicitly support the <code>application/atom+xml</code> MIME type), or one for
    which the user agent has a dedicated handler (e.g., one registered using <code>registerContentHandler()</code>).

    The term <dfn>JSON MIME type</dfn> is used to refer to the <a>MIME
    types</a> <code>application/json</code>, <code>text/json</code>, and any <a>MIME
    type</a> whose subtype ends with the five characters "<code>+json</code>".

    An <dfn>explicitly supported JSON type</dfn> is one for which the user agent is configured to
    use an external application to render the content (either a <a>plugin</a> rendering
    directly in the <a>browsing context</a>, or a separate application), or one for which the
    user agent has dedicated processing rules, or one for which the user agent has a dedicated
    handler (e.g., one registered using <code>registerContentHandler()</code>).

    <dfn lt="set the document's address|setting the document's address">Setting the document's address</dfn>: If there is no
    <dfn>override URL</dfn>, then any {{Document}} created by these steps must have its
    <a>address</a> set to the <a for="url">URL</a> that was
    originally to be fetched, ignoring any other data that was used to obtain the resource. However,
    if there <em>is</em> an <a>override URL</a>, then any {{Document}} created by
    these steps must have its <a>address</a> set to that
    <a for="url">URL</a> instead.

    <p class="note">
    An <a>override URL</a> is set when <a>dereferencing a <code>javascript:</code> URL</a> and when
    performing <a>an overridden reload</a>.
    </p>

  <dfn>Initializing a new <code>Document</code> object</dfn>: when a {{Document}} is created as part
  of the above steps, the user agent will be required to additionally run the following algorithm
  after creating the new object:

  1. If <var>browsingContext</var>'s only entry in its <a>session history</a> is the
      <a scheme>about:blank</a> {{Document}} that was added when <var>browsingContext</var> was
      <a lt="create a new browsing context">created</a>, and navigation is occurring with
      <a>replacement enabled</a>, and that {{Document}} has the <a>same origin</a> as the new
      {{Document}}, then
      1. Let <var>window</var> be the {{Window}} object of that {{Document}}.
      2. Change the {{Window/document}} attribute of <var>window</var> to point to the new
          {{Document}}.
  2. Otherwise,
      1. Call the JavaScript <a>InitializeHostDefinedRealm</a>() abstract operation with the
          following customizations:

          * For the global object, create a new {{Window}} object <var>window</var>.
          * For the global <em>this<em> value, use <var>browsingContext</var>'s {{WindowProxy}}
             object.
          * Let <var>realm execution context</var> be the created
             <a>JavaScript execution context</a>.
          * Do not obtain any source texts for scripts.
      2. <a>Set up a browsing context environment settings object</a> with
          <var>realm execution context</var>, and let <var>settings object</var> be the result.
      3. Set <var>window</var>'s
          <a lt="document associated with a window">associated <code>Document</code></a> to the new
          {{Document}}.
  3. Set <var>browsingContext</var>'s {{WindowProxy}} object's [[Window]] internal slot value to
      <var>window</var>.
  4. Set the {{Document}}'s <a for="document">HTTPS state</a> to the
      <a for="response">HTTPS state</a> of the resource used to generate the document.
  5. Execute the <a>Initialize a <code>Document</code>'s CSP list</a> algorithm on the {{Document}}
      object and the resource used to generate the document. [[CSP3]]
  6. Set <a>the document's referrer</a> to the
      <em>address of the resource from which Request-URIs are obtained</em> as determined when the
      fetch algorithm obtained the resource, if that algorithm was used and determined such a value;
      otherwise, set it to the empty string.
  7. <a>Implement the sandboxing</a> for the {{Document}}.
  8. If the <a>active sandboxing flag set</a> of the {{Document}}'s <a>browsing context</a> or any
      of its <a>ancestor browsing contexts</a> (if any) have the
      <a>sandboxed fullscreen browsing context flag</a> set, then skip this step.

      If the {{Document}}'s <a>browsing context</a> has a <a>browsing context container</a> and
      either it is not an <{iframe}> element, or it does not have the <code>allowfullscreen</code>
      attribute specified, or its {{Document}} does not have the <a>fullscreen enabled flag</a> set,
      then also skip this step.

      Otherwise, set the {{Document}}'s <a>fullscreen enabled flag</a>.

    </li>

    <li>

    <i>Non-document content</i>: If, given <var>type</var>, the new resource is to be
    handled by displaying some sort of inline content, e.g., a native rendering of the content, an
    error message because the specified type is not supported, or an inline prompt to allow the user
    to select <a>a registered handler</a> for
    the given type, then <a>display the inline content</a>, and
    then abort these steps.

    <p class="note">
    In the case of a registered handler being used, the algorithm will be reinvoked
    with a new URL to handle the request.
    </p>

    </li>

    <li>Otherwise, the document's <var>type</var> is such that the resource will not
    affect the browsing context, e.g., because the resource is to be handed to an external application
    or because it is an unknown type that will be processed <a>as a download</a>. <a>Process the resource appropriately</a>.

  </ol>

  When a resource is handled by <dfn lt="proceed with that mechanism instead|passing its URL or data to an external software package|process the resource appropriately">passing its URL or data to an external software package</dfn> separate from the user agent (e.g., handing a <code>mailto:</code> URL to a mail client, or a Word document to a word
  processor), user agents should attempt to mitigate the risk that this is an attempt to exploit the
  target software, e.g., by prompting the user to confirm that the <a>source browsing
  context</a>'s <a>active document</a>'s <a for="concept">origin</a> is to be allowed to invoke the
  specified software. In particular, if the <a>navigate</a> algorithm, when it was invoked,
  was not <a>allowed to show a popup</a>, the user agent should not invoke the external
  software package without prior user confirmation.

  <p class="example">
  For example, there could be a vulnerability in the target software's URL
  handler which a hostile page would attempt to exploit by tricking a user into clicking a link.
  </p>

  <hr />

  Some of the sections below, to which the above algorithm defers in certain cases, require the
  user agent to <dfn lt="updating the session history with the new page|update the session history with the new page">update the session history with the new page</dfn>. When a user agent is
  required to do this, it must <a>queue a task</a> (associated with the {{Document}}
  object of the <a>current entry</a>, not the new one) to run the following steps:

  <ol>

    <li>

    <a>Unload</a> the {{Document}} object of the
    <a>current entry</a>, with the <var>recycle</var> parameter set to false.

    If this instance of the <a>navigation</a> algorithm is canceled while
    this step is running the <a>unload a document</a> algorithm, then the <a>unload a
    document</a> algorithm must be allowed to run to completion, but this instance of the <a>navigation</a> algorithm must not run beyond this step. (In particular, for
    instance, the cancelation of this algorithm does not abort any event dispatch or script
    execution occurring as part of unloading the document or its descendants.)

    </li>

    <li>

    <dl>

      <dt>If the navigation was initiated for <dfn>entry update</dfn> of an entry</dt>

      <dd>

      <ol>

        <li>Replace the {{Document}} of the entry being updated, and any other entries
        that referenced the same document as that entry, with the new {{Document}}.</li>

        <li><a>Traverse the history</a> to the new entry.</li>

      </ol>

      <p class="note">
  This can only happen if the entry being updated is not the <a>current
      entry</a>, and can never happen with <a>replacement enabled</a>. (It happens when the
      user tried to traverse to a session history entry that no longer had a {{Document}}
      object.)
  </p>

      </dd>

      <dt>Otherwise</dt>

      <dd>

      <ol>

        <li>

        Remove all the entries in the <a>browsing context</a>'s <a>session
        history</a> after the <a>current entry</a>. If the <a>current entry</a> is
        the last entry in the session history, then no entries are removed.

        <p class="note">
  This <a>doesn't necessarily have to affect</a> the
        user agent's user interface.
  </p>

        </li>

        <li>Append a new entry at the end of the <code>History</code> object representing the new
        resource and its {{Document}} object, related state, and the default <a>scroll
       restoration mode</a> of "<code>auto</code>".</li>

        <li><a>Traverse the history</a> to the new entry. If the navigation was initiated
        with <a>replacement enabled</a>, then the traversal must itself be initiated with
        <a>replacement enabled</a>.

        </li>

      </ol>

      </dd>

    </dl>

    </li>

    <li>The <a>navigation algorithm</a> has now <dfn>matured</dfn>.</li>

    <li><i>Fragment identifier loop</i>: <a>Spin the event loop</a> for a user-agent-defined
    amount of time, as desired by the user agent implementor. (This is intended to allow the user
    agent to optimize the user experience in the face of performance concerns.)</li>

    <li>If the {{Document}} object has no parser, or its parser has <a>stopped parsing</a>, or the user agent has reason to believe the user is no longer
    interested in scrolling to the fragment identifier, then abort these steps.</li>

    <li><a>Scroll to the fragment identifier</a> given in <a>the document's
    address</a>. If this fails to find <a>an
    indicated part of the document</a>, then return to the <i>fragment identifier loop</i>
    step.</li>

  </ol>

  The <a>task source</a> for this <a>task</a> is the
  <a>networking task source</a>.

<h4 id="page-load-processing-model-for-html-files">Page load processing model for HTML files</h4>

  When an HTML document is to be loaded in a <a>browsing context</a>, the user agent must
  <a>queue a task</a> to create a {{Document}} object, mark it as being an <a>HTML document</a>, set its <a>content type</a> to "<a href="#text-html"><code>text/html</code></a>",
  initialize the {{Document}} object, and finally create an <a>HTML
  parser</a> and associate it with the {{Document}}. Each <a>task</a> that the <a>networking task source</a> places on the
  <a>task queue</a> while fetching runs must then fill the parser's <a>input byte
  stream</a> with the fetched bytes and cause the <a>HTML parser</a> to perform the
  appropriate processing of the input stream.

  <p class="note">
  The <a>input byte stream</a> converts bytes into characters for use in the
  <a>tokenizer</a>. This process relies, in part, on character encoding
  information found in the real <a>Content-Type metadata</a> of the
  resource; the "computed type" is not used for this purpose.
  </p>

  When no more bytes are available, the user agent must <a>queue a task</a> for the parser
  to process the implied EOF character, which eventually causes a <code>load</code> event to be fired.

  After creating the {{Document}} object, but before any script execution, certainly
  before the parser <a lt="stops parsing">stops</a>, the user agent must <a>update the
  session history with the new page</a>.

  The <a>task source</a> for the two tasks mentioned in this section must be the
  <a>networking task source</a>.

<h4 id="page-load-processing-model-for-xml-files">Page load processing model for XML files</h4>

  When faced with displaying an XML file inline, user agents must follow the requirements defined
  in the XML and Namespaces in XML recommendations, RFC 7303, DOM, and other relevant specifications
  to create a {{Document}} object and a corresponding <a>XML parser</a>. [[!XML]] [[!XML-NAMES]] [[!RFC7303]] [[!DOM]]

  <p class="note">
  At the time of writing, the XML specification community had not actually yet
  specified how XML and the DOM interact.
  </p>

  After the {{Document}} is created, the user agent must initialize the
  {{Document}} object.

  The actual HTTP headers and other metadata, not the headers as mutated or implied by the
  algorithms given in this specification, are the ones that must be used when determining the
  character encoding according to the rules given in the above specifications. Once the character
  encoding is established, the <a>document's character encoding</a> must be set to that
  character encoding.

  User agents may examine the namespace of the root {{Element}} node of this
  {{Document}} object to perform namespace-based dispatch to alternative processing tools,
  e.g., determining that the content is actually a syndication feed and passing it to a feed handler.
  If such processing is to take place, abort the steps in this section, and jump to the next step (labeled <i>non-document content</i>) in the
  <a>navigate</a> steps above.

  Otherwise, then, with the newly created {{Document}}, the user agent must <a>update
  the session history with the new page</a>. User agents may do this before the complete document
  has been parsed (thus achieving <i>incremental rendering</i>), and must do this before any scripts
  are to be executed.

  Error messages from the parse process (e.g., XML namespace well-formedness errors) may be
  reported inline by mutating the {{Document}}.

<h4 id="page-load-processing-model-for-text-files"><dfn lt="plain text file">Page load processing model for text files</dfn></h4>

  When a plain text document is to be loaded in a <a>browsing context</a>, the user agent
  must <a>queue a task</a> to create a {{Document}} object, mark it as being an <a>HTML document</a>, set its <a>content type</a> to the <a>computed MIME type</a> of the
  resource (<var>type</var> in the <a>navigate</a> algorithm), initialize the
  {{Document}} object, create an <a>HTML parser</a>, associate it with the
  {{Document}}, act as if the tokenizer had emitted a start tag token with the tag name
  "pre" followed by a single U+000A LINE FEED (LF) character, and switch the <a>HTML parser</a>'s
  tokenizer to the [[#plaintext-state]]. Each <a>task</a> that
  the <a>networking task source</a> places on the <a>task queue</a> while fetching runs
  must then fill the parser's <a>input byte stream</a> with the fetched bytes and cause the
  <a>HTML parser</a> to perform the appropriate processing of the input stream.

  The rules for how to convert the bytes of the plain text document into actual characters, and
  the rules for actually rendering the text to the user, are defined by the specifications for the
  <a>computed MIME type</a> of the resource (<var>type</var> in the <a>navigate</a> algorithm).

  The <a>document's character encoding</a> must be set to the character encoding used to
  decode the document.

  When no more bytes are available, the user agent must <a>queue a task</a> for the parser
  to process the implied EOF character, which eventually causes a <code>load</code> event to be fired.

  After creating the {{Document}} object, but potentially before the page has finished
  parsing, the user agent must <a>update the session history with the new page</a>.

  User agents may add content to the <{head}> element of the {{Document}}, e.g.,
  to link to a style sheet, provide a script, give the document a <a element for="html"><code>title</code></a>, etc.

  <p class="note">
  In particular, if the user agent supports the <code>Format=Flowed</code>
  feature of RFC3676 then the user agent would need to apply extra styling to cause the text to
  wrap correctly and to handle the quoting feature. [[RFC3676]]
  </p>

  The <a>task source</a> for the two tasks mentioned in this section must be the
  <a>networking task source</a>.

<h4 id="page-load-processing-model-for-multipartx-mixed-replace-resources">Page load processing model for <code>multipart/x-mixed-replace</code> resources</h4>

  When a resource with the type <code>multipart/x-mixed-replace</code> is to be loaded in a
  <a>browsing context</a>, the user agent must parse the resource using the rules for
  multipart types. [[!RFC2046]]

  For each body part obtained from the resource, the user agent must run a new instance of the
  <a>navigate</a> algorithm, starting from the <i>resource handling</i> step, using the new
  body part as the resource being navigated, with <a>replacement enabled</a> if a previous
  body part from the same resource resulted in a {{Document}} object being created and
  <a>initialized</a>, and otherwise using the same
  setup as the <a>navigate</a> attempt that caused this section to be invoked in the first
  place.

  For the purposes of algorithms processing these body parts as if they were complete stand-alone
  resources, the user agent must act as if there were no more bytes for those resources whenever the
  boundary following the body part is reached.

  <p class="note">
  Thus, <code>load</code> events (and for that matter <code>unload</code> events) do fire for each body part loaded.
  </p>

<h4 id="page-load-processing-model-for-media">Page load processing model for media</h4>

  When an image, video, or audio resource is to be loaded in a <a>browsing context</a>, the
  user agent should create a {{Document}} object, mark it as being an <a>HTML document</a>, set its <a>content
  type</a> to the <a>computed MIME type</a> of the resource (<var>type</var> in the
  <a>navigate</a> algorithm), initialize the {{Document}} object, append
  an <{html}> element to the {{Document}}, append a <{head}> element and
  a <{body}> element to the <{html}> element, append an element <var>host element</var> for the media, as described below, to the <{body}> element,
  and set the appropriate attribute of the element <var>host element</var>, as described
  below, to the address of the image, video, or audio resource.

  The element <var>host element</var> to create for the media is the element given in
  the table below in the second cell of the row whose first cell describes the media. The
  appropriate attribute to set is the one given by the third cell in that same row.

  <table>
    <thead>
    <tr> <th> Type of media
          <th> Element for the media
          <th> Appropriate attribute
    <tr> <td> Image
          <td> <code>img</code>
          <td> <code>src</code>
    <tr> <td> Video
          <td> <code>video</code>
          <td> <code>src</code>
    <tr> <td> Audio
          <td> <code>audio</code>
          <td> <code>src</code>
  </table>

  Then, the user agent must act as if it had <a>stopped
  parsing</a>.

  After creating the <code>Document</code> object, but potentially before the page has finished
  fully loading, the user agent must <a>update the session history with the new page</a>.

  User agents may add content to the <{head}> element of the {{Document}}, or
  attributes to the element <var>host element</var>, e.g., to link to a style sheet, provide a script, give the document a <a element for="html"><code>title</code></a>, make the media
  <a element-attr for="media">autoplay</a>, etc.

<h4 id="page-load-processing-model-for-content-that-uses-plugins">Page load processing model for content that uses plugins</h4>

  When a resource that requires an external resource to be rendered is to be loaded in a
  <a>browsing context</a>, the user agent should create a {{Document}} object, mark
  it as being an <a>HTML document</a> and mark it as being a
  <dfn>plugin document</dfn>, set its <a>content
  type</a> to the <a>computed MIME type</a> of the resource (<var>type</var> in the
  <a>navigate</a> algorithm), initialize the {{Document}} object, append
  an <{html}> element to the {{Document}}, append a <{head}> element and
  a <{body}> element to the <{html}> element, append an <code>embed</code> to the
  <{body}> element, and set the <code>src</code> attribute of the
  <{embed}> element to the address of the resource.

  <p class="note">
  The term <a>plugin document</a> is used by
  <cite>Content Security Policy</cite> as part of the mechanism that ensures <code>iframe</code>s
  can't be used to evade <code>plugin-types</code> directives. [[!CSP3]]
  </p>

  Then, the user agent must act as if it had <a>stopped
  parsing</a>.

  After creating the <code>Document</code> object, but potentially before the page has finished
  fully loading, the user agent must <a>update the session history with the new page</a>.

  User agents may add content to the <{head}> element of the {{Document}}, or
  attributes to the <{embed}> element, e.g., to link to a style sheet,
  to give the document a <a element for="html"><code>title</code></a>, etc.

  <p class="note">
  If the {{Document}}'s <a>active sandboxing
  flag set</a> has its <a>sandboxed plugins browsing context flag</a> set, the synthesized
  <{embed}> element will fail to render the content if
  the relevant <a>plugin</a> cannot be <a>secured</a>.
  </p>

<h4 id="page-load-processing-model-for-inline-content-that-doesnt-have-a-dom"><dfn lt="display the inline content">Page load processing model for inline content that doesn't have a DOM</dfn></h4>

  When the user agent is to display a user agent page inline in a <a>browsing context</a>,
  the user agent should create a {{Document}} object, mark it as being an <a>HTML document</a>, set its <a>content type</a> to "<a href="#text-html"><code>text/html</code></a>",
  initialize the {{Document}} object, and then either associate that
  {{Document}} with a custom rendering that is not rendered using the normal
  {{Document}} rendering rules, or mutate that {{Document}} until it represents
  the content the user agent wants to render.

  Once the page has been set up, the user agent must act as if it had <a lt="stops parsing">stopped parsing</a>.

  After creating the <code>Document</code> object, but potentially before the page has been
  completely set up, the user agent must <a>update the session history with the new
  page</a>.

<h4 id="navigating-to-a-fragment-identifier">Navigating to a <dfn lt="fragment identifier|fragment identifiers">fragment identifier</dfn></h4>

  When a user agent is supposed to navigate to a fragment identifier, then the user agent must
  run the following steps:

  <ol>

    <li>

    Remove all the entries in the <a>browsing context</a>'s <a>session history</a>
    after the <a>current entry</a>. If the <a>current entry</a> is the last entry in the
    session history, then no entries are removed.

    <p class="note">
  This <a>doesn't necessarily have to affect</a> the user
    agent's user interface.
  </p>

    </li>

    <li>Remove any <a>tasks</a> queued by the <a>history traversal
    task source</a> that are associated with any {{Document}} objects in the
    <a>top-level browsing context</a>'s <a>document family</a>.</li>

    <li>Append a new entry at the end of the <code>History</code> object representing the new
    resource and its {{Document}} object, related state, and current history scroll restoration preference. Its <a for="url">URL</a> must be set to the address to which the user
   agent was <a>navigating</a>. The title must be left unset.</li>

    <li><a>Traverse the history</a> to the new entry, with the <i>non-blocking events</i> flag
    set. This will <a>scroll to the fragment
    identifier</a> given in what is now <a>the document's address</a>.</li>

  </ol>

  <p class="note">
  If the scrolling fails because the relevant <a>ID</a> has
  not yet been parsed, then the original <a>navigation</a> algorithm will
  take care of the scrolling instead, as the last few steps of its <a>update the session history
  with the new page</a> algorithm.
  </p>

  <hr />

  When the user agent is required to <dfn>scroll to the fragment identifier</dfn> and <a>the
  indicated part of the document</a>, if any, is <a>being rendered</a>, the user agent must
  either change the scrolling position of the document using the following algorithm, or perform
  some other action such that <a>the indicated part of the document</a> is brought to the
  user's attention. If there is no indicated part, or if the indicated part is not <a>being
  rendered</a>, then the user agent must do nothing. The aforementioned algorithm is as
  follows:

  <ol>

    <li>Let <var>target</var> be <a>the indicated part of the
    document</a>, as defined below.</li>

    <li>If <var>target</var> is the top of the document, then <a spec="cssom-view">scroll to the beginning of the document</a> for the {{Document}}, and abort these steps. [[!CSSOM-VIEW]]</li>

    <li>Use the <a spec="cssom-view">scroll an element into view</a> algorithm to scroll <var>target</var> into view, with the <var>align to top flag</var> set. [[!CSSOM-VIEW]]</li>

    <li>Run the <a>focusing steps</a> for that element, with the {{Document}}'s
    <a>viewport</a> as the <i>fallback target</i>.</li>

    <li>Move the <a>sequential focus navigation starting point</a> to
    <var>target</var>.

  </ol>

  <dfn lt="an indicated part of the document|the indicated part of the document|indicated part of the document">The indicated part of the document</dfn> is the one that the fragment identifier, if any,
  identifies. The semantics of the fragment identifier in terms of mapping it to a specific DOM Node
  is defined by the specification that defines the <a>MIME type</a> used by the
  {{Document}} (for example, the processing of fragment identifiers for <a>XML MIME types</a> is the responsibility of RFC7303). [[!RFC7303]]

  For HTML documents (and <a>HTML MIME types</a>), the following
  processing model must be followed to determine what <a>the indicated part of the document</a> is.

  <ol>

    <li>Apply the <a>URL parser</a> algorithm to the <a for="url">URL</a>, and let <var>fragid</var> be the <a for="url">fragment</a> component of the
    <a>resulting URL record</a>.</li>

    <li>If <var>fragid</var> is the empty string, then <a>the indicated part of the
    document</a> is the top of the document; stop the algorithm here.</li>

    <li>Let <var>fragid bytes</var> be the result of percent decoding <var>fragid</var>.</li>

    <li>Let <var>decoded fragid</var> be the result of running
    <a>UTF-8 decode without BOM or fail</a> on <var>fragid bytes</var>. If <var>decoded fragid</var>
    is failure, jump to the step labeled no <var>decoded fragid</var>.</li>

    <li>If there is an element in the DOM that has an <a>ID</a> exactly
    equal to <var>decoded fragid</var>, then the first such element in <a>tree order</a> is
    <a>the indicated part of the document</a>; stop the algorithm here.</li>

    <li><i>No decoded fragid</i>: If there is an <{a}> element in the DOM that has a <code>name</code> attribute whose value is exactly equal to <var>fragid</var> (<em>not</em> <var>decoded fragid</var>), then the first such
    element in <a>tree order</a> is <a>the indicated part of the document</a>; stop the algorithm
    here.</li>

    <li>If <var>fragid</var> is an <a>ASCII case-insensitive</a> match for the
    string <code>top</code>, then <a>the indicated part of the document</a> is the top
    of the document; stop the algorithm here.</li>

    <li>Otherwise, there is no <a>indicated part of the document</a>.</li>

  </ol>

  For the purposes of the interaction of HTML with Selectors' <dfn><code>:target</code></dfn> pseudo-class, the <dfn><i>target element</i></dfn>
  is <a>the indicated part of the document</a>, if that is an element; otherwise there is no
  <i>target element</i>. [[!CSS3-SELECTORS]]

  The <a>task source</a> for the task mentioned in this section must be the <a>DOM
  manipulation task source</a>.

  </div>

<h4 id="history-traversal">History traversal</h4>

  <div class="impl">

  When a user agent is required to <dfn lt="traverse the history|history traversal|session history traversal|traversing the history">traverse the history</dfn> to a <var>specified
  entry</var>, optionally with <a>replacement enabled</a>, and optionally with the
  <i>non-blocking events</i> flag set, the user agent must act as follows.

  <p class="note">
  This algorithm is not just invoked when <a>explicitly going back or forwards in the session history</a> &mdash; it is also invoked
  in other situations, for example when <a>navigating a browsing context</a>,
  as part of <a>updating the session history
  with the new page</a>.
  </p>

  <ol>

    <li>

    If there is no longer a {{Document}} object for the entry in question,
    <a>navigate</a> the <a>browsing
    context</a> to the resource for that entry to perform an <a>entry update</a> of that
    entry, and abort these steps. The "<a>navigate</a>" algorithm reinvokes this "traverse"
    algorithm to complete the traversal, at which point there <em>is</em> a {{Document}}
    object and so this step gets skipped. The navigation must be done using the same <a>source
    browsing context</a> as was used the first time this entry was created. (This can never
    happen with <a>replacement enabled</a>.)

    <p class="note">
  If the resource was obtained using a non-idempotent action, for example a POST
    <a>form submission</a>, or if the resource is no longer available, for example because the computer is
    now offline and the page wasn't cached, navigating to it again might not be possible. In this
    case, the navigation will result in a different page than previously; for example, it might be
    an error message explaining the problem or offering to resubmit the form.
  </p>

    </li>

    <li>If the <a>current entry</a>'s title was not set by the <code>pushState()</code> or <code>replaceState()</code> methods, then set its title to the value
    returned by the <code>document.title</code> IDL attribute.</li>

    <li>If appropriate, update the <a>current entry</a> in the <a>browsing
    context</a>'s {{Document}} object's <code>History</code> object to reflect any state
    that the user agent wishes to persist. The entry is then said to be <a>an entry with persisted
    user state</a>.</li>

    <li>If the <var>specified entry</var> has a different {{Document}} object
    than the <a>current entry</a>, then run the following substeps:

    <ol>

      <li>Remove any <a>tasks</a> queued by the <a>history traversal
      task source</a> that are associated with any {{Document}} objects in the
      <a>top-level browsing context</a>'s <a>document family</a>.</li>

      <li>

      If the <a for="concept">origin</a> of the {{Document}} of the <var>specified entry</var> is not the same as
      the <a for="concept">origin</a> of the {{Document}} of the <a>current entry</a>, then run the
      following sub-sub-steps:

      <ol>

        <li>The current <a>browsing context name</a> must be stored with all the entries in
        the history that are associated with {{Document}} objects with the <a>same
        origin</a> as the <a>active document</a> <em>and</em> that are contiguous with the
        <a>current entry</a>.</li>

        <li><dfn lt="gets reset"></dfn>If the browsing context is a <a>top-level browsing context</a>,
        but not an <a>auxiliary browsing context</a>, then the browsing context's
        <a>browsing context name</a> must be unset.</li>

      </ol>

      </li>

      <li>Make the <var>specified entry</var>'s
      {{Document}} object the <a>active document</a> of the <a>browsing
      context</a>.</li>

      <li>

      If the <var>specified entry</var> has a <a>browsing context name</a> stored
      with it, then run the following sub-sub-steps:

      <ol>

        <li>Set the browsing context's <a>browsing context name</a> to the name stored with
        the specified entry.</li>

        <li>Clear any <a>browsing context names</a> stored
        with all entries in the history that are associated with {{Document}} objects with
        the <a>same origin</a> as the new <a>active document</a> and that are contiguous
        with the specified entry.</li>

      </ol>

      </li>

      <li>If the <var>specified entry</var>'s
      {{Document}} has any form controls whose <a>autofill field name</a> is "<code>off</code>", invoke the <dfn lt="values are reset"></dfn> <a>reset algorithm</a> of each of those elements.</li>

      <li>

      If the <a>current document readiness</a> of the <var>specified entry</var>'s
      {{Document}} is "<code>complete</code>", <a>queue a task</a> to run
      the following sub-sub-steps:

      <ol>

        <li>If the {{Document}}'s <a>page showing</a> flag is true, then abort this
        task (i.e., don't fire the event below).</li>

        <li>Set the {{Document}}'s <a>page showing</a> flag to true.</li>

        <li>

        Run any <dfn>session history document visibility change steps</dfn> for {{Document}} that
        are defined by <a lt="applicable specification">other applicable specifications</a>.

        <p class="note">
  This is specifically intended for use by the Page Visibility specification. [[PAGE-VISIBILITY]]
  </p>

        </li>

        <li><a>Fire</a> a <a>trusted</a> event with the name <code>pageshow</code> at the <code>Window</code> object of that
        {{Document}}, with <i>target override</i> set to the {{Document}}
        object,
        using the <code>PageTransitionEvent</code> interface, with the <code>persisted</code> attribute initialized to true.
        This event must not bubble, must not be cancelable, and has no default action.</li>

      </ol>

      </li>

    </ol>

    </li>

    <li>Set <a>the document's address</a> to the URL of the <var>specified
    entry</var>.</li>

    <li>If the <var>specified entry</var> has a URL whose fragment identifier differs
    from that of the <a>current entry</a>'s when compared in a <a>case-sensitive</a>
    manner, and the two share the same {{Document}} object, then let <var>hash
    changed</var> be true, and let <var>old URL</var> be the URL of the <a>current
    entry</a> and <var>new URL</var> be the URL of the <var>specified
    entry</var>. Otherwise, let <var>hash changed</var> be false.</li>

    <li>If the traversal was initiated with <dfn lt="replacement must be enabled|replacement enabled">replacement enabled</dfn>, remove the entry
    immediately before the <var>specified entry</var> in the session history.</li>

    <li>If the <var>specified entry</var> is not <a>an entry with persisted user
    state</a>, but its URL has a fragment identifier, <a>scroll to the fragment
    identifier</a>.</li>

    <li>If the entry is <a>an entry with persisted user state</a>, the user agent may
    <a>restore persisted user state</a> and update aspects of the document and its rendering.</li>

    <li>Let <var>targetRealm</var> be the <a>current Realm Record</a>.</li>

    <li>If the entry is a <a>state object</a> entry, let <var>state</var> be
    <a>StructuredClone</a>(that state object, <var>targetRealm</var>) of that state object. Otherwise, let <var>state</var> be
    null.</li>

    <li>Set <code>history.state</code> to <var>state</var>.</li>

    <li>Let <var>state changed</var> be true if the {{Document}} of the <var>specified entry</var> has a <a>latest entry</a>, and that entry is not the <var>specified entry</var>; otherwise let it be false.

    <li>Let the <a>latest entry</a> of the {{Document}} of the <var>specified entry</var> be the <var>specified entry</var>.</li>

    <li>

    If the <i>non-blocking events</i> flag is not set, then run the following steps
    <a>immediately</a>. Otherwise, the <i>non-blocking events</i> flag is set; <a>queue a task</a>
    to run the following substeps instead.

    <ol>

      <li>If <var>state changed</var> is true, <a>fire</a> a <a>trusted</a>
      event with the name <code>popstate</code> at the <code>Window</code>
      object of the {{Document}}, using the <code>PopStateEvent</code> interface, with the
      <code>state</code> attribute initialized to the value of <var>state</var>. This event must bubble but not be cancelable and has no default
      action.</li>

      <li>If <var>hash changed</var> is true, then <a>fire</a> a <a>trusted</a>
      event with the name <code>hashchange</code> at the <a>browsing
      context</a>'s <code>Window</code> object, using the <code>HashChangeEvent</code> interface,
      with the <code>oldURL</code> attribute initialized to <var>old URL</var> and the <code>newURL</code> attribute
      initialized to <var>new URL</var>. This event must bubble but not be cancelable and
      has no default action.</li>

    </ol>

    </li>

    <li>The <a>current entry</a> is now the <var>specified entry</var>.</li>

  </ol>

  The <a>task source</a> for the tasks mentioned above is the <a>DOM manipulation task
  source</a>.

  </div>

  <h5 id="persisted-user-state-restoration">Persisted user state restoration</h5>
  <div class="impl">

  <p>When the user agent is to <dfn>restore persisted user state</dfn> from a history entry, it must
  run the following steps immediately:</p>

  <ol>

   <li>If the entry has a <a>scroll restoration mode</a>, let <var>scrollRestoration</var>
   be that. Otherwise let <var>scrollRestoration</var> be "<code>auto</code>"</li>

   <li>If <var>scrollRestoration</var> is "<code>manual</code>" the user agent should not restore
   the scroll position for the document, otherwise, it may do so.</li>

   <li>Optionally, update other aspects of the document and its rendering, for instance values of
   form fields, that the user agent had previously recorded.</li>

  </ol>
  </div>

  <p class="note">This can even include updating the <code>dir</code> attribute
  of <{textarea}> elements or <{input}> elements whose <code>type</code> attribute
  is in either the <a element-state for="input">Text</a> state or the
  <a element-state for="input">Search</a> state, if the persisted state includes the
  directionality of user input in such controls.</p>

<h5 id="the-popstateevent-interface">The <code>PopStateEvent</code> interface</h5>

  <pre class="idl" data-highlight="webidl" dfn-for="PopStateEvent">
    [Constructor(DOMString type, optional PopStateEventInit eventInitDict), Exposed=(Window,Worker)]
    interface PopStateEvent : Event {
      readonly attribute any state;
    };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="PopStateEventInit">
    dictionary PopStateEventInit : EventInit {
      any state;
    };
  </pre>

  <dl class="domintro">

    <dt><var>event</var> . <code>state</code></dt>

    <dd>

    Returns a copy of the information that was provided to <code>pushState()</code> or <code>replaceState()</code>.

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="PopStateEvent"><code>state</code></dfn> attribute must return the
  value it was initialized to. When the object is created, this attribute must be initialized to
  null. It represents the context information for the event, or null, if the state represented is
  the initial state of the {{Document}}.

  </div>

<h5 id="the-hashchangeevent-interface">The <code>HashChangeEvent</code> interface</h5>

  <pre class="idl" data-highlight="webidl" dfn-for="HashChangeEvent">
    [Constructor(DOMString type, optional HashChangeEventInit eventInitDict), Exposed=(Window,Worker)]
    interface HashChangeEvent : Event {
      readonly attribute DOMString oldURL;
      readonly attribute DOMString newURL;
    };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="HashChangeEventInit">
    dictionary HashChangeEventInit : EventInit {
      DOMString oldURL;
      DOMString newURL;
    };
  </pre>

  <dl class="domintro">

    <dt><var>event</var> . <code>oldURL</code></dt>

    <dd>

    Returns the <a for="url">URL</a> of the <a>session history entry</a> that was previously
    current.

    </dd>

    <dt><var>event</var> . <code>newURL</code></dt>

    <dd>

    Returns the <a for="url">URL</a> of the <a>session history entry</a> that is now
    current.

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="HashChangeEvent"><code>oldURL</code></dfn> attribute must return the
  value it was initialized to. When the object is created, this attribute must be initialized to
  null. It represents context information for the event, specifically the URL of the <a>session
  history entry</a> that was traversed from.

  The <dfn attribute for="HashChangeEvent"><code>newURL</code></dfn> attribute must return the
  value it was initialized to. When the object is created, this attribute must be initialized to
  null. It represents context information for the event, specifically the URL of the <a>session
  history entry</a> that was traversed to.

  </div>

<h5 id="the-pagetransitionevent-interface">The <code>PageTransitionEvent</code> interface</h5>

  <pre class="idl" data-highlight="webidl" dfn-for="PageTransitionEvent">
    [Constructor(DOMString type, optional PageTransitionEventInit eventInitDict), Exposed=(Window,Worker)]
    interface PageTransitionEvent : Event {
      readonly attribute boolean persisted;
    };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="PageTransitionEventInit">
    dictionary PageTransitionEventInit : EventInit {
      boolean persisted;
    };
  </pre>

  <dl class="domintro">

    <dt><var>event</var> . <code>persisted</code></dt>

    <dd>

    For the <code>pageshow</code> event, returns false if the page is
    newly being loaded (and the <code>load</code> event will fire). Otherwise,
    returns true.

    For the <code>pagehide</code> event, returns false if the page is
    going away for the last time. Otherwise, returns true, meaning that (if nothing conspires to
    make the page unsalvageable) the page might be reused if the user navigates back to this
    page.

    Things that can cause the page to be unsalvageable include:

    <ul class="brief">
      <li><code>document.open()</code>
      <li>Listening for <code>beforeunload</code> events
      <li>Listening for <code>unload</code> events
      <li>Having <code>iframe</code>s that are not salvageable
      <li>Active <code>WebSocket</code> objects
      <li><a>Aborting a <code>Document</code></a>
    </ul>

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="PageTransitionEvent"><code>persisted</code></dfn> attribute must
  return the value it was initialized to. When the object is created, this attribute must be
  initialized to false. It represents the context information for the event.

  </div>

<h4 id="unloading-documents">Unloading documents</h4>

  <div class="impl">

  A {{Document}} has a <dfn><i>salvageable</i></dfn> state, which must initially be
  true, a <dfn>fired unload</dfn> flag, which must initially be false, and a <dfn>page showing</dfn>
  flag, which must initially be false. The <a>page showing</a> flag is used to ensure that
  scripts receive <code>pageshow</code> and <code>pagehide</code> events in a consistent manner (e.g., that they never
  receive two <code>pagehide</code> events in a row without an intervening
  <code>pageshow</code>, or vice versa).

  <a>Event loops</a> have a <dfn>termination nesting level</dfn>
  counter, which must initially be zero.

  When a user agent is to <dfn lt="prompt to unload|prompt to unload a document">prompt to unload a document</dfn>, it must run the following
  steps.

  <ol>

    <li>Increase the <a>event loop</a>'s <a>termination nesting level</a> by
    one.</li>

    <li>Increase the {{Document}}'s <a>ignore-opens-during-unload counter</a> by
    one.</li>

    <li>Let <var>event</var> be a new <a>trusted</a>
    <code>BeforeUnloadEvent</code> event object with the name <code>beforeunload</code>, which does not bubble but is cancelable.</li>

    <li><i>Dispatch</i>: <a>Dispatch</a> <var>event</var> at the {{Document}}'s <code>Window</code> object.</li>

    <li>Decrease the <a>event loop</a>'s <a>termination nesting level</a> by
    one.</li>

    <li>If any event listeners were triggered by the earlier <i>dispatch</i> step, then set the
    {{Document}}'s <i>salvageable</i> state to
    false.</li>

    <li>

    If the {{Document}}'s <a>active sandboxing flag set</a> does not have its
    <a>sandboxed modals flag</a> set, and the {{BeforeUnloadEvent/returnValue}} attribute of the
    <var>event</var> object is not the empty string, or if the event was canceled, then the user
    agent should ask the user to confirm that they wish to unload the document.

    The prompt shown by the user agent may include the string of the
    {{BeforeUnloadEvent/returnValue}} attribute, or some leading subset thereof. (A user agent may
    want to truncate the string to 1024 characters for display, for instance.)

    The user agent must <a state for="useragent">pause</a> while waiting for the user's response.

    If the user did not confirm the page navigation, then the user agent <dfn lt="refused to allow the document to be unloaded|refused to allow this document to be unloaded">refused to allow the document to be unloaded</dfn>.

    </li>

    <li>If this algorithm was invoked by another instance of the "prompt to unload a document"
    algorithm (i.e., through the steps below that invoke this algorithm for all descendant browsing
    contexts), then jump to the step labeled <i>end</i>.</li>

    <li>Let <var>descendants</var> be the <a>list of the descendant browsing
    contexts</a> of the {{Document}}.</li>

    <li>

    If <var>descendants</var> is not an empty list, then for each <a>browsing
    context</a> <var>b</var> in <var>descendants</var> run the following
    substeps:

    <ol>

      <li><a>Prompt to unload</a> the <a>active
      document</a> of the <a>browsing context</a> <var>b</var>. If the user
      <a>refused to allow the document to be unloaded</a>, then the user implicitly also <a>refused to allow <em>this</em> document to be unloaded</a>; jump to the step labeled <i>end</i>.

      <li>If the <i>salvageable</i> state of the <a>active
      document</a> of the <a>browsing context</a> <var>b</var> is false, then set
      the <i>salvageable</i> state of <em>this</em> document to
      false also.</li>

    </ol>

    </li>

    <li><i>End</i>: Decrease the {{Document}}'s <a>ignore-opens-during-unload
    counter</a> by one.</li>

  </ol>

  When a user agent is to <dfn lt="unloaded|unload|unload a document|being unloaded">unload a document</dfn>, it must run the following steps. These
  steps are passed an argument, <var>recycle</var>, which is either true or false,
  indicating whether the {{Document}} object is going to be re-used. (This is set by the
  <code>document.open()</code> method.)

  <ol>

    <li>Increase the <a>event loop</a>'s <a>termination nesting level</a> by
    one.</li>

    <li>Increase the {{Document}}'s <a>ignore-opens-during-unload counter</a> by
    one.</li>

    <li>If the {{Document}}'s <a>page showing</a> flag is false, then jump to the
    step labeled <i>unload event</i> below (i.e., skip firing the <code>pagehide</code> event and don't rerun the <a>unloading document
    visibility change steps</a>).</li>

    <li>Set the {{Document}}'s <a>page showing</a> flag to false.</li>

    <li><a>Fire</a> a <a>trusted</a> event with the name <code>pagehide</code> at the <code>Window</code> object of the
    {{Document}}, with <i>target override</i> set to the {{Document}}
    object, using the <code>PageTransitionEvent</code> interface,
    with the <code>persisted</code> attribute initialized
    to true if the {{Document}} object's <i>salvageable</i> state is true, and false otherwise. This
    event must not bubble, must not be cancelable, and has no default action.</li>

    <li>

    Run any <dfn>unloading document visibility change steps</dfn> for {{Document}} that
    are defined by <a lt="applicable specification">other applicable specifications</a>.

    <p class="note">
  This is specifically intended for use by the Page Visibility specification. [[PAGE-VISIBILITY]]
  </p>

    </li>

    <li><i>Unload event</i>: If the {{Document}}'s <a>fired unload</a> flag is
    false, <a>fire a simple event</a> named <code>unload</code> at the
    {{Document}}'s <code>Window</code> object, with <i>target override</i> set to the
    {{Document}} object.</li>

    <li>Decrease the <a>event loop</a>'s <a>termination nesting level</a> by
    one.</li>

    <li>If any event listeners were triggered by the earlier <i>unload event</i> step, then set
    the {{Document}} object's <i>salvageable</i> state
    to false and set the {{Document}}'s <a>fired unload</a> flag to true.</li>

    <li>Run any <a>unloading document cleanup steps</a> for {{Document}} that are
    defined by this specification and <a lt="applicable specification">other applicable specifications</a>.</li>

    <li>If this algorithm was invoked by another instance of the "unload a document" algorithm
    (i.e., by the steps below that invoke this algorithm for all descendant browsing contexts), then
    jump to the step labeled <i>end</i>.</li>

    <li>Let <var>descendants</var> be the <a>list of the descendant browsing
    contexts</a> of the {{Document}}.</li>

    <li>

    If <var>descendants</var> is not an empty list, then for each <a>browsing
    context</a> <var>b</var> in <var>descendants</var> run the following
    substeps:

    <ol>

      <li><a>Unload</a> the <a>active document</a> of the
      <a>browsing context</a> <var>b</var> with the <var>recycle</var>
      parameter set to false.</li>

      <li>If the <i>salvageable</i> state of the <a>active
      document</a> of the <a>browsing context</a> <var>b</var> is false, then set
      the <i>salvageable</i> state of <em>this</em> document to
      false also.</li>

    </ol>

    </li>

    <li>If both the {{Document}}'s <i>salvageable</i> state and <var>recycle</var> are
    false, then the {{Document}}'s <a>browsing context</a> must <a>discard the <code>Document</code></a>.</li>

    <li><i>End</i>: Decrease the {{Document}}'s <a>ignore-opens-during-unload
    counter</a> by one.</li>

  </ol>

  This specification defines the following <dfn>unloading document cleanup steps</dfn>. Other
  specifications can define more.

  <ol>

    <li>

    Make disappear any <code>WebSocket</code> objects that were created by the <code>WebSocket()</code> constructor from the
    {{Document}}'s <code>Window</code> object.

    If this affected any <code>WebSocket</code> objects, then set {{Document}}'s <i>salvageable</i> state to false.

    </li>

    <li>If the {{Document}}'s <i>salvageable</i>
    state is false, forcibly close any
    <code>EventSource</code> objects that whose constructor was invoked from the
    {{Document}}'s <code>Window</code> object.</li>

    <li>If the {{Document}}'s <i>salvageable</i>
    state is false, empty the {{Document}}'s <code>Window</code>'s <a>list of active
    timers</a>.</li>

  </ol>

  </div>

<h5 id="the-beforeunloadevent-interface">The <code>BeforeUnloadEvent</code> interface</h5>

  <pre class="idl" data-highlight="webidl" dfn-for="BeforeUnloadEvent">
    interface BeforeUnloadEvent : Event {
      attribute DOMString returnValue;
    };
  </pre>

  <dl class="domintro">

    <dt><var>event</var> . {{BeforeUnloadEvent/returnValue}} [ = <var>value</var> ]</dt>

    <dd>

    Returns the current return value of the event (the message to show the user).

    Can be set, to update the message.

    </dd>

  </dl>

  <p class="note">
  There are no <code>BeforeUnloadEvent</code>-specific initialization methods.
  </p>

  <div class="impl">

  The <dfn attribute for="BeforeUnloadEvent"><code>returnValue</code></dfn> attribute
  represents the message to show the user. When the event is created, the attribute must be set to
  the empty string. On getting, it must return the last value it was set to. On setting, the
  attribute must be set to the new value.

  </div>

  <div class="impl">

<h4 id="aborting-a-document-load">Aborting a document load</h4>

  If a {{Document}} is <dfn lt="abort the document|aborted|aborting a document|abort a document">aborted</dfn>, the user agent must
  run the following steps:

  <ol>

    <li><a>Abort</a> the <a>active
    documents</a> of every <a>child browsing context</a>. If this results in any of those
    {{Document}} objects having their <i>salvageable</i> state set to false, then set this
    {{Document}}'s <i>salvageable</i> state to false
    also.</li>

    <li>Cancel any instances of the <a>fetch</a> algorithm in the
    context of this {{Document}}, discarding any <a>tasks</a>
    <a>queued</a> for them, and discarding any further data received from
    the network for them. If this resulted in any instances of the <a>fetch</a> algorithm being canceled or any <a>queued</a> <a>tasks</a> or any network data getting
    discarded, then set the {{Document}}'s <i>salvageable</i> state to false.</li>

    <li>If the {{Document}} has an <a>active parser</a>, then <a>abort that parser</a> and set the {{Document}}'s <i>salvageable</i> state to false.</li>

  </ol>

  User agents may allow users to explicitly invoke the <a>abort a
  document</a> algorithm for a {{Document}}. If the user does so, then, if that
  {{Document}} is an <a>active document</a>, the user agent should <a>queue a
  task</a> to <a>fire a simple event</a> named <code>abort</code> at
  that {{Document}}'s <code>Window</code> object before invoking the <a>abort</a> algorithm.

  </div>

<h4 id="browser-state">Browser state</h4>

  <pre class="idl" data-highlight="webidl" dfn-for="NavigatorOnLine">
    [NoInterfaceObject, Exposed=(Window, Worker)]
    interface NavigatorOnLine {
      readonly attribute boolean onLine;
    };
  </pre>

  <dl class="domintro">

    <dt><var>window</var> . <code>navigator</code> . <code>onLine</code></dt>

    <dd>

    Returns false if the user agent is definitely offline (disconnected from the network).
    Returns true if the user agent might be online.

    The events <code>online</code> and <code>offline</code> are fired when the value of this attribute changes.

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="NavigatorOnLine" lt="onLine|navigator.onLine"><code>navigator.onLine</code></dfn> attribute must return
  false if the user agent will not contact the network when the user follows links or when a script
  requests a remote page (or knows that such an attempt would fail), and must return true
  otherwise.

  When the value that would be returned by the <code>navigator.onLine</code> attribute of a <code>Window</code> or
  <code>WorkerGlobalScope</code> changes from true to false, the user agent must <a>queue a
  task</a> to <a>fire a simple event</a> named <code>offline</code>
  at the <code>Window</code> or <code>WorkerGlobalScope</code> object.

  On the other hand, when the value that would be returned by the <code>navigator.onLine</code> attribute of a <code>Window</code> or
  <code>WorkerGlobalScope</code> changes from false to true, the user agent must <a>queue a
  task</a> to <a>fire a simple event</a> named <code>online</code> at
  the <code>Window</code> or <code>WorkerGlobalScope</code> object.

  The <a>task source</a> for these <a>tasks</a> is the
  <a>networking task source</a>.

  </div>

  <p class="note">
  This attribute is inherently unreliable. A computer can be connected to a network
  without having Internet access.
  </p>

  <div class="example">
    In this example, an indicator is updated as the browser goes online and offline.

    <pre highlight="html">
      &lt;!DOCTYPE HTML>
      &lt;html>
        &lt;head>
          &lt;title>Online status&lt;/title>
          &lt;script>
            function updateIndicator() {
              document.getElementById('indicator').textContent = navigator.onLine ? 'online' : 'offline';
            }
          &lt;/script>
        &lt;/head>
        &lt;body onload="updateIndicator()" ononline="updateIndicator()" onoffline="updateIndicator()">
          &lt;p>The network is: &lt;span>(state unknown)&lt;/span>
        &lt;/body>
      &lt;/html>
    </pre>
  </div>

</section>
