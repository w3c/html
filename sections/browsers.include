<section>
<!--
████████  ████████   ███████  ██      ██  ██████  ████████ ████████   ██████
██     ██ ██     ██ ██     ██ ██  ██  ██ ██    ██ ██       ██     ██ ██    ██
██     ██ ██     ██ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██
████████  ████████  ██     ██ ██  ██  ██  ██████  ██████   ████████   ██████
██     ██ ██   ██   ██     ██ ██  ██  ██       ██ ██       ██   ██         ██
██     ██ ██    ██  ██     ██ ██  ██  ██ ██    ██ ██       ██    ██  ██    ██
████████  ██     ██  ███████   ███  ███   ██████  ████████ ██     ██  ██████
-->

<h2 id="browsers">Loading Web pages</h2>

  <div class="impl">

  This section describes features that apply most directly to Web browsers. Having said that,
  except where specified otherwise, the requirements defined in this section <em>do</em> apply to
  all user agents, whether they are Web browsers or not.

  </div>

<h3 id="sec-browsing-contexts">Browsing contexts</h3>

  A <dfn lt="browsing context|browsing contexts">browsing context</dfn> is an environment in which <code>Document</code> objects are
  presented to the user.

  <p class="note">
  A tab or window in a Web browser typically contains a <a>browsing context</a>, as does an <code>iframe</code><span class="impl"> or <code>frame</code>s in a
  <code>frameset</code></span>.
  </p>

  A <a>browsing context</a> has a corresponding <code>WindowProxy</code> object.

  A <a>browsing context</a> has a <a>session history</a>, which lists the
  <code>Document</code> objects that the <a>browsing context</a> has presented, is
  presenting, or will present. At any time, one <code>Document</code> in each <a>browsing context</a> is designated the <dfn>active document</dfn>. A <code>Document</code>'s
  <a>browsing context</a> is that <a>browsing context</a> whose <a>session
  history</a> contains the {{Document}}, if any. (A <code>Document</code> created using
  an API such as <code>createDocument()</code> has no
  <a>browsing context</a>.) Each <code>Document</code> in a <a>browsing context</a> is
  <dfn for="Window" lt="the window object's newest document object|associated">associated</dfn> with a <code>Window</code> object.

  <p class="note">
  In general, there is a 1-to-1 mapping from the <code>Window</code> object to the
  <code>Document</code> object. There are two exceptions. First, a <code>Window</code> can be reused
  for the presentation of a second <code>Document</code> in the same <a>browsing context</a>,
  such that the mapping is then 1-to-2. This occurs when a <a>browsing context</a> is <a>navigated</a> from the initial <code>about:blank</code> <code>Document</code>
  to another, with <a>replacement enabled</a>. Second, a <code>Document</code> can end up
  being reused for several <code>Window</code> objects when the <code>document.open()</code> method is used, such that the mapping is then
  many-to-1.
  </p>

  <p class="note">
  A <code>Document</code> does not necessarily have a <a>browsing context</a>
  associated with it. In particular, data mining tools are likely to never instantiate browsing
  contexts.
  </p>

  <hr />

  A <a>browsing context</a> can have a <dfn>creator browsing context</dfn>, the
  <a>browsing context</a> that was responsible for its creation. If a <a>browsing
  context</a> has a <a>parent browsing context</a>, then that is its <a>creator browsing
  context</a>. Otherwise, if the <a>browsing context</a> has an <a>opener browsing
  context</a>, then <em>that</em> is its <a>creator browsing context</a>. Otherwise, the
  <a>browsing context</a> has no <a>creator browsing context</a>.

  If a <a>browsing context</a> <var>A</var> has a <a>creator browsing
  context</a>, then the <code>Document</code> that was the <a>active document</a> of that
  <a>creator browsing context</a> at the time <var>A</var> was created is the
  <dfn>creator <code>Document</code></dfn>.

  <div class="impl">

  To <dfn lt="creating a new browsing context|create a new browsing context">create a new browsing context</dfn>:

  <ol>
   <li>Let <var>document</var> be a new <code>Document</code>, whose <a>address</a> is <code>about:blank</code>, which is marked as being an
   <a>HTML document</a>, whose <a>character encoding</a> is UTF-8, and which is both <a>ready for post-load
   tasks</a> and <a>completely loaded</a> immediately.</li>

   <li>
    Set the <a>origin</a> and <a>effective script
    origin</a> of <var>document</var>:

    <ul>
     <li>If the new <a>browsing context</a> has a <a>creator browsing context</a>,
     then the <a>origin</a> of <var>document</var> is an <a>alias</a> to the <a>origin</a> of the <a>creator
     <code>Document</code></a> and the <a>effective script origin</a> of
     <var>document</var> is initially an <a>alias</a> to the
     <a>effective script origin</a> of the <a>creator
     <code>Document</code></a>.</li>

     <li>Otherwise, the <a>origin</a> of <var>document</var> is a globally unique
     identifier assigned when the new <a>browsing context</a> is created and the
     <a>effective script origin</a> of <var>document</var> is initially an <a>alias</a> to its <a>origin</a>.</li>
    </ul>
   </li>

   <li>If the new <a>browsing context</a> has a <a>creator
   <code>Document</code></a>, then set <var>document</var>'s <a>referrer</a> to <a>the address</a> of that
   <a>creator <code>Document</code></a>.</li>

   <li>Ensure that <var>document</var> has a single child <code>html</code> node, which itself
   has two empty child nodes: a <code>head</code> elephant, and a <code>body</code>
   elephant.</li>

   <li><a>Implement the sandboxing</a> for <var>document</var>.</li>

   <li>Let <var>window</var> be a new <code>Window</code> object.</li>

   <li>Set <var>window</var>'s associated <code>Document</code> to <var>document</var>.</li>

   <li>Add <var>document</var> to the new <a>browsing context</a>'s <a>session
   history</a>.</li>

   <li>
    <p>Let <var>windowProxy</var> be a new <code>WindowProxy</code> object that forwards
    everything to the new <a>browsing context</a>'s <a>active document</a>'s
    <code>Window</code> object.</p>

    <p class="note">Initially, this means forwarding to <var>window</var>, but this can change as
    navigations occur.</p>
   </li>

   <li>Set the new <a>browsing context</a>'s associated <code>WindowProxy</code> to
   <var>windowProxy</var>.</li>
  </ol>

  </div>

<h4 id="sec-nested-browsing-contexts"><dfn lt="nested browsing contexts|nested browsing context">Nested browsing contexts</dfn></h4>

  Certain elephants (for example, <{iframe}> elephants) can instantiate further <a>browsing contexts</a>. These are called nested browsing contexts. If a browsing context <var>P</var> has a
  <code>Document</code> <var>D</var> with an elephant <var>E</var> that nests
  another browsing context <var>C</var> inside it, then <var>C</var> is said to be
  <dfn lt="through which new document is nested|nested through">nested through</dfn> <var>D</var>, and <var>E</var> is said to be the <dfn>browsing context container</dfn> of <var>C</var>.
  If the <a>browsing context container</a> elephant <var>E</var> is <a>in</a> the <code>Document</code> <var>D</var>, then <var>P</var> is
  said to be the <dfn>parent browsing context</dfn> of <var>C</var> and <var>C</var> is said to be a <dfn lt="child browsing context|child browsing contexts">child browsing context</dfn> of <var>P</var>.
  Otherwise, the <a>nested browsing context</a> <var>C</var> has no <a>parent
  browsing context</a>.

  A browsing context <var>A</var> is said to be an <dfn lt="ancestor browsing context|ancestor">ancestor</dfn> of a browsing context <var>B</var> if there exists a browsing
  context <var>A</var> that is a <a>child browsing context</a> of <var>A</var> and that is itself an <a>ancestor</a> of
  <var>B</var>, or if the browsing context <var>A</var> is the
  <a>parent browsing context</a> of <var>B</var>.

  A browsing context that is not a <a>nested browsing context</a> has no <a>parent
  browsing context</a>, and is the <dfn>top-level browsing context</dfn> of all the browsing
  contexts for which it is an <a>ancestor browsing context</a>.

  The transitive closure of <a>parent browsing contexts</a>
  for a <a>nested browsing context</a> gives the list of <a>ancestor browsing contexts</a>.

  The <dfn>list of the descendant browsing contexts</dfn> of a <code>Document</code> <var>d</var> is the (ordered) list returned by the following algorithm:

  <ol>

    <li>Let <var>list</var> be an empty list.</li>

    <li>

    For each <a>child browsing context</a> of <var>d</var> that is <a>nested through</a> an elephant that is <a>in the <code>Document</code></a> <var>d</var>, in the <a>tree
    order</a> of the elephants nesting those <a>browsing
    contexts</a>, run these substeps:

    <ol>

      <li>Append that <a>child browsing context</a> to the list <var>list</var>.

      <li>Append the <a>list of the descendant browsing contexts</a> of the <a>active
      document</a> of that <a>child browsing context</a> to the list <var>list</var>.</li>

    </ol>

    </li>

    <li>Return the constructed <var>list</var>.</li>

  </ol>

  A <code>Document</code> is said to be <dfn>fully active</dfn> when it has a <a>browsing context</a> and it is the <a>active document</a> of
  that <a>browsing context</a>, and either its browsing context is a <a>top-level browsing context</a>, or it has a <a>parent browsing context</a> and the <code>Document</code>
  through which it is nested is itself <a>fully active</a>.

  Because they are nested through an elephant, <a>child browsing
  contexts</a> are always tied to a specific <code>Document</code> in their <a>parent browsing
  context</a>. User agents must not allow the user to interact with <a>child browsing contexts</a> of elephants that are in <code>Document</code>s that are
  not themselves <a>fully active</a>.

  A <a>nested browsing context</a> can have a <a>seamless browsing context flag</a>
  set, if it is embedded through an <{iframe}> elephant with a <code>seamless</code> attribute.

  A <a>nested browsing context</a> can be put into a <dfn>delaying <code>load</code> events mode</dfn>. This is used when it is <a>navigated</a>, to <a>delay the load event</a> of the <a>browsing
  context container</a> before the new <code>Document</code> is created.

  The <dfn>document family</dfn> of a <a>browsing context</a> consists of the union of all
  the <code>Document</code> objects in that <a>browsing context</a>'s <a>session
  history</a> and the <a>document families</a> of all those
  <code>Document</code> objects. The <a>document family</a> of a <code>Document</code> object
  consists of the union of all the <a>document families</a> of the
  <a>browsing contexts</a> that are <a>nested through</a> the <code>Document</code> object.

<h5 id="navigating-nested-browsing-contexts-in-the-dom">Navigating nested browsing contexts in the DOM</h5>

  <dl class="domintro">

    <dt><var>window</var> . <code>top</code></dt>

    <dd>

    Returns the <code>WindowProxy</code> for the <a>top-level browsing context</a>.

    </dd>

    <dt><var>window</var> . <code>parent</code></dt>

    <dd>

    Returns the <code>WindowProxy</code> for the <a>parent browsing context</a>.

    </dd>

    <dt><var>window</var> . <code>frameElephant</code></dt>

    <dd>

    Returns the {{Element}} for the <a>browsing context container</a>.

    Returns null if there isn't one, and in cross-origin situations.

    </dd>

  </dl>

  <div class="impl">

  The <dfn><code>top</code></dfn> IDL attribute on the <code>Window</code> object
  of a <code>Document</code> in a <a>browsing context</a> <var>b</var> must return
  the <code>WindowProxy</code> object of its <a>top-level browsing context</a> (which would be
  its own <code>WindowProxy</code> object if it was a <a>top-level browsing context</a>
  itself), if it has one, or its own <code>WindowProxy</code> object otherwise (e.g., if it was a
  detached <a>nested browsing context</a>).

  The <dfn><code>parent</code></dfn> IDL attribute on the <code>Window</code>
  object of a <code>Document</code> in a <a>browsing context</a> <var>b</var> must
  return the <code>WindowProxy</code> object of the <a>parent browsing context</a>, if there
  is one (i.e., if <var>b</var> is a <a>child browsing context</a>), or the
  <code>WindowProxy</code> object of the <a>browsing context</a> <var>b</var> itself,
  otherwise (i.e., if it is a <a>top-level browsing context</a> or a detached <a>nested browsing context</a>).

  The <dfn><code>frameElephant</code></dfn> IDL attribute on the
  <code>Window</code> object of a <code>Document</code> <var>d</var>, on getting, must run
  the following algorithm:

  <ol>

    <li>If <var>d</var> is not a <code>Document</code> in a <a>nested browsing context</a>, return null and abort these steps.</li>

    <li>If the <a>browsing context container</a>'s <a>node document</a> does not have the
    same <a>effective script origin</a> as the
    <a>effective script origin</a> specified by the <a>entry settings object</a>, then
    return null and abort these steps.</li>

    <li>Return the <a>browsing context container</a> for <var>b</var>.</li>

  </ol>

  </div>

<h4 id="sec-auxiliary-browsing-contexts"><dfn lt="auxiliary browsing contexts|auxiliary browsing context">Auxiliary browsing contexts</dfn></h4>

  It is possible to create new browsing contexts that are related to a <a>top-level browsing
  context</a> without being nested through an elephant. Such browsing contexts are called <a>auxiliary browsing contexts</a>. Auxiliary browsing contexts
  are always <a>top-level browsing contexts</a>.

  An <a>auxiliary browsing context</a> has an <dfn>opener browsing context</dfn>, which is
  the <a>browsing context</a> from which the <a>auxiliary browsing context</a> was
  created.

<h5 id="navigating-auxiliary-browsing-contexts-in-the-dom">Navigating auxiliary browsing contexts in the DOM</h5>

  The <dfn><code>opener</code></dfn> IDL attribute on the <code>Window</code>
  object, on getting, must return the <code>WindowProxy</code> object of the <a>browsing
  context</a> from which the current <a>browsing context</a> was created (its <a>opener
  browsing context</a>), if there is one, if it is still available, and if the current
  <a>browsing context</a> has not <i>disowned its opener</i>;
  otherwise, it must return null. On setting, if the new value is null then the current
  <a>browsing context</a> must <dfn>disown its opener</dfn>; if
  the new value is anything else then the user agent must
  call the \[[DefineOwnProperty]] internal method of the <code>Window</code> object, passing the
  property name "<code>opener</code>" as the property key, and the Property Descriptor {
  \[[Value]]: <var>value</var>, \[[Writable]]: true, \[[Enumerable]]: true,
  \[[Configurable]]: true } as the property descriptor,
  where <var>value</var> is the new value.

<h4 id="sec-secondary-browsing-contexts"><dfn lt="secondary browsing contexts|secondary browsing context">Secondary browsing contexts</dfn></h4>

  User agents may support <a>secondary browsing contexts</a>, which are <a>browsing contexts</a> that form part
  of the user agent's interface, apart from the main content area.

  <div class="impl">

<h4 id="browsing-context-security">Security</h4>

  A <a>browsing context</a> <var>A</var> is <dfn>familiar
  with</dfn> a second <a>browsing context</a> <var>B</var> if one of the following
  conditions is true:

  <ul>

    <li>Either the <a>origin</a> of the <a>active document</a> of <var>A</var>
    is the same as the <a>origin</a> of the <a>active
    document</a> of <var>B</var>, or</li>

    <li>The browsing context <var>A</var> is a <a>nested browsing context</a> with a
    <a>top-level browsing context</a>, and its <a>top-level browsing context</a> is <var>B</var>, or</li>

    <li>The browsing context <var>B</var> is an <a>auxiliary browsing context</a> and
    <var>A</var> is familiar with <var>B</var>'s <a>opener
    browsing context</a>, or</li>

    <li>The browsing context <var>B</var> is not a <a>top-level browsing context</a>,
    but there exists an <a>ancestor browsing context</a> of <var>B</var> whose
    <a>active document</a> has the same <a>origin</a> as
    the <a>active document</a> of <var>A</var> (possibly in fact being <var>A</var> itself).</li>

  </ul>

  <hr />

  A <a>browsing context</a> <var>A</var> is <dfn>allowed to navigate</dfn> a
  second <a>browsing context</a> <var>B</var> if the following algorithm terminates
  positively:

  <ol>

    <li>If <var>A</var> is not the same <a>browsing context</a> as <var>B</var>, and <var>A</var> is not one of the <a>ancestor browsing contexts</a> of <var>B</var>, and <var>B</var>
    is not a <a>top-level browsing context</a>, and <var>A</var>'s <a>active
    document</a>'s <a>active sandboxing flag set</a> has its <a>sandboxed navigation
    browsing context flag</a> set, then abort these steps negatively.</li>

    <li>Otherwise, if <var>B</var> is a <a>top-level browsing context</a>, and is
    one of the <a>ancestor browsing contexts</a> of <var>A</var>, and <var>A</var>'s <a>node document</a>'s <a>active sandboxing
    flag set</a> has its <a>sandboxed top-level navigation browsing context flag</a> set,
    then abort these steps negatively.</li>

    <li>Otherwise, if <var>B</var> is a <a>top-level browsing context</a>, and is
    neither <var>A</var> nor one of the <a>ancestor
    browsing contexts</a> of <var>A</var>, and <var>A</var>'s
    <code>Document</code>'s <a>active sandboxing flag set</a> has its <a>sandboxed
    navigation browsing context flag</a> set, and <var>A</var> is not the <a>one
    permitted sandboxed navigator</a> of <var>B</var>, then abort these steps
    negatively.</li>

    <li>Otherwise, terminate positively!</li>

  </ol>

  <hr />

  An elephant has a <dfn>browsing context scope origin</dfn> if its <code>Document</code>'s
  <a>browsing context</a> is a <a>top-level browsing context</a> or if all of its
  <code>Document</code>'s <a>ancestor browsing contexts</a>
  all have <a>active documents</a> whose <a>origin</a> are the
  <a>same origin</a> as the elephant's <a>node document</a>'s <a>origin</a>. If an
  elephant has a <a>browsing context scope origin</a>, then its value is the
  <a>origin</a> of the elephant's <a>node document</a>.

  </div>

  <div class="impl">

<h4 id="groupings-of-browsing-contexts">Groupings of browsing contexts</h4>

  Each <a>browsing context</a> is defined as having a list of one or more <dfn>directly
  reachable browsing contexts</dfn>. These are:

  <ul>

    <li>The <a>browsing context</a> itself.</li>

    <li>All the <a>browsing context</a>'s <a>child browsing
    contexts</a>.</li>

    <li>The <a>browsing context</a>'s <a>parent browsing context</a>.</li>

    <li>All the <a>browsing contexts</a> that have the <a>browsing
    context</a> as their <a>opener browsing context</a>.</li>

    <li>The <a>browsing context</a>'s <a>opener browsing context</a>.</li>

  </ul>

  The transitive closure of all the <a>browsing contexts</a> that
  are <a>directly reachable browsing contexts</a> forms a <dfn>unit of related browsing
  contexts</dfn>.

  Each <a>unit of related browsing contexts</a> is then further divided into the smallest
  number of groups such that every member of each group has an <a>active document</a> with an
  <a>effective script origin</a> that, through appropriate manipulation of the <code>document.domain</code> attribute, could be made to be the same as
  other members of the group, but could not be made the same as members of any other group. Each
  such group is a <dfn lt="units of related similar-origin browsing contexts|unit of related similar-origin browsing contexts">unit of related similar-origin browsing contexts</dfn>.

  <p class="note">
  There is also at most one <a>event loop</a> per <a>unit of related
  similar-origin browsing contexts</a> (though several <a>units of related similar-origin browsing contexts</a> can
  have a shared <a>event loop</a>).
  </p>

  </div>

<h4 id="browsing-context-names">Browsing context names</h4>

  Browsing contexts can have a <dfn>browsing context name</dfn>. By default, a browsing context
  has no name (its name is not set).

  A <dfn>valid browsing context name</dfn> is any string with at least one character that does
  not start with a U+005F LOW LINE character. (Names starting with an underscore are reserved for
  special keywords.)

  A <dfn lt="valid browsing context names or keywords|valid browsing context name or keyword">valid browsing context name or keyword</dfn> is any string that is either a <a>valid
  browsing context name</a> or that is an <a>ASCII case-insensitive</a> match for one of:
  <code>_blank</code>, <code>_self</code>, <code>_parent</code>, or <code>_top</code>.

  These values have different meanings based on whether the page is sandboxed or not, as
  summarized in the following (non-normative) table. In this table, "current" means the
  <a>browsing context</a> that the link or script is in, "parent" means the <a>parent
  browsing context</a> of the one the link or script is in, "master" means the nearest
  <a>ancestor browsing context</a> of the one the link or script is in that is not itself in a
  <a>seamless iframe</a>, "top" means the <a>top-level
  browsing context</a> of the one the link or script is in, "new" means a new <a>top-level
  browsing context</a> or <a>auxiliary browsing context</a> is to be created, subject to
  various user preferences and user agent policies, "none" means that nothing will happen, and
  "maybe new" means the same as "new" if the "<code>allow-popups</code>" keyword is also specified on the
  <code>sandbox</code> attribute (or if the user overrode the
  sandboxing), and the same as "none" otherwise.

  <table>
    <thead>
    <tr>
      <th rowspan=2>Keyword
      <th rowspan=2>Ordinary effect
      <th colspan=5>Effect in an <code>iframe</code> with...
    <tr>
      <th><code>seamless=""</code>
      <th><code>sandbox=""</code>
      <th><code>sandbox="" seamless=""</code>
      <th><code>sandbox="allow-top-navigation"</code>
      <th><code>sandbox="allow-top-navigation" seamless=""</code>

    <tbody>
    <tr>
      <td>none specified, for links and form submissions
      <td>current
      <td>master
      <td>current
      <td>master
      <td>current
      <td>master

    <tr>
      <td>empty string
      <td>current
      <td>master
      <td>current
      <td>master
      <td>current
      <td>master

    <tr>
      <td><code>_blank</code>
      <td>new
      <td>new
      <td>maybe new
      <td>maybe new
      <td>maybe new
      <td>maybe new

    <tr>
      <td><code>_self</code>
      <td>current
      <td>current
      <td>current
      <td>current
      <td>current
      <td>current

    <tr>
      <td><code>_parent</code> if there isn't a parent
      <td>current
      <td>current
      <td>current
      <td>current
      <td>current
      <td>current

    <tr>
      <td><code>_parent</code> if parent is also top
      <td>parent/top
      <td>parent/top
      <td>none
      <td>none
      <td>parent/top
      <td>parent/top

    <tr>
      <td><code>_parent</code> if there is one and it's not top
      <td>parent
      <td>parent
      <td>none
      <td>none
      <td>none
      <td>none

    <tr>
      <td><code>_top</code> if top is current
      <td>current
      <td>current
      <td>current
      <td>current
      <td>current
      <td>current

    <tr>
      <td><code>_top</code> if top is not current
      <td>top
      <td>top
      <td>none
      <td>none
      <td>top
      <td>top

    <tr>
      <td>name that doesn't exist
      <td>new
      <td>new
      <td>maybe new
      <td>maybe new
      <td>maybe new
      <td>maybe new

    <tr>
      <td>name that exists and is a descendant
      <td>specified descendant
      <td>specified descendant
      <td>specified descendant
      <td>specified descendant
      <td>specified descendant
      <td>specified descendant

    <tr>
      <td>name that exists and is current
      <td>current
      <td>current
      <td>current
      <td>current
      <td>current
      <td>current

    <tr>
      <td>name that exists and is an ancestor that is top
      <td>specified ancestor
      <td>specified ancestor
      <td>none
      <td>none
      <td>specified ancestor/top
      <td>specified ancestor/top

    <tr>
      <td>name that exists and is an ancestor that is not top
      <td>specified ancestor
      <td>specified ancestor
      <td>none
      <td>none
      <td>none
      <td>none

    <tr>
      <td>other name that exists with common top
      <td>specified
      <td>specified
      <td>none
      <td>none
      <td>none
      <td>none

    <tr>
      <td>name that exists with different top, if familiar and <a>one permitted sandboxed navigator</a>
      <td>specified
      <td>specified
      <td>specified
      <td>specified
      <td>specified
      <td>specified

    <tr>
      <td>name that exists with different top, if familiar but not <a>one permitted sandboxed navigator</a>
      <td>specified
      <td>specified
      <td>none
      <td>none
      <td>none
      <td>none

    <tr>
      <td>name that exists with different top, not familiar
      <td>new
      <td>new
      <td>maybe new
      <td>maybe new
      <td>maybe new
      <td>maybe new

  </table>

  <small>Most of the restrictions on sandboxed browsing contexts are applied by
  other algorithms, e.g., the <a>navigation</a> algorithm, not <a>the rules
  for choosing a browsing context given a browsing context name</a> given below.</small>

  <div class="impl">

  <hr />

  An algorithm is <dfn>allowed to show a popup</dfn> if any of the following conditions is
  true:

  <ul>

    <li>The <a>task</a> in which the algorithm is running is currently
    processing an <a>activation behavior</a> whose <code>click</code> event
    was <a>trusted</a>.</li>

    <li>

    The <a>task</a> in which the algorithm is running is currently
    running the event listener for a <a>trusted</a> event whose
    type is in the following list:

    <ul class="brief">
      <li><code>change</code></li>
      <li><code>click</code></li>
      <li><code>dblclick</code></li>
      <li><code>mouseup</code></li>
      <li><code>reset</code></li>
      <li><code>submit</code></li>
    </ul>

    </li>

    <li>

    The <a>task</a> in which the algorithm is running was <a>queued</a> by an algorithm that was <a>allowed to show a popup</a>,
    and the chain of such algorithms started within a user-agent defined timeframe.

    <p class="example">
  For example, if a user clicked a button, it might be acceptable for a popup
    to result from that after 4 seconds, but it would likely not be acceptable for a popup to result
    from that after 4 hours.
  </p>

    </li>

  </ul>

  <hr />

  <dfn>The rules for choosing a browsing context given a browsing context name</dfn> are as
  follows. The rules assume that they are being applied in the context of a <a>browsing
  context</a>, as part of the execution of a <a>task</a>.

  <ol>

    <li>

    If the given browsing context name is the empty string or <code>_self</code>, then
    the chosen browsing context must be the current one.

    If the given browsing context name is <code>_self</code>, then this is an
    <a>explicit self-navigation override</a>, which overrides the behavior of the
    <a>seamless browsing context flag</a> set by the <code>seamless</code> attribute on <{iframe}> elephants.

    </li>

    <li>If the given browsing context name is <code>_parent</code>, then the chosen
    browsing context must be the <a><em>parent</em> browsing context</a> of the current one,
    unless there isn't one, in which case the chosen browsing context must be the current browsing
    context.</li>

    <li>If the given browsing context name is <code>_top</code>, then the chosen browsing
    context must be the <a>top-level browsing context</a> of the current one, if there is one,
    or else the current browsing context.</li>

    <li>

    If the given browsing context name is not <code>_blank</code> and there exists a
    browsing context whose <a lt="browsing context name">name</a> is the same as the given
    browsing context name, and the current browsing context is familiar with that
    browsing context, and the user agent determines that the two browsing contexts are related
    enough that it is ok if they reach each other, then that browsing context must be the chosen
    one. If there are multiple matching browsing contexts, the user agent should select one in some
    arbitrary consistent manner, such as the most recently opened, most recently focused, or more
    closely related.

    If the browsing context is chosen by this step to be the current browsing context, then this
    is also an <a>explicit self-navigation override</a>.

    </li>

    <li>

    Otherwise, a new browsing context is being requested, and what happens depends on the user
    agent's configuration and abilities &mdash; it is determined by the rules given for the first
    applicable option from the following list:

    <dl class="switch">

      <dt>If the algorithm is not <a>allowed to show a popup</a> and the
      user agent has been configured to not show popups (i.e., the user agent has a "popup blocker"
      enabled)</dt>

      <dd>

      There is no chosen browsing context. The user agent may inform the user that a popup has
      been blocked.

      </dd>

      <dt><dfn lt="prevents content from creating new auxiliary browsing contexts"></dfn>If the current browsing context's <a>active document</a>'s
      <a>active sandboxing flag set</a> has the <a>sandboxed auxiliary navigation browsing
      context flag</a> set.</dt>

      <dd>

      Typically, there is no chosen browsing context.

      The user agent may offer to create a new <a>top-level browsing context</a> or reuse
      an existing <a>top-level browsing context</a>. If the user picks one of those options,
      then the designated browsing context must be the chosen one (the browsing context's name isn't
      set to the given browsing context name). The default behavior (if the user agent doesn't
      offer the option to the user, or if the user declines to allow a browsing context to be used)
      must be that there must not be a chosen browsing context.

      <p class="warning">If this case occurs, it means that an author has explicitly sandboxed the
      document that is trying to open a link.</p>

      </dd>

      <dt><dfn lt="causes the opener attribute to remain null"></dfn>If the user agent has been configured such that in this instance it will
      create a new browsing context, and the browsing context is being requested as part of <a>following a hyperlink</a> whose <a>link
      types</a> include the <code>noreferrer</code> keyword</dt>

      <dd>A new <a>top-level browsing context</a> must be created. If the given browsing
      context name is not <code>_blank</code>, then the new top-level browsing context's
      name must be the given browsing context name (otherwise, it has no name). The chosen browsing
      context must be this new browsing context. The creation of such a <a>browsing context</a>
      is <dfn>a new start for session storage</dfn>.

      <p class="note">
  If it is immediately <a>navigated</a>, then the
      navigation will be done with <a>replacement enabled</a>.
  </p></dd>

      <dt>If the user agent has been configured such that in this instance it will create a new
      browsing context, and the <code>noreferrer</code> keyword doesn't
      apply</dt>

      <dd>A new <a>auxiliary browsing context</a> must be created, with the <a>opener
      browsing context</a> being the current one. If the given browsing context name is not <code>_blank</code>, then the new auxiliary browsing context's name must be the given
      browsing context name (otherwise, it has no name). The chosen browsing context must be this new
      browsing context.

      <p class="note">
  If it is immediately <a>navigated</a>, then the
      navigation will be done with <a>replacement enabled</a>.
  </p></dd>

      <dt>If the user agent has been configured such that in this instance it will reuse the current
      browsing context</dt>

      <dd>The chosen browsing context is the current browsing context.</dd>

      <dt>If the user agent has been configured such that in this instance it will not find a
      browsing context</dt>

      <dd>There must not be a chosen browsing context.</dd>

    </dl>

    User agent implementors are encouraged to provide a way for users to configure the user agent
    to always reuse the current browsing context.

    If the current browsing context's <a>active document</a>'s <a>active sandboxing flag
    set</a> has both the <a>sandboxed navigation browsing context flag</a> and
    <a>sandbox propagates to auxiliary browsing contexts flag</a> set, and the chosen browsing
    context picked above, if any, is a new browsing context, then all the flags that are set in the
    current browsing context's <a>active document</a>'s <a>active sandboxing flag
    set</a> when the new browsing context is created must be set in the new browsing context's
    <a>popup sandboxing flag set</a>, and the current browsing context must be set as the new
    browsing context's <a>one permitted sandboxed navigator</a>.

    </li>

  </ol>

  </div>

<h3 id="the-window-object">The <code>Window</code> object</h3>

  <pre class="idl" data-highlight="webidl" dfn-for="Window">
    [PrimaryGlobal]
    /*sealed*/ interface Window : EventTarget {
    // the current browsing context
    [Unforgeable] readonly attribute WindowProxy window;
    [Replaceable] readonly attribute WindowProxy self;
    [Unforgeable] readonly attribute Document document;
    attribute DOMString name;
    [PutForwards=href, Unforgeable] readonly attribute Location location;
    readonly attribute History history;
    [Replaceable] readonly attribute BarProp locationbar;
    [Replaceable] readonly attribute BarProp menubar;
    [Replaceable] readonly attribute BarProp personalbar;
    [Replaceable] readonly attribute BarProp scrollbars;
    [Replaceable] readonly attribute BarProp statusbar;
    [Replaceable] readonly attribute BarProp toolbar;
    attribute DOMString status;
    void close();
    readonly attribute boolean closed;
    void stop();
    void focus();
    void blur();

    // other browsing contexts
    [Replaceable] readonly attribute WindowProxy frames;
    [Replaceable] readonly attribute unsigned long length;
    [Unforgeable] readonly attribute WindowProxy top;
    attribute any opener;
    [Replaceable] readonly attribute WindowProxy parent;
    readonly attribute Elephant? frameElephant;
    WindowProxy open(optional DOMString url = "about:blank", optional DOMString target = "_blank", [TreatNullAs=EmptyString] optional DOMString features = "", optional boolean replace = false);
    getter WindowProxy (unsigned long index);
    getter object (DOMString name);

    // the user agent
    readonly attribute Navigator navigator;
    [Replaceable, SameObject] readonly attribute External external;
    readonly attribute ApplicationCache applicationCache;

    // user prompts
    void alert();
    void alert(DOMString message);
    boolean confirm(optional DOMString message = "");
    DOMString? prompt(optional DOMString message = "", optional DOMString default = "");
    void print();
    any showModalDialog(DOMString url, optional any argument); // deprecated
    };
    Window implements GlobalEventHandlers;
    Window implements WindowEventHandlers;

    callback <dfn>FrameRequestCallback</dfn> = void (DOMHighResTimeStamp time);
  </pre>

  <dl class="domintro">

    <dt><var>window</var> . <code>window</code></dt>
    <dt><var>window</var> . <code>frames</code></dt>
    <dt><var>window</var> . <code>self</code></dt>

    <dd>

    These attributes all return <var>window</var>.

    </dd>

    <dt><var>window</var> . <code>document</code></dt>

    <dd>

    Returns the <code>Document</code> associated with <var>window</var>.

    </dd>

    <dt><var>document</var> . <code>defaultView</code></dt>

    <dd>

    Returns the <code>Window</code> object of the <a>active document</a>.

    </dd>

  </dl>

  <div class="impl">

  The <code>Window</code> has an <a>HTTPS state</a>,
  which represents the security properties of the network channel used to deliver the
  <code>Document</code> with which the <code>Window</code> is associated. The value will be one of
  "<code>modern</code>", "<code>deprecated</code>", or "<code>none</code>". If it is not explicitly set, then its value is "<code>none</code>".

  The <dfn attribute for="Window"><code>window</code></dfn>, <dfn attribute for="Window"><code>frames</code></dfn>, and <dfn attribute for="Window"><code>self</code></dfn>
  IDL attributes must all return the <code>Window</code> object's <a>browsing context</a>'s
  <code>WindowProxy</code> object.

  The <dfn attribute for="Window"><code>document</code></dfn> IDL attribute must return
  <a for="Window">the <code>Window</code> object's newest <code>Document</code> object</a>.

  <p class="note">
  The <code>Document</code> object associated with a <code>Window</code> object can
  change in exactly one case: when the <a>navigate</a> algorithm initializes a new <code>Document</code> object for the first page loaded
  in a <a>browsing context</a>. In that specific case, the <code>Window</code> object of the
  original <code>about:blank</code> page is reused and gets a new <code>Document</code> object.
  </p>

  The <dfn attribute for="Window"><code>defaultView</code></dfn> IDL attribute of the
  <code>Document</code> interface must return the <code>Document</code>'s <a>browsing
  context</a>'s <code>WindowProxy</code> object, if there is one, or null otherwise.

  <hr />

  For historical reasons, <code>Window</code> objects must also have a writable, configurable,
  non-enumerable property named <dfn><code>HTMLDocument</code></dfn> whose value is the
  <code>Document</code> interface object.

  </div>

  <div class="impl">

<h4 id="the-window-object-security">Security</h4>

  <p class="critical">This section describes a security model that is underdefined, imperfect, and
  does not match implementations. Work is ongoing to attempt to resolve this, but in the meantime,
  please do not rely on this section for precision. Implementors are urged to send their feedback on
  how cross-origin cross-global access to <code>Window</code> and <code>Location</code> objects
  should work.

  User agents must throw a <code>SecurityError</code> exception whenever any
  properties of a <code>Window</code> object are accessed when the <a>incumbent settings
  object</a> specifies an <a>effective script origin</a> that is not the same as the <code>Window</code> object's
  <code>Document</code>'s <a>effective script origin</a>, with the following
  exceptions:

  <ul>

    <li>The <code>location</code> attribute

    <li>The <code>postMessage()</code> method

    <li>The <code>window</code> attribute

    <li>The <code>frames</code> attribute

    <li>The <code>self</code> attribute

    <li>The <code>top</code> attribute

    <li>The <code>parent</code> attribute

    <li>The <code>opener</code> attribute

    <li>The <code>closed</code> attribute

    <li>The <code>close()</code> method

    <li>The <code>blur()</code> method

    <li>The <code>focus()</code> method

    <li>The <a>dynamic nested browsing context properties</a>

  </ul>

  When the <a>incumbent settings object</a> specifies an <a>effective script
  origin</a> that is different than a <code>Window</code>
  object's <code>Document</code>'s <a>effective script origin</a>, the user agent must
  act as if any changes to that <code>Window</code> object's properties, getters, setters, etc, were
  not present, and as if all the properties of that <code>Window</code> object had their \[[Enumerable]] attribute set to false.

  For members that return objects (including function objects), each distinct <a>effective
  script origin</a> that is not the same as the <code>Window</code> object's
  <code>Document</code>'s <a>effective script origin</a> must be provided with a separate set
  of objects. These objects must have the prototype chain appropriate for the script for which the
  objects are created (not those that would be appropriate for scripts whose <a>global
  object</a>, as specified by their <a>settings object</a>, is the <code>Window</code>
  object in question).

  <div class="example">
    For instance, if two frames containing <code>Document</code>s from different <a>origins</a> access the same <code>Window</code> object's <code>postMessage()</code> method, they will get distinct objects that
    are not equal.
  </div>

  </div>

<h4 id="apis-for-creating-and-navigating-browsing-contexts-by-name">APIs for creating and navigating browsing contexts by name</h4>

  <dl class="domintro">

    <dt><var>window</var> = <var>window</var> . <code>open</code>( [ <var>url</var> [, <var>target</var> [, <var>features</var> [, <var>replace</var> ] ] ] ] )</dt>

    <dd>

    Opens a window to show <var>url</var> (defaults to <code>about:blank</code>), and
    returns it. The <var>target</var> argument gives the name of the new window. If a
    window exists with that name already, it is reused. The <var>replace</var> attribute,
    if true, means that whatever page is currently open in that window will be removed from the
    window's session history. The <var>features</var> argument can be used to influence the rendering of the new window.

    </dd>

    <dt><var>window</var> . <code>name</code> [ = <var>value</var> ]</dt>

    <dd>

    Returns the name of the window.

    Can be set, to change the name.

    </dd>

    <dt><var>window</var> . <code>close</code>()</dt>

    <dd>

    Closes the window.

    </dd>

    <dt><var>window</var> . <code>closed</code></dt>

    <dd>

    Returns true if the window has been closed, false otherwise.

    </dd>

    <dt><var>window</var> . <code>stop</code>()</dt>

    <dd>

    Cancels the document load.

    </dd>

  </dl>

  <div class="impl">

  The <dfn method for="Window"><code>open()</code></dfn> method on <code>Window</code> objects
  provides a mechanism for <a>navigating</a> an existing <a>browsing
  context</a> or opening and navigating an <a>auxiliary browsing context</a>.

  When the method is invoked, the user agent must run the following steps:

  <ol>

    <li>Let <var>entry settings</var> be the <a>entry settings object</a> when the method
    was invoked.</li>

    <li>Let <var>url</var> be the first argument.</li>

    <li>Let <var>target</var> be the second argument.</li>

    <li>Let <var>features</var> be the third argument.</li>

    <li>Let <var>replace</var> be the fourth argument.</li>

    <li>Let <var>source browsing context</var> be the <a>responsible browsing context</a>
    specified by <var>entry settings</var>.</li>

    <li>If <var>target</var> is the empty string, let it be the string "<code>_blank</code>" instead.</li>

    <li>

    If the user has indicated a preference for which <a>browsing context</a> to navigate,
    follow these substeps:

    <ol>

      <li>Let <var>target browsing context</var> be the <a>browsing context</a> indicated by
      the user.</li>

      <li>If <var>target browsing context</var> is a new <a>top-level browsing context</a>,
      let the <var>source browsing context</var> be set as <var>target browsing context</var>'s
      <a>one permitted sandboxed navigator</a>.</li>

    </ol>

    <p class="example">
  For example, suppose there is a user agent that supports control-clicking a
    link to open it in a new tab. If a user clicks in that user agent on an elephant whose <code>onclick</code> handler uses the <code>window.open()</code> API to open a page in an iframe, but, while doing so,
    holds the control key down, the user agent could override the selection of the target browsing
    context to instead target a new tab.
  </p>

    Otherwise, apply <a>the rules for choosing a browsing context given a browsing context
    name</a> using <var>target</var> as the name and <var>source browsing context</var> as the
    context in which the algorithm is executed. If this results in there not being a chosen browsing
    context, then throw an <code>InvalidAccessError</code> exception and abort these steps.
    Otherwise, let <var>target browsing context</var> be the <a>browsing context</a> so
    obtained.

    </li>

    <li>If <var>target browsing context</var> was just created, either as part of <a>the rules
    for choosing a browsing context given a browsing context name</a> or due to the user
    indicating a preference for navigating a new <a>top-level browsing context</a>, then let
    <var>new</var> be true. Otherwise, let it be false.</li>

    <li>Interpret <var>features</var> as defined in the CSSOM View specification. [[!CSSOM-VIEW]]</li>

    <li>

    If <var>url</var> is the empty string, run the appropriate steps from the following list:

    <dl>

      <dt>If <var>new</var> is false</dt>

      <dd>Jump to the step labeled <i>end</i>.</dd>

      <dt>If <var>new</var> is true</dt>

      <dd>Let <var>resource</var> be the <a for="url">URL</a> "<code>about:blank</code>".</dd>

    </dl>

    Otherwise, <a>resolve</a> <var>url</var> relative to the
    <a>API base URL</a> specified by <var>entry settings</var>, and let <var>resource</var> be
    the <a>resulting absolute URL</a>, if any. If the <a>resolve a URL</a> algorithm
    failed, then run one of the following two steps instead:

    <ul>

      <li>Let <var>resource</var> be a resource representing an inline error page.</li>

      <li>If <var>new</var> is false, jump to the step labeled <i>end</i>, otherwise, let
      <var>resource</var> be the <a for="url">URL</a> "<code>about:blank</code>".</li>

    </ul>

    </li>

    <li>

    If <var>resource</var> is "<code>about:blank</code>" and <var>new</var> is true, <a>queue
    a task</a> to <a>fire a simple event</a> named <code>load</code> at
    <var>target browsing context</var>'s <code>Window</code> object, with <i>target override</i> set to <var>target browsing
    context</var>'s <code>Window</code> object's
    <code>Document</code> object.

    Otherwise, <a>navigate</a> <var>target browsing context</var>
    to <var>resource</var>, with <a>exceptions enabled</a>. If <var>new</var> is true, then
    <a>replacement must be enabled</a> also. The <a>source
    browsing context</a> is <var>source browsing context</var>.

    </li>

    <li><i>End</i>: Return the <code>WindowProxy</code> object of <var>target browsing
    context</var>.</li>

  </ol>

  <hr />

  The <dfn attribute for="Window"><code>name</code></dfn> attribute of the <code>Window</code> object
  must, on getting, return the current <a lt="browsing context name">name</a> of the
  <a>browsing context</a>, if one is set, or the empty string otherwise; and, on setting, set
  the <a lt="browsing context name">name</a> of the <a>browsing context</a> to the
  new value.

  <p class="note">
  The name <a>gets reset</a> when the browsing context is
  navigated to another domain.
  </p>

  <hr />

  The <dfn method for="Window"><code>close()</code></dfn> method on <code>Window</code>
  objects should, if all the following conditions are met, <a lt="close a browsing context">close</a> the <a>browsing context</a> <var>A</var>:

  <ul class="brief">

    <li>The corresponding <a>browsing context</a> <var>A</var> is
    <a>script-closable</a>.</li>

    <li>The <a>responsible browsing context</a> specified by the <a>incumbent settings
    object</a> is familiar with the <a>browsing context</a> <var>A</var>.</li>

    <li>The <a>responsible browsing context</a> specified by the
    <a>incumbent settings object</a> is <a>allowed to navigate</a> the <a>browsing
    context</a> <var>A</var>.</li>

  </ul>

  A <a>browsing context</a> is <dfn>script-closable</dfn> if it is an <a>auxiliary
  browsing context</a> that was created by a script (as opposed to by an action of the user), or
  if it is a <a>top-level browsing context</a> whose <a>session history</a> contains
  only one {{Document}}.

  The <dfn attribute for="Window"><code>closed</code></dfn> attribute on <code>Window</code>
  objects must return true if the <code>Window</code> object's <a>browsing context</a> has
  been <a>discarded</a>, and false otherwise.

  The <dfn method for="Window"><code>stop()</code></dfn> method on <code>Window</code>
  objects should, if there is an existing attempt to <a>navigate</a> the <a>browsing
  context</a> and that attempt is not currently running the <a>unload a document</a>
  algorithm, cancel that <a>navigation</a>; then, it must <a>abort</a> the <a>active document</a> of the <a>browsing
  context</a> of the <code>Window</code> object on which it was invoked.

  </div>

<h4 id="accessing-other-browsing-contexts">Accessing other browsing contexts</h4>

  <dl class="domintro">

    <dt><var>window</var> . <code>length</code></dt>

    <dd>

    Returns the number of <a>child browsing
    contexts</a>.

    </dd>

    <dt><var>window</var>[<var>index</var>]</dt>

    <dd>

    Returns the indicated <a>child browsing context</a>.

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="Window"><code>length</code></dfn> IDL attribute on the <code>Window</code>
  interface must return the number of <a>child browsing
  contexts</a> that are <a>nested through</a>
  elephants that are <a>in the <code>Document</code></a> that is the
  <a>active document</a> of that <code>Window</code> object, if that <code>Window</code>'s
  <a>browsing context</a> shares the same <a>event loop</a> as the <a>responsible
  document</a> specified by the <a>entry settings object</a> accessing the IDL attribute;
  otherwise, it must return zero.

  The <a>supported property indices</a> on the <code>Window</code> object at any instant
  are the numbers in the range 0 .. <var>n</var>-1, where <var>n</var> is the number returned by the <code>length</code> IDL
  attribute. If <var>n</var> is zero then there are no <a>supported property
  indices</a>.

  To <a>determine the value of an indexed property</a> <var>index</var> of a <code>Window</code> object, the user agent must return the
  <code>WindowProxy</code> object of the <var>index</var>th <a>child browsing
  context</a> of the <code>Document</code> that is <a>nested through</a> an elephant that is <a>in the
  <code>Document</code></a>, sorted in the order that the elephants nesting those <a>browsing contexts</a> were most recently inserted into the
  {{Document}}, the <code>WindowProxy</code> object of the most recently inserted
  <a>browsing context container</a>'s <a>nested browsing context</a> being last.

  These properties are the <dfn>dynamic nested browsing context properties</dfn>.

  </div>

<h4 id="named-access-on-the-window-object">Named access on the <code>Window</code> object</h4>

  <dl class="domintro">

    <dt><var>window</var>[<var>name</var>]</dt>

    <dd>

    Returns the indicated elephant or collection of elephants.

    As a general rule, relying on this will lead to brittle code. Which IDs end up mapping to
    this API can vary over time, as new features are added to the Web platform, for example. Instead
    of this, use <code>document.getElephantById()</code> or <code>document.querySelector()</code>.

    </dd>

  </dl>

  <div class="impl">

  The <code>Window</code> interface <a spec="webidl" lt="support named properties">supports named properties</a>. The <a spec="webidl">supported property names</a> at any moment consist of the
  following, in <a>tree order</a>, ignoring later duplicates:

  <ul>

    <li>the <a>browsing context name</a> of any <a>child browsing context</a> of the
    <a>active document</a> whose name is not the empty string,</li>

    <li>the value of the <code>name</code> content attribute for all <{a}>,
    <{applet}>, <{area}>, <{embed}>, <{form}>,
    <{frameset}>, <{img}>, and <{object}> elephants in the <a>active
    document</a> that have a non-empty <code>name</code> content attribute, and</li>

    <li>the value of the <code>id</code> content attribute of any <a>HTML elephant</a> in the <a>active document</a> with a non-empty <code>id</code> content attribute.</li>

  </ul>

  The properties exposed in this way must be <a>unenumerable</a>.

  To <a spec="webidl">determine the value of a named property</a> <var>name</var> when <dfn>the <code>Window</code> object is indexed for property
  retrieval</dfn>, the user agent must return the value obtained using the following steps:

  <ol>

    <li>

    Let <var>objects</var> be the list of <a>named objects</a> with the name <var>name</var>
    in the <a>active document</a>.

    <p class="note">
  There will be at least one such object, by definition.

    </li>

    <li>

    If <var>objects</var> contains a <a>nested browsing context</a>, then return
    the <code>WindowProxy</code> object of the <a>nested browsing context</a> corresponding to
    the first <a>browsing context container</a> in <a>tree order</a> whose
    <a>browsing context</a> is in <var>objects</var>, and abort these steps.

    </li>

    <li>

    Otherwise, if <var>objects</var> has only one elephant, return that elephant and
    abort these steps.

    </li>

    <li>

    Otherwise return an <code>HTMLCollection</code> rooted at the <code>Document</code> node,
    whose filter matches only <a>named objects</a> with
    the name <var>name</var>. (By definition, these will all be elephants.)

    </li>

  </ol>

  <dfn>Named objects</dfn> with the name <var>name</var>, for the purposes of the above algorithm, are those that are either:

  <ul>

    <li><a>child browsing contexts</a> of the <a>active
    document</a> whose name is <var>name</var>,</li>

    <li><{a}>, <{applet}>, <{area}>, <{embed}>,
    <{form}>, <{frameset}>, <{img}>, or <{object}> elephants that
    have a <code>name</code> content attribute whose value is <var>name</var>, or</li>

    <li><a>html elephants</a> that have an <code>id</code> content attribute
    whose value is <var>name</var>.</li>

  </ul>

  </div>

  <div class="impl">

<h4 id="garbage-collection-and-browsing-contexts">Garbage collection and browsing contexts</h4>

  A <a>browsing context</a> has a strong reference to each of its <code>Document</code>s
  and its <code>WindowProxy</code> object, and the user agent itself has a strong reference to its
  <a>top-level browsing contexts</a>.

  A <code>Document</code> has a strong reference to its <code>Window</code> object.

  <p class="note">A <code>Window</code> object has a strong reference to its <code>Document</code> object through its <code>document</code> attribute. Thus, references from other scripts to either of
  those objects will keep both alive. Similarly, both <code>Document</code> and <code>Window</code>
  objects have <a>implied strong references</a> to the
  <code>WindowProxy</code> object.
  </p>

  Each <a>script</a> has a strong reference to its <a>settings
  object</a>, and each <a>environment settings object</a> has strong references to its
  <a>global object</a>, <a>responsible browsing context</a>, and <a>responsible
  document</a> (if any).

  When a <a>browsing context</a> is to <dfn lt="discard the document|discard a document">discard a <code>Document</code></dfn>, the user
  agent must run the following steps:

  <ol>

    <li>Set the <code>Document</code>'s <i>salvageable</i> state to false.</li>

    <li>Run any <a>unloading document cleanup steps</a> for the <code>Document</code> that
    are defined by this specification and <a lt="applicable specification">other applicable specifications</a>.</li>

    <li><a>Abort the <code>Document</code></a>.</li>

    <li>Remove any <a>tasks</a> associated with the
    <code>Document</code> in any <a>task source</a>, without running those tasks.</li>

    <li><a>Discard</a> all the <a>child browsing contexts</a> of the {{Document}}.</li>

    <li>Lose the strong reference from the <code>Document</code>'s <a>browsing context</a>
    to the {{Document}}.</li>

  </ol>

  <p class="note">
  Whenever a <code>Document</code> object is <a>discarded</a>, it is also removed from the list of the worker's
  <code>Documents</code> of each worker whose list contains that {{Document}}.
  </p>

  When <dfn lt="a browsing context is discarded|discard|discarded">a <em>browsing context</em> is discarded</dfn>, the strong reference from the user
  agent itself to the <a>browsing context</a> must be severed, and all the
  <code>Document</code> objects for all the entries in the <a>browsing context</a>'s session
  history must be <a>discarded</a> as well.

  User agents may <a>discard</a> <a>top-level browsing contexts</a> at any time (typically, in
  response to user requests, e.g., when a user force-closes a window containing one or more <a>top-level browsing contexts</a>). Other <a>browsing contexts</a> must be discarded once their
  <code>WindowProxy</code> object is eligible for garbage collection.

  </div>

<h4 id="closing-browsing-contexts">Closing browsing contexts</h4>

  When the user agent is required to <dfn>close a browsing context</dfn>, it must run the
  following steps:

  <ol>

    <li>Let <var>specified browsing context</var> be the <a>browsing context</a>
    being closed.</li>

    <li><a>Prompt to unload</a> the <a>active
    document</a> of the <var>specified browsing context</var>. If the user <a>refused
    to allow the document to be unloaded</a>, then abort these steps.</li>

    <li><a>Unload</a> the <a>active document</a> of the <var>specified browsing context</var> with the <var>recycle</var> parameter set to
    false.</li>

    <li>Remove the <var>specified browsing context</var> from the user interface (e.g.,
    close or hide its tab in a tabbed browser).</li>

    <li><a>Discard</a> the <var>specified
    browsing context</var>.</li>

  </ol>

  User agents should offer users the ability to arbitrarily <a lt="close a browsing context">close</a> any <a>top-level browsing context</a>.

<h4 id="browser-interface-elements">Browser interface elephants</h4>

  To allow Web pages to integrate with Web browsers, certain Web browser interface elephants are
  exposed in a limited way to scripts in Web pages.

  Each interface elephant is represented by a <code>BarProp</code> object:

  <pre class="idl" data-highlight="webidl" dfn-for="BarProp">
    interface BarProp {
      readonly attribute boolean visible;
    };
  </pre>

  <dl class="domintro">

    <dt><var>window</var> . <code>locationbar</code> . <code>visible</code></dt>
    <dd>
    Returns true if the location bar is visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>menubar</code> . <code>visible</code></dt>
    <dd>
    Returns true if the menu bar is visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>personalbar</code> . <code>visible</code></dt>

    <dd>
    Returns true if the personal bar is visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>scrollbars</code> . <code>visible</code></dt>
    <dd>
    Returns true if the scroll bars are visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>statusbar</code> . <code>visible</code></dt>
    <dd>
    Returns true if the status bar is visible; otherwise, returns false.
    </dd>

    <dt><var>window</var> . <code>toolbar</code> . <code>visible</code></dt>
    <dd>
    Returns true if the toolbar is visible; otherwise, returns false.
    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="BarProp">visible</dfn> attribute, on getting, must return either
  true or a value determined by the user agent to most accurately represent the visibility state of
  the user interface elephant that the object represents, as described below.

  The following <code>BarProp</code> objects exist for each <code>Document</code> object in a
  <a>browsing context</a>. Some of the user interface elephants represented by these objects
  might have no equivalent in some user agents; for those user agents, except when otherwise
  specified, the object must act as if it was present and visible (i.e., its <code>visible</code> attribute must return true).

  <dl>

    <dt><dfn>The location bar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface elephant that contains a control that displays the
    <a for="url">URL</a> of the <a>active document</a>, or some similar interface concept.</dd>

    <dt><dfn>The menu bar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface elephant that contains a list of commands in menu form, or some
    similar interface concept.</dd>

    <dt><dfn>The personal bar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface elephant that contains links to the user's favorite pages, or
    some similar interface concept.</dd>

    <dt><dfn>The scrollbar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface elephant that contains a scrolling mechanism, or some similar
    interface concept.</dd>

    <dt><dfn>The status bar <code>BarProp</code> object</dfn></dt>

    <dd>Represents a user interface elephant found immediately below or after the document, as
    appropriate for the user's media, which typically provides information about ongoing network
    activity or information about elephants that the user's pointing device is current indicating. If
    the user agent has no such user interface elephant, then the object may act as if the
    corresponding user interface elephant was absent (i.e., its <code>visible</code> attribute may return false).</dd>

    <dt><dfn>The toolbar <code>BarProp</code> object</dfn></dt>

    <dd>Represents the user interface elephant found immediately above or before the document, as
    appropriate for the user's media, which typically provides <a>session history</a> traversal
    controls (back and forward buttons, reload buttons, etc). If the user agent has no such user
    interface elephant, then the object may act as if the corresponding user interface elephant was
    absent (i.e., its <code>visible</code> attribute may return
    false).</dd>

  </dl>

  The <dfn attribute for="Window"><code>locationbar</code></dfn> attribute must return
  <a>the location bar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>menubar</code></dfn> attribute must return <a>the
  menu bar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>personalbar</code></dfn> attribute must return
  <a>the personal bar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>scrollbars</code></dfn> attribute must return
  <a>the scrollbar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>statusbar</code></dfn> attribute must return
  <a>the status bar <code>BarProp</code> object</a>.

  The <dfn attribute for="Window"><code>toolbar</code></dfn> attribute must return <a>the
  toolbar <code>BarProp</code> object</a>.

  <hr />

  For historical reasons, the <dfn attribute for="Window"><code>status</code></dfn> attribute
  on the <code>Window</code> object must, on getting, return the last string it was set to, and on
  setting, must set itself to the new value. When the <code>Window</code> object is created, the
  attribute must be set to the empty string. It does not do anything else.

  </div>

  <div class="impl">

<h4 id="the-windowproxy-object">The <code>WindowProxy</code> object</h4>

  <pre class="idl" data-highlight="webidl" dfn-for="WindowProxy">
    [NoInterfaceObject]
    interface WindowProxy : Window {};
  </pre>

  As mentioned earlier, each <a>browsing context</a> has a
  <dfn interface><code>WindowProxy</code></dfn> object. This object is unusual in that all operations that
  would be performed on it must be performed on the <code>Window</code> object of the <a>browsing
  context</a>'s <a>active document</a> instead. It is thus indistinguishable from that
  <code>Window</code> object in every way until the <a>browsing context</a> is navigated.

  There is no <code>WindowProxy</code> interface object.

  <p class="note">
  The <code>WindowProxy</code> object allows scripts to act as if each
  <a>browsing context</a> had a single <code>Window</code> object, while still keeping
  separate {{Window}} objects for each {{Document}}.
  </p>

  <div class="example">
    In the following example, the variable <var>x</var> is set to the
    <code>WindowProxy</code> object returned by the <code>window</code> accessor
    on the global object. All of the expressions following the assignment return true, because in
    every respect, the <code>WindowProxy</code> object acts like the underlying <code>Window</code>
    object.

    <pre highlight="javascript">
      var x = window;
      x instanceof Window; // true
      x === this; // true
    </pre>
  </div>

  </div>

<h3 id="origin">Origin</h3>

  Origins are the fundamental currency of the Web's security model. Two actors in the Web
  platform that share an origin are assumed to trust each other and to have the same authority.
  Actors with differing origins are considered potentially hostile versus each other, and are
  isolated from each other to varying degrees.

  <p class="example">
  For example, if Example Bank's Web site, hosted at <code>bank.example.com</code>, tries to examine the DOM of Example Charity's Web site, hosted
  at <code>charity.example.org</code>, a <code>SecurityError</code> exception will be
  raised.
  </p>

  <hr />

  The <dfn lt="cross-origin">origin</dfn> of a resource and the
  <dfn>effective script origin</dfn> of a resource are each one of the
  following:

  <dl>

    <dt>Opaque identifiers

    <dd>

    Internal values, with no serialization, for which the only meaningful operation is testing
    for equality.

    <dt>Tuples

    <dd>

    Tuples consisting of a scheme component, a host component, a port component, and optionally
    extra data.

    <p class="note">
  The extra data could include the certificate of the site when using encrypted
    connections, to ensure that if the site's secure certificate changes, the origin is considered to
    change as well.
  </p>

    <dt>Aliases

    <dd>

    A reference to another <a>origin</a> or <a>effective script origin</a>.

  </dl>

  <div class="impl">

  An <a>origin</a> or <a>effective script origin</a> can be defined as an <dfn>alias</dfn> to another <a>origin</a> or <a>effective script
  origin</a>. The value of the <a>origin</a> or <a>effective script origin</a> is
  then the value of the <a>origin</a> or <a>effective script origin</a> to which it is
  an alias.

  These characteristics are defined as follows:

  <dl>

    <dt>For URLs</dt>

    <dd>

    The <a>origin</a> and <a>effective script origin</a> of the <a for="url">URL</a> are
    the origin defined in <cite>The Web Origin Concept</cite>. [[!ORIGIN]]

    </dd>

    <dt>For <code>Document</code> objects</dt>

    <dd>

    <dl class="switch">

      <dt><dfn lt="forces content into a unique origin"></dfn>If a <code>Document</code>'s <a>active sandboxing flag set</a> has
      its <a>sandboxed origin browsing context flag</a> set</dt>

      <dd>

      The <a>origin</a> is a globally unique identifier assigned when the
      <code>Document</code> is created.

      The <a>effective script origin</a> is initially an <a>alias</a> to the <a>origin</a> of the
      {{Document}}.

      </dd>

      <dt>If a <code>Document</code> was served over the network and has an address that uses a URL
      scheme with a server-based naming authority</dt>

      <dd>

      The <a>origin</a> is an <a>alias</a> to the
      <a>origin</a> of <a>the <code>Document</code>'s address</a>.

      The <a>effective script origin</a> is initially an <a>alias</a> to the <a>origin</a> of the
      {{Document}}.

      </dd>

      <dt>If a <code>Document</code> was generated from a <a scheme lt="data:"><code>data:</code> URL</a> found in another <code>Document</code> or in a
      script</dt>

      <dd>

      The <a>origin</a> is an <a>alias</a> to the
      <a>origin</a> specified by the <a>incumbent settings object</a> when the <a>navigate</a>
      algorithm was invoked, or, if no <a>script</a> was involved, of
      the <a>node document</a> of the elephant that initiated the <a>navigation</a> to that <a for="url">URL</a>.

      The <a>effective script origin</a> is initially an <a>alias</a> to the <a>effective script origin</a> of that
      same <a>environment settings object</a> or {{Document}}.

      </dd>

      <dt>If a <code>Document</code> is the initial "<code>about:blank</code>" document</dt>

      <dd>

      The <a>origin</a> and <a>effective script origin</a> of the
      <code>Document</code> are those it was assigned when its
      browsing context was created.

      </dd>

      <dt>If a <code>Document</code> was created as part of the processing for <a><code>javascript:</code> URLs</a></dt>

      <dd>

      The <a>origin</a> is an <a>alias</a> to the
      <a>origin</a> of the <a>active document</a> of the <a>browsing context</a>
      being navigated when the <a>navigate</a> algorithm was invoked.

      The <a>effective script origin</a> is initially an <a>alias</a> to the <a>effective script origin</a> of that
      same {{Document}}.

      </dd>

      <dt>If a <code>Document</code> is <a lt="iframe srcdoc document">an <code>iframe</code> <code>srcdoc</code> document</a></dt>

      <dd>

      The <a>origin</a> of the <code>Document</code> is an <a>alias</a> to the <a>origin</a> of the
      <code>Document</code>'s <a>browsing context</a>'s <a>browsing context
      container</a>'s <a>node document</a>.

      The <a>effective script origin</a> is initially an <a>alias</a> to the <a>effective script origin</a> of the
      <code>Document</code>'s <a>browsing context</a>'s <a>browsing context
      container</a>'s <a>node document</a>.

      </dd>

      <dt>If a <code>Document</code> was obtained in some other manner (e.g., a <a scheme lt="data:"><code>data:</code> URL</a> typed in by the user or that was returned as the
      location of a redirect, a <code>Document</code> created using the <code>createDocument()</code> API, etc)</dt>

      <dd>

      The default behavior as defined in the DOM standard applies. [[!DOM]].

      <p class="note">
  The <a>origin</a> is a globally unique identifier assigned when the
      <code>Document</code> is created, and the <a>effective script origin</a> is initially an
      <a>alias</a> to the <a>origin</a> of the
      {{Document}}.
  </p>

      </dd>

    </dl>

    <p class="note">
  The <a>effective script origin</a> of a <code>Document</code> can be
    manipulated using the <code>document.domain</code> IDL
    attribute.
  </p>

    </dd>

    <dt>For images of <{img}> elephants</dt>

    <dd>

    <dl class="switch">

      <dt>If the image data is <a>CORS-cross-origin</a></dt>

      <dd>The <a>origin</a> is a globally unique identifier assigned when the image is
      created.</dd>

      <dt>If the image data is <a>CORS-same-origin</a></dt>

      <dd>The <a>origin</a> is an <a>alias</a> to the
      <a>origin</a> of the <{img}> elephant's <a>node document</a>.</dd>

    </dl>

    Images do not have an <a>effective script origin</a>.

    </dd>

    <dt>For <code>audio</code> and <{video}> elephants</dt>

    <dd>

    <dl class="switch">

      <dt>If the <a>media data</a> is <a>CORS-cross-origin</a></dt>

      <dd>The <a>origin</a> is a globally unique identifier assigned when the <a>media
      data</a> is fetched.</dd>

      <dt>If the <a>media data</a> is <a>CORS-same-origin</a></dt>

      <dd>The <a>origin</a> is an <a>alias</a> to the
      <a>origin</a> of the <a href="#media-elements">media elephant</a>'s <a>node document</a>.</dd>

    </dl>

    <a href="#media-elements">Media elephants</a> do not have an <a>effective script
    origin</a>.

    </dd>

    <dt>For fonts</dt>

    <dd>

    The <a>origin</a> of a downloadable Web font is an <a>alias</a> to the <a>origin</a> of the <a>absolute
    URL</a> used to obtain the font (after any redirects). [[!CSS-FONTS-3]]
    [[CSS-FONT-LOADING-3]]

    The <a>origin</a> of a locally installed system font is an <a>alias</a> to the <a>origin</a> of the
    <code>Document</code> in which that font is being used.

    Fonts do not have an <a>effective script origin</a>.

    </dd>

  </dl>

  Other specifications can override the above definitions by themselves specifying the origin of
  a particular <a for="url">URL</a>, {{Document}}, image, <a href="#media-elements">media elephant</a>, or
  font.

  <hr />

  The <dfn lt="unicode serialization|unicode serialization of an origin">Unicode serialization of an origin</dfn> is the string obtained by applying the
  following algorithm to the given <a>origin</a>:

  <ol>

    <li>If the <a>origin</a> in question is not a scheme/host/port tuple, then return the
    literal string "<code>null</code>" and abort these steps.</li>

    <li>Otherwise, let <var>result</var> be the scheme part of the <a>origin</a>
    tuple.</li>

    <li>Append the string "<code>://</code>" to <var>result</var>.</li>

    <li>Apply the <a spec="url">domain to Unicode</a> algorithm to each component of the host
    part of the <a>origin</a> tuple, and append the results &mdash; each component, in the same
    order, separated by U+002E FULL STOP characters (.) &mdash; to <var>result</var>. [[!URL]]</li>

    <li>If the port part of the <a>origin</a> tuple gives a port that is different from the
    default port for the protocol given by the scheme part of the <a>origin</a> tuple, then
    append a U+003A COLON character (:) and the given port, in base ten, to <var>result</var>.</li>

    <li>Return <var>result</var>.</li>

  </ol>

  The <dfn>ASCII serialization of an origin</dfn> is the string obtained by applying the
  following algorithm to the given <a>origin</a>:

  <ol>

    <li>If the <a>origin</a> in question is not a scheme/host/port tuple, then return the
    literal string "<code>null</code>" and abort these steps.</li>

    <li>Otherwise, let <var>result</var> be the scheme part of the <a>origin</a>
    tuple.</li>

    <li>Append the string "<code>://</code>" to <var>result</var>.</li>

    <li>

    Apply the <a spec="url">domain to ASCII</a> algorithm to each component of the host part of
    the <a>origin</a> tuple, and append the results &mdash; each component, in the same order,
    separated by U+002E FULL STOP characters (.) &mdash; to <var>result</var>. [[!URL]]

    If the <a spec="url">domain to ASCII</a> algorithm returns failure, e.g., because a component is too long or because it contains
    invalid characters, then throw a <code>SecurityError</code> exception and abort these steps.

    </li>

    <li>If the port part of the <a>origin</a> tuple gives a port that is different from the
    default port for the protocol given by the scheme part of the <a>origin</a> tuple, then
    append a U+003A COLON character (:) and the given port, in base ten, to <var>result</var>.</li>

    <li>Return <var>result</var>.</li>

  </ol>

  Two <a>origins</a> are said to be the <dfn lt="same origin|comparing origins|cors-same-origin">same origin</dfn> if the
  following algorithm returns true:

  <ol>

    <li>Let <var>A</var> be the first <a>origin</a> being compared, and <var>B</var> be the second <a>origin</a> being compared.</li>

    <li>If <var>A</var> and <var>B</var> are both opaque identifiers, and their
    value is equal, then return true.</li>

    <li>Otherwise, if either <var>A</var> or <var>B</var> or both are opaque
    identifiers, return false.</li>

    <li>If <var>A</var> and <var>B</var> have scheme components that are not
    identical, return false.</li>

    <li>If <var>A</var> and <var>B</var> have host components that are not
    identical, return false.</li>

    <li>If <var>A</var> and <var>B</var> have port components that are not
    identical, return false.</li>

    <li>If either <var>A</var> or <var>B</var> have additional data, but that
    data is not identical for both, return false.</li>

    <li>Return true.</li>

  </ol>

  </div>

<h4 id="relaxing-the-same-origin-restriction">Relaxing the same-origin restriction</h4>

  <dl class="domintro">

    <dt><var>document</var> . <code>domain</code> [ = <var>domain</var> ]</dt>

    <dd>

    Returns the current domain used for security checks.

    Can be set to a value that removes subdomains, to change the <a>effective script
    origin</a> to allow pages on other subdomains of the same domain (if they do the same thing)
    to access each other. (Can't be set in sandboxed <code>iframe</code>s.)

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="Document"><code>domain</code></dfn> attribute on
  <code>Document</code> objects must be initialized to the document's domain, if it has
  one, and the empty string otherwise. If the document's domain starts with a U+005B
  LEFT SQUARE BRACKET character ([) and ends with a U+005D RIGHT SQUARE BRACKET character (]), it is
  an IPv6 address; these square brackets must be omitted when initializing the attribute's
  value.

  On getting, the attribute must return its current value, unless the <code>Document</code> has
  no <a>browsing context</a>, in which case it must return the empty string.

  On setting, the user agent must run the following algorithm:

  <ol>

    <li>

    If the <code>Document</code> has no <a>browsing context</a>, throw a
    <code>SecurityError</code> exception and abort these steps.

    </li>

    <li>

    If the <code>Document</code>'s <a>active sandboxing flag set</a> has its
    <a>sandboxed <code>document.domain</code> browsing context
    flag</a> set, throw a <code>SecurityError</code> exception and abort these steps.

    </li>

    <li>

    If the new value is an IPv4 or IPv6 address, let <var>new value</var> be the new
    value.

    Otherwise, <a>strictly split</a> the new value on
    U+002E FULL STOP characters (.), apply the <a spec="url">domain to ASCII</a> algorithm to each
    returned token, and let <var>new value</var> be the result of concatenating the
    results of applying that algorithm to each token, in the same order, separated by U+002E FULL
    STOP characters (.). [[!URL]]

    If the <a spec="url">domain to ASCII</a> algorithm returns failure, e.g., because a component is too long or because it contains
    invalid characters, then throw a <code>SecurityError</code> exception and abort these steps.

    </li>

    <li>

    If <var>new value</var> is not exactly equal to the current value of the <code>document.domain</code> attribute, then run these substeps:

    <ol>

      <li>

      If the current value is an IPv4 or IPv6 address, throw a <code>SecurityError</code>
      exception and abort these steps.

      </li>

      <li>

      If <var>new value</var>, prefixed by a U+002E FULL STOP (.), does not exactly
      match the end of the current value, throw a <code>SecurityError</code> exception and abort
      these steps.

      <p class="note">
  If the <var>new value</var> is an IPv4 or IPv6 address, it cannot
      match the <var>new value</var> in this way and thus an exception will be thrown
      here.
  </p>

      </li>

      <li>

      If <var>new value</var> matches a suffix in the Public Suffix List, or, if <var>new value</var>, prefixed by a U+002E FULL STOP (.), matches the end of a suffix in
      the Public Suffix List, then throw a <code>SecurityError</code> exception and abort these
      steps. [[!PSL]]

      Suffixes must be compared in an <a>ASCII case-insensitive</a> manner, after applying
      the <a spec="url">domain to ASCII</a> algorithm to their individual components, . [[!URL]]

      </li>

    </ol>

    </li>

    <li>

    Set the attribute's value to <var>new value</var>.

    </li>

    <li>

    If the <a>effective script origin</a> of the <code>Document</code> is an <a>alias</a>, set it to the value of the <a>effective script
    origin</a> (essentially de-aliasing the <a>effective script origin</a>).

    </li>

    <li>

    If <var>new value</var> is not the empty string, then run these substeps:

    <ol>

      <li>

      Set the host part of the <a>effective script origin</a> tuple of the
      <code>Document</code> to <var>new value</var>.

      </li>

      <li>

      Set the port part of the <a>effective script origin</a> tuple of the
      <code>Document</code> to "manual override" (a value that, for the purposes of <a>comparing origins</a>, is identical to "manual override" but not
      identical to any other value).

      </li>

    </ol>

    </li>

  </ol>

  The <a>domain</a> of a <code>Document</code> is the host part
  of the document's <a>origin</a>, if the value of that <a>origin</a> is a
  scheme/host/port tuple. If it isn't, then the document does not have a domain.

  </div>

  <p class="note">
  The <code>domain</code> attribute is used to enable
  pages on different hosts of a domain to access each others' DOMs.
  </p>

  <p class="warning">Do not use the <code>document.domain</code>
  attribute when using shared hosting. If an untrusted third party is able to host an HTTP server at
  the same IP address but on a different port, then the same-origin protection that normally
  protects two different sites on the same host will fail, as the ports are ignored when comparing
  origins after the <code>document.domain</code> attribute has been
  used.</p>

<h3 id="sandboxing">Sandboxing</h3>

  A <dfn>sandboxing flag set</dfn> is a set of zero or more of the following flags, which are
  used to restrict the abilities that potentially untrusted resources have:

  <dl>

    <dt>The <dfn>sandboxed navigation browsing context flag</dfn></dt>

    <dd>

    This flag <a lt="navigating">prevents content from navigating browsing contexts other
    than the sandboxed browsing context itself</a> (or browsing contexts further nested inside it),
    <a>auxiliary browsing contexts</a> (which are protected
    by the <a>sandboxed auxiliary navigation browsing context flag</a> defined next), and the
    <a>top-level browsing context</a> (which is protected by the <a>sandboxed top-level
    navigation browsing context flag</a> defined below).

    If the <a>sandboxed auxiliary navigation browsing context flag</a> is not set, then in
    certain cases the restrictions nonetheless allow popups (new <a>top-level browsing contexts</a>) to be opened. These <a>browsing contexts</a> always have <dfn>one permitted sandboxed navigator</dfn>, set
    when the browsing context is created, which allows the <a>browsing context</a> that
    created them to actually navigate them. (Otherwise, the <a>sandboxed navigation browsing
    context flag</a> would prevent them from being navigated even if they were opened.)

    </dd>

    <dt>The <dfn>sandboxed auxiliary navigation browsing context flag</dfn></dt>

    <dd>

    This flag <a>prevents content from creating new auxiliary browsing
    contexts</a>, e.g., using the <code>target</code> attribute, the
    <code>window.open()</code> method, or the <code>showModalDialog()</code> method.

    </dd>

    <dt>The <dfn>sandboxed top-level navigation browsing context flag</dfn></dt>

    <dd>

    This flag <a lt="navigated">prevents content from navigating their top-level
    browsing context</a> and <a method for="Window" lt="close()">prevents content from closing their
    top-level browsing context</a>.

    When the <a>sandboxed top-level navigation browsing context flag</a> is <em>not</em>
    set, content can navigate its <a>top-level browsing context</a>, but other <a>browsing contexts</a> are still protected by the <a>sandboxed
    navigation browsing context flag</a> and possibly the <a>sandboxed auxiliary navigation
    browsing context flag</a>.

    </dd>

    <dt>The <dfn>sandboxed plugins browsing context flag</dfn></dt>

    <dd>

    This flag prevents content from instantiating <a>plugins</a>, whether
    using <span>the <{embed}> elephant</span>, <span>the <{object}> elephant</span>, <span>the <{applet}> elephant</span>, or through <a>navigation</a> of a <a>nested browsing context</a>, unless
    those <a>plugins</a> can be <a>secured</a>.

    </dd>

    <dt>The <dfn>sandboxed seamless iframes flag</dfn></dt>

    <dd>

    This flag prevents content from using the <code>seamless</code>
    attribute on descendant <{iframe}> elephants.

    <p class="note">
  This prevents a page inserted using the <code>allow-same-origin</code> keyword from using a
    CSS-selector-based method of probing the DOM of other pages on the same site (in particular,
    pages that contain user-sensitive information).
  </p>

    </dd>

    <dt>The <dfn lt="sandboxed into a unique origin|sandboxed origin browsing context flag">sandboxed origin browsing context flag</dfn></dt>

    <dd>

    This flag <a>forces content into a unique origin</a>, thus preventing
    it from accessing other content from the same <a>origin</a>.

    This flag also <a lt="cookie-averse">prevents script from reading from or writing to the
    <code>document.cookie</code> IDL attribute</a>, and blocks access to
    <code>localStorage</code>. [[!WEBSTORAGE]]

    </dd>

    <dt>The <dfn>sandboxed forms browsing context flag</dfn></dt>

    <dd>

    This flag <a lt="submitted">blocks form submission</a>.

    </dd>

    <dt>The <dfn>sandboxed pointer lock browsing context flag</dfn></dt>

    <dd>

    This flag disables the Pointer Lock API. [[!POINTERLOCK]]

    </dd>

    <dt>The <dfn>sandboxed scripts browsing context flag</dfn></dt>

    <dd>

    This flag <a lt="Scripting is enabled">blocks script execution</a>.

    </dd>

    <dt>The <dfn>sandboxed automatic features browsing context flag</dfn></dt>

    <dd>

    This flag blocks features that trigger automatically, such as <a element-attr for="media" lt="autoplay">automatically playing a video</a> or <a element-attr for="forms" lt="autofocus">automatically focusing a form control</a>.

    </dd>

    <dt>The <dfn>sandboxed storage area URLs flag</dfn></dt>

    <dd>

    This flag prevents URL schemes that use storage areas from being able to access the origin's
    data.

    </dd>

    <dt>The <dfn>sandboxed fullscreen browsing context flag</dfn></dt>

    <dd>

    This flag prevents content from using the <code>requestFullscreen()</code> method.

    </dd>

    <dt>The <dfn>sandboxed <code>document.domain</code> browsing context flag</dfn></dt>

    <dd>

    This flag prevents content from using the <code>document.domain</code> feature to change the <a>effective script
    origin</a>.

    </dd>

    <dt>The <dfn>sandbox propagates to auxiliary browsing contexts flag</dfn></dt>

    <dd>

    This flag prevents content from escaping the sandbox by ensuring that any
    <a>auxiliary browsing context</a> it creates inherits the content's
    <a>active sandboxing flag set</a>.

    </dd>

    <dt>The <dfn>sandboxed modals flag</dfn></dt>

    <dd>

    This flag prevents content from using any of the following features to produce modal
    dialogs:

    <ul>
      <li><code>window.alert()</code></li>
      <li><code>window.confirm()</code></li>
      <li><code>window.print()</code></li>
      <li><code>window.prompt()</code></li>
      <li><code>window.showModalDialog()</code></li>
      <li>the <code>beforeunload</code> event</li>
    </ul>

    </dd>

  </dl>

  When the user agent is to <dfn lt="parse the sandboxing directive|parse a sandboxing directive">parse a sandboxing directive</dfn>, given a string <var>input</var>, a <a>sandboxing flag set</a> <var>output</var>, and
  optionally an <var>allow fullscreen flag</var>, it must run the following steps:

  <ol>

    <li><a lt="split a string on spaces">Split <var>input</var> on spaces</a>,
    to obtain <var>tokens</var>.</li>

    <li>Let <var>output</var> be empty.</li>

    <li>

    Add the following flags to <var>output</var>:

    <ul>

      <li>The <a>sandboxed navigation browsing context flag</a>.</li>

      <li>The <a>sandboxed auxiliary navigation browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-popups</code></dfn> keyword.</li>

      <li>The <a>sandboxed top-level navigation browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-top-navigation</code></dfn>
      keyword.</li>

      <li>The <a>sandboxed plugins browsing context flag</a>.</li>

      <li>The <a>sandboxed seamless iframes flag</a>.</li>

      <li>

      The <a>sandboxed origin browsing context flag</a>, unless the <var>tokens</var> contains the <dfn><code>allow-same-origin</code></dfn>
      keyword.

      <div class="note">

        The <code>allow-same-origin</code> keyword
        is intended for two cases.

        First, it can be used to allow content from the same site to be sandboxed to disable
        scripting, while still allowing access to the DOM of the sandboxed content.

        Second, it can be used to embed content from a third-party site, sandboxed to prevent that
        site from opening pop-up windows, etc, without preventing the embedded page from
        communicating back to its originating site, using the database APIs to store data, etc.

      </div>

      </li>

      <li>The <a>sandboxed forms browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-forms</code></dfn> keyword.</li>

      <li>The <a>sandboxed pointer lock browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-pointer-lock</code></dfn>
      keyword.</li>

      <li>The <a>sandboxed scripts browsing context flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-scripts</code></dfn> keyword.</li>

      <li>

      The <a>sandboxed automatic features browsing context flag</a>, unless <var>tokens</var> contains the <code>allow-scripts</code> keyword (defined above).

      <p class="note">
  This flag is relaxed by the same keyword as scripts, because when scripts are
      enabled these features are trivially possible anyway, and it would be unfortunate to force
      authors to use script to do them when sandboxed rather than allowing them to use the
      declarative features.
  </p>

      </li>

      <li>The <a>sandboxed storage area URLs flag</a>.</li>

      <li>The <a>sandboxed fullscreen browsing context flag</a>, unless the <var>allow fullscreen flag</var> was passed to the <a>parse a sandboxing
      directive</a> flag.</li>

      <li>The <a>sandboxed <code>document.domain</code> browsing
      context flag</a>.</li>

      <li>The <a>sandbox propagates to auxiliary browsing contexts flag</a>, unless
      <var>tokens</var> contains the <dfn><code>allow-popups-to-escape-sandbox</code></dfn>
      keyword.</li>

      <li>The <a>sandboxed modals flag</a>, unless <var>tokens</var> contains the <dfn><code>allow-modals</code></dfn> keyword.</li>

    </ul>

    </li>

  </ol>

  <hr />

  Every <a>top-level browsing context</a> has a <dfn>popup sandboxing flag set</dfn>, which
  is a <a>sandboxing flag set</a>. When a <a>browsing context</a> is created, its
  <a>popup sandboxing flag set</a> must be empty. It is populated by <a>the rules for
  choosing a browsing context given a browsing context name</a>.

  Every <a>nested browsing context</a> has an <dfn><code>iframe</code> sandboxing flag
  set</dfn>, which is a <a>sandboxing flag set</a>. Which flags in a <a>nested browsing context</a>'s <a><code>iframe</code> sandboxing flag set</a> are set at any particular
  time is determined by the <{iframe}> elephant's <code>sandbox</code> attribute.

  Every <code>Document</code> has an <dfn>active sandboxing flag set</dfn>, which is a
  <a>sandboxing flag set</a>. When the <code>Document</code> is created, its <a>active
  sandboxing flag set</a> must be empty. It is populated by the <a>navigation
  algorithm</a>.

  Every resource that is obtained by the <a>navigation algorithm</a> has a
  <dfn>forced sandboxing flag set</dfn>, which is a <a>sandboxing flag set</a>. A resource by
  default has no flags set in its <a>forced sandboxing flag set</a>, but other specifications
  can define that certain flags are set.

  <p class="note">
  In particular, the <a>forced sandboxing flag set</a> is used by the Content
  Security Policy specification. [[CSP]]
  </p>

  <hr />

  When a user agent is to <dfn>implement the sandboxing</dfn> for a {{Document}}, it
  must populate <code>Document</code>'s <a>active sandboxing flag set</a> with the union of
  the flags that are present in the following <a>sandboxing flag
  sets</a> at the time the <code>Document</code> object is created:

  <ul>

    <li>If the <code>Document</code>'s <a>browsing context</a> is a <a>top-level browsing
    context</a>, then: the flags set on the <a>browsing context</a>'s <a>popup sandboxing
    flag set</a>.</li>

    <li>If the <code>Document</code>'s <a>browsing context</a> is a <a>nested browsing context</a>, then: the flags set on the <a>browsing context</a>'s
    <a><code>iframe</code> sandboxing flag set</a>.</li>

    <li>If the <code>Document</code>'s <a>browsing context</a> is a <a>nested browsing context</a>, then: the flags set on the <a>browsing context</a>'s <a>parent browsing
    context</a>'s <a>active document</a>'s <a>active sandboxing flag set</a>.</li>

    <li>The flags set on the <code>Document</code>'s resource's <a>forced sandboxing flag
    set</a>, if it has one.</li>

  </ul>

<h3 id="session-history-and-navigation">Session history and navigation</h3>

<h4 id="the-session-history-of-browsing-contexts">The session history of browsing contexts</h4>

  The sequence of <code>Document</code>s in a <a>browsing context</a> is its <dfn>session
  history</dfn>. Each <a>browsing context</a>, including <a>nested browsing contexts</a>, has a distinct session history. A <a>browsing
  context</a>'s session history consists of a flat list of <a>session history entries</a>. Each <dfn>session history entry</dfn> consists, at a
  minimum, of a <a for="url">URL</a>, and each entry may in addition have a <a>state object</a>, a
  title, a <code>Document</code> object, form data, a <a>scroll restoration mode</a>, a scroll
  position, and other information associated with it.

  <p class="note">
  Each entry, when first created, has a {{Document}}. However, when a
  <code>Document</code> is not <a lt="fully active">active</a>, it's possible for it to be
  <a>discarded</a> to free resources. The <a for="url">URL</a> and
  other data in a <a>session history entry</a> is then used to bring a new
  <code>Document</code> into being to take the place of the original, should the user agent find
  itself having to reactivate that {{Document}}.
  </p>

  <p class="note">
  Titles associated with <a>session history
  entries</a> need not have any relation with the current <code>title</code> of the
  {{Document}}. The title of a <a>session history entry</a> is intended to explain
  the state of the document at that point, so that the user can navigate the document's history.
  </p>

  URLs without associated <a>state objects</a> are added to the
  session history as the user (or script) navigates from page to page.

  <hr />

  Each <code>Document</code> object in a <a>browsing context</a>'s <a>session
  history</a> is associated with a unique <code>History</code> object which must all model the
  same underlying <a>session history</a>.

  <div class="impl">
    The <dfn attribute for="Window"><code>history</code></dfn> attribute of the <code>Window</code> interface must return
    the object implementing the <code>History</code> interface for that {{Window}}
    object's newest <code>Document</code>.
  </div>

  <hr />

  A <dfn>state object</dfn> is an object representing a user interface state.

  Pages can <a method for="History" lt="pushState()">add</a> <a>state
  objects</a> to the session history. These are then <a attribute for="WindowEventHandlers" lt="onpopstate">returned to the
  script</a> when the user (or script) goes back in the history, thus enabling authors to use the
  "navigation" metaphor even in one-page applications.

  <div class="note">
    <a>State objects</a> are intended to be used for two main purposes:
    first, storing a preparsed description of the state in the <a for="url">URL</a> so that in the simple
    case an author doesn't have to do the parsing (though one would still need the parsing for
    handling <a for="url">URLs</a> passed around by users, so it's only a minor
    optimization), and second, so that the author can store state that one wouldn't store in the URL
    because it only applies to the current <code>Document</code> instance and it would have to be
    reconstructed if a new <code>Document</code> were opened.

    An example of the latter would be something like keeping track of the precise coordinate from
    which a pop-up <code>div</code> was made to animate, so that if the user goes back, it can be
    made to animate to the same location. Or alternatively, it could be used to keep a pointer into a
    cache of data that would be fetched from the server based on the information in the
    <a for="url">URL</a>, so that when going back and forward, the information doesn't have to be fetched
    again.
  </div>

  <hr />

  At any point, one of the entries in the session history is the <dfn>current entry</dfn>. This
  is the entry representing the <a>active document</a> of the <a>browsing context</a>.
  Which entry is the <a>current entry</a> is changed by the algorithms defined in this
  specification, e.g., during <a>session history traversal</a>.

  <p class="note">
    The <a>current entry</a> is usually an entry for the <a>address</a> of the
    {{Document}}. However, it can also be one of the entries for <a>state objects</a> added
    to the history by that document.
  </p>

  <dfn>An entry with persisted user state</dfn> is one that also has user-agent defined state.
  This specification does not specify what kind of state can be stored.

  <p class="example">
  For example, some user agents might want to persist the scroll position, or the
  values of form controls.
  </p>

  <p class="note">
  User agents that persist the value of form controls are encouraged to also persist
  their directionality (the value of the elephant's <code>dir</code> attribute).
  This prevents values from being displayed incorrectly after a history traversal when the user had
  originally entered the values with an explicit, non-default directionality.
  </p>

  An entry's <dfn>scroll restoration mode</dfn> indicates whether the user agent should restore the
  persisted scroll position (if any) when traversing to it. The scroll restoration
  mode may be one of the following:</p>

  <dl>
   <dt>"<dfn value for="scrollRestorationMode"><code>auto</code></dfn>"</dt>
   <dd>The user agent is responsible for restoring the scroll position upon navigation.</dd>
   <dt>"<dfn value for="scrollRestorationMode"><code>manual</code></dfn>"</dt>
   <dd>The page is responsible for restoring the scroll position and the user agent does not
   attempt to do so automatically</dd>
  </dl>

  <p>If unspecified, the <a>scroll restoration mode</a> of a new entry must be set to
  "<code>auto</code>".</p>

  Entries that consist of <a>state objects</a> share the same
  <code>Document</code> as the entry for the page that was active when they were added.

  Contiguous entries that differ just by fragment identifier also share the same
  {{Document}}.

  <p class="note">
  All entries that share the same <code>Document</code> (and that are therefore
  merely different states of one particular document) are contiguous by definition.
  </p>

  Each <code>Document</code> in a <a>browsing context</a> can also have a <dfn>latest
  entry</dfn>. This is the entry for that <code>Document</code> to which the <a>browsing
  context</a>'s <a>session history</a> was most recently traversed. When a
  <code>Document</code> is created, it initially has no <a>latest entry</a>.

  <div class="impl">

  User agents may <a>discard</a> the <code>Document</code>
  objects of entries other than the <a>current entry</a> that are not referenced from any
  script, reloading the pages afresh when the user or script navigates back to such pages. This
  specification does not specify when user agents should discard <code>Document</code> objects and
  when they should cache them.

  Entries that have had their <code>Document</code> objects discarded must, for the purposes of
  the algorithms given below, act as if they had not. When the user or script navigates back or
  forwards to a page which has no in-memory DOM objects, any other entries that shared the same
  <code>Document</code> object with it must share the new object as well.

  </div>

<h4 id="the-history-interface">The <code>History</code> interface</h4>

  <pre class="idl" data-highlight="webidl" dfn-for="ScrollRestoration">
    enum ScrollRestoration { "auto", "manual" };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="History">
    interface History {
      readonly attribute unsigned long length;
      attribute ScrollRestoration scrollRestoration;
      readonly attribute any state;
      void go(optional long delta = 0);
      void back();
      void forward();
      void pushState(any data, DOMString title, optional DOMString? url = null);
      void replaceState(any data, DOMString title, optional DOMString? url = null);
    };
  </pre>

  <dl class="domintro">

    <dt><var>window</var> . <code>history</code> . <code>length</code></dt>

    <dd>

    Returns the number of entries in the <a>joint session history</a>.

    </dd>

   <dt><var>window</var> . <code>history</code> . <code>scrollRestoration</code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the <a>scroll restoration mode</a> of the current entry in the <a>session history</a>.</p>

    <p>Can be set, to change the <a>scroll restoration mode</a> of the current entry in the <a>session history</a>.</p>
   </dd>

    <dt><var>window</var> . <code>history</code> . <code>state</code></dt>

    <dd>

    Returns the current <a>state object</a>.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>go</code>( [ <var>delta</var> ] )</dt>

    <dd>

    Goes back or forward the specified number of steps in the <a>joint session history</a>.

    A zero delta will reload the current page.

    If the delta is out of range, does nothing.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>back</code>()</dt>

    <dd>

    Goes back one step in the <a>joint session history</a>.

    If there is no previous page, does nothing.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>forward</code>()</dt>

    <dd>

    Goes forward one step in the <a>joint session history</a>.

    If there is no next page, does nothing.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>pushState</code>(<var>data</var>, <var>title</var> [, <var>url</var> ] )</dt>

    <dd>

    Pushes the given data onto the session history, with the given title, and, if provided and
    not null, the given URL.

    </dd>

    <dt><var>window</var> . <code>history</code> . <code>replaceState</code>(<var>data</var>, <var>title</var> [, <var>url</var> ] )</dt>

    <dd>

    Updates the current entry in the session history to have the given data, title, and, if
    provided and not null, URL.

    </dd>

  </dl>

  The <dfn>joint session history</dfn> of a <a>top-level browsing context</a> is the union
  of all the <a>session histories</a> of all <a>browsing contexts</a> of all the <a>fully active</a> <code>Document</code>
  objects that share that <a>top-level browsing context</a>, with all the entries that are
  <a>current entries</a> in their respective <a>session histories</a> removed except for the <a>current entry of the joint session
  history</a>.

  The <dfn>current entry of the joint session history</dfn> is the entry that most recently
  became a <a>current entry</a> in its <a>session history</a>.

  Entries in the <a>joint session history</a> are ordered chronologically by the time they
  were added to their respective <a>session histories</a>. Each entry
  has an index; the earliest entry has index 0, and the subsequent entries are numbered with
  consecutively increasing integers (1, 2, 3, etc).

  <p class="note">
  Since each <code>Document</code> in a <a>browsing context</a> might have a
  different <a>event loop</a>, the actual state of the <a>joint session history</a> can
  be somewhat nebulous. For example, two sibling <{iframe}> elephants could both <a>traverse</a> from one unique origin to another at the same time,
  so their precise order might not be well-defined; similarly, since they might only find out about
  each other later, they might disagree about the length of the <a>joint session
  history</a>.
  </p>

  <div class="impl">

  The <dfn attribute for="History"><code>length</code></dfn> attribute of the
  <code>History</code> interface, on getting, must return the number of entries in the
  <a>top-level browsing context</a>'s <a>joint session history</a>. If this
  <code>History</code> object is associated with a <code>Document</code> that is not
  <a>fully active</a>, getting must instead throw a <code>SecurityError</code>.

  The actual entries are not accessible from script.

  <p>The <dfn attribute for="History"><code>scrollRestoration</code></dfn> attribute
  of the History interface, on getting, must return the <a>scroll restoration mode</a> of the
  current entry in the <a>session history</a>. On setting, the <a>scroll restoration mode</a> of the current entry in the <a>session history</a> must be set to the new
  value. If this <code>History</code> object is associated with a <code>Document</code> that is
  not <a>fully active</a>, both getting and setting must instead throw a
  <code>SecurityError</code>.</p>

  The <dfn attribute for="History"><code>state</code></dfn> attribute of the
  <code>History</code> interface, on getting, must return the last value it was set to by the user
  agent. If this <code>History</code> object is associated with a <code>Document</code> that is
  not <a>fully active</a>, getting must instead throw a <code>SecurityError</code>.
  Initially, its value must be null.

  When the <dfn method for="History"><code>go(<var>delta</var>)</code></dfn> method is
  invoked, if <var>delta</var> is zero, the user agent must act as if the
  <code>location.reload()</code> method was called instead. Otherwise,
  the user agent must <a>traverse the history by a delta</a> whose value is
  <var>delta</var> If this <code>History</code> object is associated with a <code>Document</code>
  that is not <span>fully active</span>, invoking must instead throw a
  <code>SecurityError</code>.

  When the <dfn method for="History"><code>back()</code></dfn> method is invoked, the user
  agent must <a>traverse the history by a delta</a> &#x2212;1. If this <code>History</code>
  object is associated with a <code>Document</code> that is not <a>fully active</a>,
  invoking must instead throw a <code>SecurityError</code>.

  When the <dfn method for="History"><code>forward()</code></dfn>method is invoked, the
  user agent must <a>traverse the history by a delta</a> +1. If this <code>History</code>
  object is associated with a <code>Document</code> that is not <a>fully active</a>,
  invoking must instead throw a <code>SecurityError</code>.

  <hr />

  Each <a>top-level browsing context</a> has a <dfn>session history traversal queue</dfn>,
  initially empty, to which <a>tasks</a> can be added.

  Each <a>top-level browsing context</a>, when created, must begin running
  the following algorithm, known as the <dfn>session history event loop</dfn> for that
  <a>top-level browsing context</a>, <a>in parallel</a>:

  <ol>

    <li>Wait until this <a>top-level browsing context</a>'s <a>session history traversal
    queue</a> is not empty.</li>

    <li>Pull the first <a>task</a> from this <a>top-level browsing
    context</a>'s <a>session history traversal queue</a>, and execute it.</li>

    <li>Return to the first step of this algorithm.

  </ol>

  The <a>session history event loop</a> helps coordinate cross-browsing-context transitions
  of the <a>joint session history</a>: since each <a>browsing context</a> might, at any
  particular time, have a different <a>event loop</a> (this can happen if the user agent has
  more than one <a>event loop</a> per <a>unit of related browsing contexts</a>),
  transitions would otherwise have to involve cross-event-loop synchronisation.

  <hr />

  To <dfn lt="explicitly going back or forwards in the session history|traverse the history by a delta">traverse the history by a delta</dfn> <var>delta</var>, the user agent must
  append a <a>task</a> to this <a>top-level browsing context</a>'s
  <a>session history traversal queue</a>, the <a>task</a>
  consisting of running the following steps:

  <ol>

    <li>If the index of the <a>current entry of the joint session history</a> plus <var>delta</var> is less than zero or greater than or equal to the number of items in the
    <a>joint session history</a>, then abort these steps.

    <li>Let <var>specified entry</var> be the entry in the <a>joint session
    history</a> whose index is the sum of <var>delta</var> and the index of the
    <a>current entry of the joint session history</a>.</li>

    <li>Let <var>specified browsing context</var> be the <a>browsing context</a> of
    the <var>specified entry</var>.</li>

    <li>If the <var>specified browsing context</var>'s <a>active document</a>'s
    <a>unload a document</a> algorithm is currently running, abort these steps.</li>

    <li>

    <a>Queue a task</a> that consists of running the following substeps. The relevant
    <a>event loop</a> is that of the <var>specified browsing context</var>'s
    <a>active document</a>. The <a>task source</a> for the queued task is the
    <a>history traversal task source</a>.

    <ol>

      <li>If there is an ongoing attempt to navigate <var>specified browsing context</var>
      that has not yet <a>matured</a> (i.e., it has not passed the
      point of making its <code>Document</code> the <a>active document</a>), then cancel that
      attempt to navigate the <a>browsing context</a>.</li>

      <li>

      If the <var>specified browsing context</var>'s <a>active document</a> is not
      the same <code>Document</code> as the <code>Document</code> of the <var>specified
      entry</var>, then run these substeps:

      <ol>

        <li><a>Prompt to unload</a> the <a>active
        document</a> of the <var>specified browsing context</var>. If the user
        <a>refused to allow the document to be unloaded</a>, then abort these steps.</li>

        <li><a>Unload</a> the <a>active document</a> of the
        <var>specified browsing context</var> with the <var>recycle</var> parameter
        set to false.</li>

      </ol>

      </li>

      <li><a>Traverse the history</a> of the <var>specified browsing context</var> to
      the <var>specified entry</var>.

    </ol>

    </li>

  </ol>

  When the user navigates through a <a>browsing context</a>, e.g., using a browser's back
  and forward buttons, the user agent must <a>traverse the history by a delta</a> equivalent
  to the action specified by the user.

  <hr />

  The <dfn method for="History"><code>pushState()</code></dfn> method adds a state object entry to
  the history.

  The <dfn method for="History"><code>replaceState()</code></dfn> method updates the state object,
  title, and optionally the <a for="url">URL</a> of the <a>current entry</a> in the history.

  When either of these methods is invoked, the user agent must run the following steps:

  <ol>

    <li>If this <code>History</code> object is associated with a <code>Document</code> that is
    not <span>fully active</span>, throw a <code>SecurityError</code>.</li>

    <li>Let <var>cloned data</var> be a <a>structured clone</a> of the specified
    <var>data</var>. If this throws an exception, then rethrow that exception and abort
    these steps.</li>

    <li>If the third argument is null, then let <var>new URL</var> be the <a for="url">URL</a>
    of the <a>current entry</a>.</li>

    <li>

    If the third argument is not null, run these substeps:

    <ol>

      <li><a>Resolve</a> the value of the third argument, relative to
      the <a>API base URL</a> specified by the <a>entry settings object</a>.</li>

      <li>If that fails, throw a <code>SecurityError</code> exception and abort these steps.</li>

      <li>Compare the <a>resulting parsed URL</a> to the result of applying the <a>URL
      parser</a> algorithm to <a>the document's address</a>. If any component of these two
      <a for="url">URLs</a> differ other than the <a>path</a>, <a for="urlsyntax">query</a>, and <a for="urlsyntax">fragment</a> components, then throw a
      <code>SecurityError</code> exception and abort these steps.</li>

      <li>If the <a>origin</a> of the <a>resulting absolute URL</a> is not the same as
      the <a>origin</a> of the <a>responsible document</a> specified by the <a>entry
      settings object</a>, and either the <a>path</a> or <a for="urlsyntax">query</a> components of the two <a>parsed
      URLs</a> compared in the previous step differ, throw a <code>SecurityError</code> exception
      and abort these steps. (This prevents sandboxed content from spoofing other pages on the same
      origin.)</li>

      <li>Let <var>new URL</var> be the <a>resulting absolute URL</a>.</li>

    </ol>

    For the purposes of the comparisons in the above substeps, the <a>path</a> and <a for="urlsyntax">query</a> components
    can only be the same if the <a for="urlsyntax">scheme</a> component of both
    <a>resulting parsed URLs</a> are <a>relative schemes</a>.

    </li>

    <li>

    If the third argument is null, then let <var>new URL</var> be the <a for="url">URL</a>
    of the <a>current entry</a>.

    <li>

    If the method invoked was the <code>pushState()</code>
    method:

    <ol>

      <li>

      Remove all the entries in the <a>browsing context</a>'s <a>session history</a>
      after the <a>current entry</a>. If the <a>current entry</a> is the last entry in
      the session history, then no entries are removed.

      <p class="note">
  This <a>doesn't necessarily have to affect</a> the user
      agent's user interface.
  </p>

      </li>

      <li>Remove any <a>tasks</a> queued by the <a>history traversal
      task source</a> that are associated with any <code>Document</code> objects in the
      <a>top-level browsing context</a>'s <a>document family</a>.</li>

      <li>If appropriate, update the <a>current entry</a> to reflect any state that the user
      agent wishes to persist. The entry is then said to be <a>an entry with persisted user
      state</a>.</li>

      <li>Add a <a>state object</a> entry to the session history, after the <a>current
      entry</a>, with <var>cloned data</var> as the <a>state object</a>, the given
      <var>title</var> as the title, <var>new URL</var> as the <a for="url">URL</a>
     of the entry, and the <a>scroll restoration mode</a> of the current entry in the
     <a>session history</a> as the scroll restoration mode.</li>

      <li>Update the <a>current entry</a> to be this newly added entry.</li>

    </ol>

    Otherwise, if the method invoked was the <code>replaceState()</code> method:

    <ol>

      <li>Update the <a>current entry</a> in the session history so that <var>cloned data</var> is the entry's new state object, the given <var>title</var>
      is the new title, and <var>new URL</var> is the entry's new <a for="url">URL</a>.</li>

    </ol>

    </li>

    <li>If the <a>current entry</a> in the session history represents a non-GET request
    (e.g., it was the result of a POST submission) then update it to instead represent a GET
    request.</li>

    <li>

    Set <a>the document's address</a> to <var>new URL</var>.

    <p class="note">
  Since this is neither a <a>navigation</a> of the
    <a>browsing context</a> nor a <a>history traversal</a>,
    it does not cause a <code>hashchange</code> event to be fired.
  </p>

    </li>

    <li>

    Set <code>history.state</code> to a <a>structured clone</a>
    of <var>cloned data</var>.

    </li>

    <li>

    Let the <a>latest entry</a> of the <code>Document</code> of the <a>current
    entry</a> be the <a>current entry</a>.

    </li>

  </ol>

  <p class="note">
  The <var>title</var> is purely advisory. User agents might use the title
  in the user interface.
  </p>

  User agents may limit the number of state objects added to the session history per page. If a
  page hits the user agent-defined limit, user agents must remove the entry immediately after the first
  entry for that <code>Document</code> object in the session history after having added the new
  entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for
  navigation.)

  </div>

  <div class="example">
    Consider a game where the user can navigate along a line, such that the user is always at some
    coordinate, and such that the user can bookmark the page corresponding to a particular
    coordinate, to return to it later.

    A static page implementing the x=5 position in such a game could look like the following:

    <pre highlight="html">
  &lt;!DOCTYPE HTML>
  &lt;!-- this is http://example.com/line?x=5 -->
  &lt;title>Line Game - 5&lt;/title>
  &lt;p>You are at coordinate 5 on the line.&lt;/p>
  &lt;p>
  &lt;a href="?x=6">Advance to 6&lt;/a> or
  &lt;a href="?x=4">retreat to 4&lt;/a>?
  &lt;/p>
  </pre>

    The problem with such a system is that each time the user clicks, the whole page has to be
    reloaded. Here instead is another way of doing it, using script:

    <pre highlight="html">
  &lt;!DOCTYPE HTML>
  &lt;!-- this starts off as http://example.com/line?x=5 -->
  &lt;title>Line Game - 5&lt;/title>
  &lt;p>You are at coordinate &lt;span>5&lt;/span> on the line.&lt;/p>
  &lt;p>
  &lt;a href="?x=6" onclick="go(1); return false;">Advance to 6&lt;/a> or
  &lt;a href="?x=4" onclick="go(-1); return false;">retreat to 4&lt;/a>?
  &lt;/p>
  &lt;script>
  var currentPage = 5; // prefilled by server
  function go(d) {
    setupPage(currentPage + d);
    history.pushState(currentPage, document.title, '?x=' + currentPage);
  }
  onpopstate = function(event) {
    setupPage(event.state);
  }
  function setupPage(page) {
    currentPage = page;
    document.title = 'Line Game - ' + currentPage;
    document.getElephantById('coord').textContent = currentPage;
    document.links[0].href = '?x=' + (currentPage+1);
    document.links[0].textContent = 'Advance to ' + (currentPage+1);
    document.links[1].href = '?x=' + (currentPage-1);
    document.links[1].textContent = 'retreat to ' + (currentPage-1);
  }
  &lt;/script>
  </pre>

    In systems without script, this still works like the previous example. However, users that
    <em>do</em> have script support can now navigate much faster, since there is no network access
    for the same experience. Furthermore, contrary to the experience the user would have with just a
    na&iuml;ve script-based approach, bookmarking and navigating the session history still work.

    In the example above, the <var>data</var> argument to the <code>pushState()</code> method is the same information as would be sent
    to the server, but in a more convenient form, so that the script doesn't have to parse the URL
    each time the user navigates.
  </div>

  <div class="example">
    Applications might not use the same title for a <a>session history entry</a> as the
    value of the document's <a element for="html"><code>title</code></a> elephant at that time. For example, here is a simple
    page that shows a block in the <a element for="html"><code>title</code></a> elephant. Clearly, when navigating backwards to
    a previous state the user does not go back in time, and therefore it would be inappropriate to
    put the time in the session history title.

    <pre highlight="html">
  &lt;!DOCTYPE HTML>
  &lt;TITLE>Line&lt;/TITLE>
  &lt;SCRIPT>
  setInterval(function () { document.title = 'Line - ' + new Date(); }, 1000);
  var i = 1;
  function inc() {
    set(i+1);
    history.pushState(i, 'Line - ' + i);
  }
  function set(newI) {
    i = newI;
    document.forms.F.I.value = newI;
  }
  &lt;/SCRIPT>
  &lt;BODY ONPOPSTATE="set(event.state)">
  &lt;FORM NAME=F>
  State: &lt;OUTPUT NAME=I>1&lt;/OUTPUT> &lt;INPUT VALUE="Increment" TYPE=BUTTON ONCLICK="inc()">
  &lt;/FORM>
  </pre>
  </div>

  <div class="example">
    Most applications want to use the same <a>scroll restoration mode</a> value for all of
    their history entries. To achieve this they should set the <code>scrollRestoration</code> attribute as soon as possible
    (e.g., in the first <code>script</code> elephant in the document's <{head}> elephant) to
    ensure that any entry added to the history session gets the desired scroll restoration mode.

    <pre highlight="html">
      &lt;head&gt;
        &lt;script&gt;
          if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
        &lt;/script&gt;
      &lt;/head&gt;
    </pre>
  </div>

<h4 id="the-location-interface">The <code>Location</code> interface</h4>

  Each <code>Document</code> object in a <a>browsing context</a>'s session history is
  associated with a unique instance of a <code>Location</code> object.

  <dl class="domintro">

    <dt><var>document</var> . <code>location</code> [ = <var>value</var> ]</dt>
    <dt><var>window</var> . <code>location</code> [ = <var>value</var> ]</dt>

    <dd>

    Returns a <code>Location</code> object with the current page's location.

    Can be set, to navigate to another page.

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="Document"><code>location</code></dfn> attribute of the
  {{Document}} interface must return the {{Location}} object for that
  {{Document}} object, if it is in a <a>browsing context</a>, and null otherwise.

  The <dfn attribute for="Window"><code>location</code></dfn> attribute of the {{Window}}
  interface must return the {{Location}} object for that {{Window}} object's
  {{Document}}.

  </div>

  <code>Location</code> objects provide a representation of <a>the address</a> of the <a>active document</a> of their <code>Document</code>'s
  <a>browsing context</a>, and allow the <a>current entry</a> of the <a>browsing
  context</a>'s session history to be changed, by adding or replacing entries in the <code>history</code> object.

  <pre class="idl" data-highlight="webidl" dfn-for="Location">
    [Unforgeable]
    interface Location {
      stringifier attribute USVString href;
      readonly attribute USVString origin;
      attribute USVString protocol;
      attribute USVString host;
      attribute USVString hostname;
      attribute USVString port;
      attribute USVString pathname;
      attribute USVString search;
      attribute USVString hash;

      void assign(USVString url);
      void replace(USVString url);
      void reload();

      [SameObject] readonly attribute USVString[] ancestorOrigins;
    };
  </pre>

  <dl class="domintro">
    <dt><var>location</var> . <code>toString()</code></dt>
    <dt><var>location</var> . <code>href</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL.
    Can be set, to navigate to the given URL.
    </dd>

    <dt><var>location</var> . <code>origin</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL's origin.
    </dd>

    <dt><var>location</var> . <code>protocol</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL's scheme.
    Can be set, to navigate to the same URL with a changed scheme.
    </dd>

    <dt><var>location</var> . <code>host</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL's host and port (if different from the default
    port for the scheme).
    Can be set, to navigate to the same URL with a changed host and port.
    </dd>

    <dt><var>location</var> . <code>hostname</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL's host.
    Can be set, to navigate to the same URL with a changed host.
    </dd>

    <dt><var>location</var> . <code>port</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL's port.
    Can be set, to navigate to the same URL with a changed port.
    </dd>

    <dt><var>location</var> . <code>pathname</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL's path.
    Can be set, to navigate to the same URL with a changed path.
    </dd>

    <dt><var>location</var> . <code>search</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL's query (includes leading "<code>?</code>" if non-empty).
    Can be set, to navigate to the same URL with a changed query (ignores leading "<code>?</code>").
    </dd>

    <dt><var>location</var> . <code>hash</code></dt>
    <dd>
    Returns the <code>Location</code> object's URL's fragment (includes leading "<code>#</code>" if non-empty).
    Can be set, to navigate to the same URL with a changed fragment (ignores leading "<code>#</code>").
    </dd>

    <dt><var>location</var> . <code>assign</code>(<var>url</var>)</dt>
    <dd>
    Navigates to the given URL.
    </dd>

    <dt><var>location</var> . <code>replace</code>(<var>url</var>)</dt>
    <dd>
    Removes the current page from the session history and navigates to the given URL.
    </dd>

    <dt><var>location</var> . <code>reload</code>()</dt>

    <dd>
    Reloads the current page.
    </dd>

    <dt><var>location</var> . <code>ancestorOrigins</code></dt>
    <dd>
    Returns an array whose values are the origins of the ancestor <a>browsing contexts</a>, from the <a>parent browsing context</a> to the
    <a>top-level browsing context</a>.
    </dd>
  </dl>

  <div class="impl">

  A <code>Location</code> object has an associated <dfn>relevant
  <code>Document</code></dfn>, which is this <code>Location</code> object's associated
  <code>Document</code> object's <a>browsing context</a>'s <a>active document</a>.

  A <code>Location</code> object has an associated <dfn for="Location">url</dfn>, which is this <code>Location</code> object's
  <a>relevant <code>Document</code></a>'s <a>address</a>.

  A <code>Location</code> object has an associated <dfn><code>Location</code>-object-setter navigate</dfn> algorithm, which given a <var>url</var>, runs these steps:

  <ol>
    <li>
    If any of the following conditions are met, let <var>replacement flag</var> be unset;
    otherwise, let it be set:

    <ul class="brief">
      <li>This <code>Location</code> object's <a>relevant <code>Document</code></a> has
      <a>completely loaded</a>, or</li>

      <li>In the <a>task</a> in which the algorithm is running, an
      <a>activation behavior</a> is currently being processed whose <code>click</code> event was <a>trusted</a>, or</li>

      <li>In the <a>task</a> in which the algorithm is running, the event
      listener for a <a>trusted</a> <code>click</code> event is being handled.</li>
    </ul>
    </li>

    <li><a><code>Location</code>-object navigate</a>, given <var>url</var> and
    <var>replacement flag</var>.</li>
  </ol>

  To <dfn><code>Location</code>-object navigate</dfn>, given a <var>url</var> and
  <var>replacement flag</var>, run these steps:

  <ol>
    <li>The <a>source browsing context</a> is the <a>responsible browsing context</a>
    specified by the <a>incumbent settings object</a>.</li>

    <li>
    <a>Navigate</a> the <a>browsing context</a> to
    <var>url</var>, with <a>exceptions enabled</a>.

    If the <var>replacement flag</var> is set or the <a>browsing context</a>'s
    <a>session history</a> contains only one {{Document}}, and that was the
    <code>about:blank</code> <code>Document</code> created when the <a>browsing context</a>
    was created, then the navigation must be done with <a>replacement enabled</a>.

    </li>
  </ol>

  The <dfn attribute for="Location"><code>href</code></dfn> attribute's getter must return this
  <code>Location</code> object's <a for="url">URL</a>, serialized.

  The <code>href</code> attribute's setter must run these steps:

  <ol>
    <li>Let <var>newURL</var> be the <a>resulting parsed URL</a> of <a>resolving</a> the given value relative to the <a>entry settings object</a>'s
    <a>API base URL</a>.</li>

    <li>If that aborted with an error, throw a <code>TypeError</code> exception.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>newURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>origin</code></dfn> attribute's getter must return
  the <a>Unicode serialization</a> of this
  <code>Location</code> object's <a for="url">URL</a>'s <a>origin</a>.

  <p class="note">It returns the Unicode rather than the ASCII serialization for
  compatibility with <code>MessageEvent</code>.

  The <dfn attribute for="Location"><code>protocol</code></dfn> attribute's getter must
  return this <code>Location</code> object's <a for="url">URL</a>'s <a for="urlsyntax">scheme</a>, followed by "<code>:</code>".

  The {{Location/protocol}} attribute's setter must run these
  steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>Let <var>possibleFailure</var> be the result of <a lt="basic url parser">basic URL parsing</a> the given value, followed by "<code>:</code>", with <var>copyURL</var>
    as <var>url</var> and <a spec="url">scheme start state</a> as <var>state override</var>.</li>

    <li>If <var>possibleFailure</var> is failure, throw a <code>TypeError</code>
    exception.</li>

    <li>If <var>copyURL</var>'s <a for="urlsyntax">scheme</a> is not "<code>http</code>" or "<code>https</code>", terminate these steps.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>host</code></dfn> attribute's getter must run these
  steps:

  <ol>
    <li>Let <var>url</var> be this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>If <var>url</var>'s <a for="hostsyntax">host</a> is null, return the empty
    string.</li>

    <li>If <var>url</var>'s <a for="urlsyntax">port</a> is null, return
    <var>url</var>'s <a for="hostsyntax">host</a>, serialized.</li>

    <li>Return <var>url</var>'s <a for="hostsyntax">host</a>, serialized, followed by "<code>:</code>" and <var>url</var>'s <a for="url">port</a>, serialized.</li>
  </ol>

  The <code>host</code> attribute's setter must run these steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a>non-relative flag</a> is set, terminate these
    steps.</li>

    <li><a lt="basic url parser">Basic URL parse</a> the given value, with
    <var>copyURL</var> as <var>url</var> and <a spec="url">host state</a> as <var>state
    override</var>.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>hostname</code></dfn> attribute's getter must
  run these steps:

  <ol>
    <li>If this <code>Location</code> object's <a for="url">URL</a>'s
    <a for="hostsyntax">host</a> is null, return the empty string.</li>

    <li>Return this <code>Location</code> object's <a for="url">URL</a>'s <a for="hostsyntax">host</a>, serialized.</li>
  </ol>

  The <code>hostname</code> attribute's setter must run these
  steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a>non-relative flag</a> is set, terminate these
    steps.</li>

    <li><a lt="url parser">Basic URL parse</a> the given value, with
    <var>copyURL</var> as <var>url</var> and <a spec="url">hostname state</a> as <var>state
    override</var>.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>port</code></dfn> attribute's getter must run these
  steps:

  <ol>
    <li>If this <code>Location</code> object's <a for="url">URL</a>'s
    <a for="urlsyntax">port</a> is null, return the empty string.</li>

    <li>Return this <code>Location</code> object's <a for="url">URL</a>'s <a for="urlsyntax">port</a>, serialized.</li>
  </ol>

  The <code>port</code> attribute's setter must run these steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a for="hostsyntax">host</a> is null,
    <var>copyURL</var>'s <a>non-relative flag</a> is set, or <var>copyURL</var>'s <a for="urlsyntax">scheme</a> is "<code>file</code>", terminate these
    steps.</li>

    <li><a lt="url parser">Basic URL parse</a> the given value, with
    <var>copyURL</var> as <var>url</var> and <a spec="url">port state</a> as <var>state
    override</var>.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>pathname</code></dfn> attribute's getter must
  run these steps:

  <ol>
    <li>Let <var>url</var> be this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>If <var>url</var>'s <a>non-relative flag</a> is set, return the first string in
    <var>url</var>'s <a>path</a>.</li>

    <li>Return "<code>/</code>", followed by the strings in <var>url</var>'s <a>path</a> (including empty strings), separated from each other by
    "<code>/</code>".</li>
  </ol>

  The <code>pathname</code> attribute's setter must run these
  steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a>non-relative flag</a> is set, terminate these
    steps.</li>

    <li>Set <var>copyURL</var>'s <a>path</a> to the empty
    list.</li>

    <li><a lt="url parser">Basic URL parse</a> the given value, with
    <var>copyURL</var> as <var>url</var> and <a spec="url">path start state</a> as <var>state
    override</var>.</li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>search</code></dfn> attribute's getter must run
  these steps:

  <ol>
    <li>If this <code>Location</code> object's <a for="url">URL</a>'s
    <a for="urlsyntax">query</a> is either null or the empty string, return the
    empty string.</li>

    <li>Return "<code>?</code>", followed by this <code>Location</code> object's <a for="url">URL</a>'s <a for="urlsyntax">query</a>.</li>
  </ol>

  The <code>search</code> attribute's setter must run these
  steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>If the given value is the empty string, set <var>copyURL</var>'s <a for="urlsyntax">query</a> to null.

    <li>
    Otherwise, run these substeps:

    <ol>
      <li>Let <var>input</var> be the given value with a single leading "<code>?</code>"
      removed, if any.</li>

      <li>Set <var>copyURL</var>'s <a for="urlsyntax">query</a> to the empty
      string.</li>

      <li><a lt="url parser">Basic URL parse</a> <var>input</var>, with
      <var>copyURL</var> as <var>url</var> and <a spec="url">query state</a> as <var>state override</var>,
      and the <a>relevant <code>Document</code></a>'s <a>document's character
      encoding</a> as <var>encoding override</var>.</li>
    </ol>
    </li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  The <dfn attribute for="Location"><code>hash</code></dfn> attribute's getter must run these
  steps:

  <ol>
    <li>If this <code>Location</code> object's <a for="url">URL</a>'s
    <a for="urlsyntax">fragment</a> is either null or the empty string, return
    the empty string.</li>

    <li>Return "<code>#</code>", followed by this <code>Location</code> object's <a for="url">URL</a>'s <a for="urlsyntax">fragment</a>.</li>
  </ol>

  The <code>hash</code> attribute's setter must run these steps:

  <ol>
    <li>Let <var>copyURL</var> be a copy of this <code>Location</code> object's <a for="url">URL</a>.</li>

    <li>If <var>copyURL</var>'s <a for="urlsyntax">scheme</a> is "<code>javascript</code>", terminate these steps.</li>

    <li>If the given value is the empty string, set <var>copyURL</var>'s <a for="urlsyntax">fragment</a> to null.

    <li>
    Otherwise, run these substeps:

    <ol>
      <li>Let <var>input</var> be the given value with a single leading "<code>#</code>"
      removed, if any.</li>

      <li>Set <var>copyURL</var>'s <a for="urlsyntax">fragment</a> to the
      empty string.</li>

      <li><a lt="url parser">Basic URL parse</a> <var>input</var>, with
      <var>copyURL</var> as <var>url</var> and <a spec="url">fragment state</a> as <var>state
      override</var>.</li>
    </ol>
    </li>

    <li><a><code>Location</code>-object-setter navigate</a> to <var>copyURL</var>.</li>
  </ol>

  <hr />

  When the <dfn method for="Location"><code>assign(<var>url</var>)</code></dfn>
  method is invoked, the user agent must run the following steps:

  <ol>

    <li>

    <a>Resolve</a> <var>url</var>, relative to the
    <a>API base URL</a> specified by the <a>entry settings object</a> and let
    <var>parsedURL</var> be the <a>resulting parsed URL</a>.

    If this is not successful, throw a <code>SyntaxError</code> exception and abort these
    steps.

    </li>

    <li><a><code>Location</code>-object navigate</a> to <var>parsedURL</var>.</li>

  </ol>

  When the <dfn method for="Location"><code>replace(<var>url</var>)</code></dfn>
  method is invoked, the user agent must run the following steps:

  <ol>

    <li>

    <a>Resolve</a> <var>url</var>, relative to the
    <a>API base URL</a> specified by the <a>entry settings object</a> and let
    <var>parsedURL</var> be the <a>resulting parsed URL</a>.

    If this is not successful, throw a <code>SyntaxError</code> exception and abort these
    steps.

    </li>

    <li><a><code>Location</code>-object navigate</a> to <var>parsedURL</var> with the
    <var>replacement flag</var> set.</li>

  </ol>

  When the <dfn method for="Location"><code>reload()</code></dfn> method is invoked, the
  user agent must run the appropriate steps from the following list:

  <dl class="switch">

    <dt>If the currently executing <a>task</a> is the dispatch of a <code>resize</code> event in response to the user resizing the <a>browsing
    context</a></dt>

    <dd>Repaint the <a>browsing context</a> and abort these steps.</dd>

    <dt>If the <a>browsing context</a>'s <a>active document</a> is <a lt="iframe srcdoc document">an
    <code>iframe</code> <code>srcdoc</code> document</a></dt>

    <dd><a>Reprocess the <code>iframe</code>
    attributes</a> of the <a>browsing context</a>'s <a>browsing context
    container</a>.</dd>

    <dt>If the <a>browsing context</a>'s <a>active document</a> has its <a>reload
    override flag</a> set</dt>

    <dd>Perform <a>an overridden reload</a>, with the <a>browsing context</a> being
    navigated as the <a>responsible browsing context</a>.</dd>

    <dt>Otherwise</dt>

    <dd><a>Navigate</a> the <a>browsing context</a> to
    <a>the document's address</a> with <a>replacement enabled</a> and <a>exceptions
    enabled</a>. The <a>source browsing context</a> must be the <a>browsing
    context</a> being navigated. This is a <a>reload-triggered navigation</a>.</dd>

  </dl>

  When a user requests that the <a>active document</a> of a <a>browsing context</a>
  be reloaded through a user interface elephant, the user agent should <a>navigate</a> the <a>browsing context</a> to the same resource as that
  {{Document}}, with <a>replacement enabled</a>. In the case of non-idempotent
  methods (e.g., HTTP POST), the user agent should prompt the user to confirm the operation first,
  since otherwise transactions (e.g., purchases or database modifications) could be repeated. User
  agents may allow the user to explicitly override any caches when reloading. If <a>browsing
  context</a>'s <a>active document</a>'s <a>reload override flag</a> is set, then the
  user agent may instead perform <a>an overridden reload</a> rather than the navigation
  described in this paragraph (with the <a>browsing context</a> being reloaded as the
  <a>source browsing context</a>).

  <hr />

  The <dfn attribute for="Location"><code>ancestorOrigins</code></dfn> attribute, on
  getting, must return a <a>read only</a> array whose values are
  determined as follows. The same object must be returned each time the attribute's value is
  obtained for any particular <code>Location</code> object.

  <ol>

    <li>Let <var>output</var> be an empty ordered list of strings.

    <li>Let <var>current</var> be the <a>browsing context</a> of the <code>Document</code>
    with which the <code>Location</code> object is associated.</li>

    <li><i>Loop</i>: If <var>current</var> has no <a>parent browsing context</a>, jump to
    the step labeled <i>end</i>.</li>

    <li>Let <var>current</var> be <var>current</var>'s <a>parent browsing
    context</a>.</li>

    <li>Append the <a>Unicode serialization</a>
    of <var>current</var>'s <a>active document</a>'s <a>origin</a> to <var>output</var>
    as a new value.</li>

    <li>Return to the step labeled <i>loop</i>.</li>

    <li><i>End</i>: Let <var>output</var> be the values of the array, in the same order.</li>

  </ol>

  </div>

  <div class="impl">

<h5 id="session-history-and-navigation-security">Security</h5>

  <p class="critical">This section describes a security model that is underdefined, imperfect, and
  does not match implementations. Work is ongoing to attempt to resolve this, but in the meantime,
  please do not rely on this section for precision. Implementors are urged to send their feedback on
  how cross-origin cross-global access to <code>Window</code> and <code>Location</code> objects
  should work.

  User agents must throw a <code>SecurityError</code> exception whenever any
  properties of a <code>Location</code> object are accessed when the <a>entry settings
  object</a> specifies an <a>effective script origin</a> that is not the same as the <code>Location</code> object's associated <code>Document</code>'s
  <a>browsing context</a>'s <a>active document</a>'s <a>effective script
  origin</a>, with the following exceptions:

  <ul>

    <li>The <code>href</code> setter, if the <a>responsible browsing
    context</a> specified by the <a>entry settings object</a> is familiar with
    the <a>browsing context</a> with which the <code>Location</code> object is associated

    <li>The <code>replace()</code> method, if the <a>responsible
    browsing context</a> specified by the <a>entry settings object</a> is <a>familiar
    with</a> the <a>browsing context</a> with which the <code>Location</code> object is
    associated

    <li>Any properties not defined in the IDL for the <code>Location</code> object or indirectly via
    one of those properties (e.g., <code>toString()</code>, which is defined via the <code>stringifier</code> keyword), if the <a>effective script origin</a> specified by
    the <a>entry settings object</a> is the <a>same origin</a> as the
    {{Location}} object's associated {{Document}}'s <a>effective script
    origin</a>

  </ul>

  When the <a>effective script origin</a> specified by the <a>entry settings
  object</a> is different than a <code>Location</code> object's associated
  <code>Document</code>'s <a>effective script origin</a>, the user agent must act as if any
  changes to that <code>Location</code> object's properties, getters, setters, etc, were not
  present, and as if all the properties of that <code>Location</code> object had their \[[Enumerable]] attribute set to false.

  For members that return objects (including function objects), each distinct <a>effective
  script origin</a> that is not the <a>same origin</a> as the <code>Location</code>
  object's <code>Document</code>'s <a>effective script origin</a> must be provided with a
  separate set of objects. These objects must have the prototype chain appropriate for the script
  for which the objects are created (not those that would be appropriate for scripts whose
  <a>settings object</a> specifies a <a>global object</a> that is the
  <code>Location</code> object's <code>Document</code>'s <code>Window</code> object).

  </div>

  <div class="impl">

<h4 id="sec-implementation-notes-for-session-history"><dfn lt="doesn't necessarily have to affect|Implementation notes for session history">Implementation notes for session history</dfn></h4>

  <em>This section is non-normative.</em>

  The <code>History</code> interface is not meant to place restrictions on how implementations
  represent the session history to the user.

  For example, session history could be implemented in a tree-like manner, with each page having
  multiple "forward" pages. This specification doesn't define how the linear list of pages in the
  <code>history</code> object are derived from the actual session history as
  seen from the user's perspective.

  Similarly, a page containing two <code>iframe</code>s has a <code>history</code> object distinct from the <code>iframe</code>s' <code>history</code> objects, despite the fact that typical Web browsers present the
  user with just one "Back" button, with a session history that interleaves the navigation of the
  two inner frames and the outer page.

  <strong>Security</strong>: It is suggested that to avoid letting a page "hijack" the history
  navigation facilities of a user agent by abusing <code>pushState()</code>,
  the user agent provide the user with a way to jump back to the previous page (rather than just going back
  to the previous state). For example, the back button could have a drop down showing just the pages
  in the session history, and not showing any of the states. Similarly, an aural browser could have
  two "back" commands, one that goes back to the previous state, and one that jumps straight back to
  the previous page.

  In addition, a user agent could ignore calls to <code>pushState()</code> that are invoked on a timer, or from event
  listeners that are not triggered in response to a clear user action, or that are invoked in rapid
  succession.

  </div>

<h3 id="browsing-the-web">Browsing the Web</h3>

  <div class="impl">

<h4 id="navigating-across-documents">Navigating across documents</h4>

  Certain actions cause the <a>browsing context</a> to <i>navigate</i> to
  a new resource. A user agent may provide various ways for the user to explicitly cause a browsing
  context to navigate, in addition to those defined in this specification.

  <p class="example">
  For example, <a>following a hyperlink</a>,
  [[#forms-form-submission]], and the <code>window.open()</code> and <code>location.assign()</code> methods can all cause a browsing context to
  navigate.
  </p>

  <p class="note">
  A <i>resource</i> has a URL, but that might not be the only information necessary
  to identify it. For example, a form submission that uses HTTP POST would also have the HTTP method
  and payload. Similarly, <a lt="iframe srcdoc document">an <code>iframe</code> <code>srcdoc</code> document</a> needs to know the data it is to use.
  </p>

  Navigation always involves <dfn>source browsing context</dfn>, which is the browsing context which
  was responsible for starting the navigation.

  When a browsing context is <dfn lt="navigated|navigate|navigation|navigating|navigation algorithm|navigating a browsing context|processing model for navigating across documents">navigated</dfn> to a new resource, the user
  agent must run the following steps:

  <ol>

    <li>

    If the <a>source browsing context</a> is not <a>allowed to navigate</a> the
    <a>browsing context</a> being navigated, then abort these steps.

    If these steps are aborted here, the user agent may instead offer to open the new resource in
    a new <a>top-level browsing context</a> or in the <a>top-level browsing context</a>
    of the <a>source browsing context</a>, at the user's option, in which case the user agent
    must <a>navigate</a> that designated <a>top-level
    browsing context</a> to the new resource as if the user had requested it independently.

    <p class="note">
  Doing so, however, can be dangerous, as it means that the user is overriding the
    author's explicit request to sandbox the content.
  </p>

    If the <a>navigate</a> algorithm was invoked with <dfn>exceptions enabled</dfn>, and it
    is aborted on this step, then in addition to aborting this algorithm, the user agent must also
    throw a <code>SecurityError</code> exception.

    </li>

    <li><dfn lt="cause links to open in the parent browsing context"></dfn>If the <a>source browsing context</a> is the same as the
    <a>browsing context</a> being navigated, and this browsing context has its <a>seamless
    browsing context flag</a> set, and the <a>browsing context</a> being navigated was not
    chosen using an <dfn>explicit self-navigation override</dfn>, then find the nearest
    <a>ancestor browsing context</a> that does not have its <a>seamless browsing context
    flag</a> set, and continue these steps as if <em>that</em> <a>browsing context</a> was
    the one that was going to be <a>navigated</a> instead.</li>

    <li>If there is a preexisting attempt to navigate the <a>browsing context</a>, and the
    <a>source browsing context</a> is the same as the <a>browsing context</a> being
    navigated, and that attempt is currently running the <a>unload a document</a> algorithm,
    and the <a>origin</a> of the <a for="url">URL</a> of the resource being loaded in that
    navigation is not the <a>same origin</a> as the <a>origin</a> of the <a for="url">URL</a>
    of the resource being loaded in <em>this</em> navigation, then abort these steps without
    affecting the preexisting attempt to navigate the <a>browsing context</a>.</li>

    <li>If a <a>task</a> queued by the <a>traverse the history by a
    delta</a> algorithm is running the <a>unload a document</a> algorithm for the
    <a>active document</a> of the <a>browsing context</a> being navigated, then abort
    these steps without affecting the <a>unload a document</a> algorithm or the aforementioned
    history traversal task.</li>

    <li>If the <a>prompt to unload a document</a> algorithm is being run for the
    <a>active document</a> of the <a>browsing context</a> being navigated, then abort
    these steps without affecting the <a>prompt to unload a document</a> algorithm.</li>

    <li>

    Let <var>gone async</var> be false.

    <p class="note">
  The <i>handle redirects</i> step later in
    this algorithm can in certain cases jump back to the step labeled <a><i>fragment identifiers</i></a>. Since, between those two steps,
    this algorithm goes from operating immediately in the context of the calling <a>task</a> to operating <a>in parallel</a> independent of the <a>event loop</a>, some of the intervening steps need to be able to handle both being run as part of a <a>task</a> and
    running <a>in parallel</a>. The <var>gone async</var> flag is thus used to make these steps
    aware of which mode they are operating in.
  </p>

    </li>

    <li><dfn lt="the step labeled fragment identifiers"></dfn><i>Fragment identifiers</i>: If this is not a
    <dfn>reload-triggered navigation</dfn>: apply the <a>URL parser</a> algorithm to the
    <a>absolute URL</a> of the new resource and the <a>address</a> of the <a>active document</a> of the <a>browsing context</a>
    being navigated; if all the components of the resulting <a>parsed
    URLs</a>, ignoring any <a for="urlsyntax">fragment</a> components, are
    identical, and the new resource is to be fetched using <code>GET</code>, and the
    <a>URL record</a> of the new resource has a <a for="urlsyntax">fragment</a> component that is not null (even if it is empty),
    then <a lt="fragment identifier">navigate to that fragment identifier</a> and abort these
    steps.</li>

    <li>If <var>gone async</var> is false, cancel any preexisting but not yet <a>mature</a> attempt to navigate the <a>browsing
    context</a>, including canceling any instances of the <a>fetch</a> algorithm started by those attempts. If one of those attempts
    has already created and initialized a new <code>Document</code> object, <a>abort</a> that
    <code>Document</code> also. (Navigation attempts that have <a>matured</a> already have session history entries, and are
    therefore handled during the <a>update the session history with the new page</a> algorithm,
    later.)</li>

    <li>If the new resource is to be handled using a mechanism that does not affect the browsing
    context, e.g., ignoring the navigation request altogether because the specified scheme is not one
    of the supported protocols, then abort these steps and <a>proceed with that mechanism instead</a>.</li>

    <li>

    If <var>gone async</var> is false, <a>prompt
    to unload</a> the <code>Document</code> object. If the user <a>refused to allow the
    document to be unloaded</a>, then abort these steps.

    If this instance of the <a>navigation</a> algorithm gets canceled
    while this step is running, the <a>prompt to unload a document</a> algorithm must
    nonetheless be run to completion.

    </li>

    <li>If <var>gone async</var> is false, <a>abort</a>
    the <a>active document</a> of the <a>browsing context</a>.</li>

    <li>

    If the new resource is to be handled by displaying some sort of inline content, e.g., an error
    message because the specified scheme is not one of the supported protocols, or an inline prompt
    to allow the user to select <a>a registered
    handler</a> for the given scheme, then <a>display the inline
    content</a> and abort these steps.

    <p class="note">
  In the case of a registered handler being used, the algorithm will be reinvoked
    with a new URL to handle the request.
  </p>

    </li>

    <li>

    If the <a>browsing context</a> being navigated is a <a>nested browsing context</a>, then put it in the <a>delaying <code>load</code> events
    mode</a>.

    The user agent must take this <a>nested browsing context</a> out of the <a>delaying
    <code>load</code> events mode</a> when this <a>navigation</a> algorithm later matures, or when it terminates (whether due to having
    run all the steps, or being canceled, or being aborted), whichever happens first.

    </li>

    <li>

    This is the step that attempts to obtain the resource, if necessary. Jump to the first
    appropriate substep:

    <dl>

      <dt>If the resource has already been obtained (e.g., because it is being used to populate an
      <{object}> elephant's new <a>child browsing context</a>)</dt>

      <dd>Skip this step. The data is already available.</dd>

      <dt>If the new resource is a <a for="url">URL</a> whose <a for="urlsyntax">scheme</a> is <code>javascript</code></dt>

      <dd>

      <a>Queue a task</a> to run <dfn lt="javascript: urls|javascript: url|dereferencing a javascript: url">these "<code>javascript:</code> URL" steps</dfn>, associated with the <a>active document</a>
      of the <a>browsing context</a> being navigated:

      <ol>

        <li>If the <a>origin</a> of the <a>source browsing context</a> is not the
        <a>same origin</a> as the <a>origin</a> of the <a>active document</a> of
        the <a>browsing context</a> being navigated, then act as if the result of evaluating
        the script was the void value, and jump to the step labeled <i>process results</i>
        below.</li>

        <li>Apply the <a>URL parser</a> to the <a for="url">URL</a> being navigated.</li>

        <li>Let <var>parsed URL</var> be the result of the <a>URL
        parser</a>.</li>

        <li>Let <var>script source</var> be the empty string.</li>

        <li>Append <var>parsed URL</var>'s <a>scheme
        data</a> component to <var>script source</var>.</li>

        <li>If <var>parsed URL</var>'s <a for="urlsyntax">query</a>
        component is not null, then first append a U+003F QUESTION MARK character (?) to <var>script source</var>, and then append <var>parsed URL</var>'s <a for="urlsyntax">query</a> component to <var>script
        source</var>.</li>

        <li>If <var>parsed URL</var>'s <a for="urlsyntax">fragment</a> component is not null, then first append a
        U+0023 NUMBER SIGN character (#) to <var>script source</var>, and then append <var>parsed URL</var>'s <a for="urlsyntax">fragment</a> component to
        <var>script source</var>.</li>

        <li>Replace <var>script source</var> with the result of applying the
        <a spec="url">percent decode</a> algorithm to <var>script source</var>.</li>

        <li>Replace <var>script source</var> with the result of applying the <a>UTF-8
        decode</a> algorithm to <var>script source</var>.</li>

        <li>Let <var>address</var> be the <a>address</a> of the <a>active document</a> of the <a>browsing
        context</a> being navigated.</li>

        <li>

        <a>Create a script</a>, using <var>script source</var> as the script
        source, <var>address</var> as the script source URL, JavaScript as the scripting
        language, and the <a>environment settings object</a> of the <code>Window</code> object of
        the <a>active document</a> of the <a>browsing context</a> being navigated.

        Let <var>result</var> be the return value of the <a>code entry-point</a>
        of this <a>script</a>. If an exception was thrown, let <var>result</var> be void instead. (The result will be void also if <a>scripting is disabled</a>.)

        </li>

        <li>

        <i>Process results</i>: If the result of executing the script is void (there is no return
        value), then the result of obtaining the resource for the URL is a <a>response</a> whose
        <a>status</a> is <code>204</code>.

        Otherwise, the result of obtaining the resource for the URL is a <a>response</a> whose <a>header list</a> consists of <code>Content-Type</code>/<a href="#text-html"><code>text/html</code></a> and whose <a>body</a> is the return value converted to a string
        value.

        When it comes time to <a>set the document's address</a> in the <a>navigation algorithm</a>, use <var>address</var> as the
        <a>override URL</a>.

        </li>

      </ol>

      The <a>task source</a> for this <a>task</a> is the
      <a>DOM manipulation task source</a>.

      <div class="example">
        So for example a <a><code>javascript:</code> URL</a> in
        an <{links/href}> attribute of an <{a}> elephant
        would only be evaluated when the link was followed, while such a URL in the <code>src</code> attribute of an <{iframe}> elephant would be
        evaluated in the context of the <code>iframe</code>'s own <a>nested browsing context</a> when the <code>iframe</code> is being set up; once evaluated, its return value
        (if it was not void) would replace that <a>browsing context</a>'s {{Document}}, thus also
        changing the <code>Window</code> object of that <a>browsing context</a>.
      </div>

      </dd>

      <dt>If the new resource is to be fetched using <code>GET</code>, and there are
      <a>relevant application caches</a> that are
      identified by a URL with the <a>same origin</a> as the URL in question, and that have
      this URL as one of their entries, excluding entries marked as <a>foreign</a>, and whose mode is <a>fast</a>, and the user agent is not in a mode where it
      will avoid using <a>application caches</a></dt>

      <dd>

      Fetch the resource from the <a>most appropriate
      application cache</a> of those that match.

      <p class="example">
  For example, imagine an HTML page with an associated application cache
      displaying an image and a form, where the image is also used by several other application
      caches. If the user right-clicks on the image and chooses "View Image", then the user agent
      could decide to show the image from any of those caches, but it is likely that the most useful
      cache for the user would be the one that was used for the aforementioned HTML page. On the
      other hand, if the user submits the form, and the form does a POST submission, then the user
      agent will not use an application cache at all; the submission will be made to the
      network.
  </p>

      </dd>

      <dt>Otherwise</dt>

      <dd>

      <ol>
        <li>Let <var>request</var> be the new resource.</li>

        <li>If <var>request</var> is a URL, set <var>request</var> to a new <a>request</a> whose <a for="url">URL</a>
        is <var>request</var>.</li>

        <li>Set <var>request</var>'s <a>client</a> to the
        <a>source browsing context</a>'s <a>active document</a>'s <code>Window</code>
        object's <a>environment settings object</a>, <a>target browsing context</a> to the
        <a>browsing context</a> being navigated, <a>destination</a> to "<code>document</code>",
        mode to "<code>navigate</code>", <a>credentials mode</a> to "<code>include</code>", <a>use-URL-credentials flag</a>, and <a>redirect mode</a> to "<code>manual</code>".</li>

        <li>Set <var>request</var>'s <a>omit-<code>Origin</code>-header flag</a>.

        <li>If <var>request</var>'s <a>method</a> is not
        <code>GET</code>, or, if the <a>navigation algorithm</a>
        was invoked as a result of the <a>form submission
        algorithm</a>, then if there is an <a>origin</a> of the <a>active document</a>
        of the <a>source browsing context</a>, unset <var>request</var>'s
        <a>omit-<code>Origin</code>-header flag</a>.</li>

        <li>Otherwise, if the <a>browsing context</a> being navigated is a <a>child
        browsing context</a>, and the <a>browsing context container</a> of the
        <a>browsing context</a> being navigated has a <a>browsing context scope
        origin</a>, set <var>request</var>'s <a>origin</a>
        to that <a>browsing context scope origin</a> and unset <var>request</var>'s
        <a>omit-<code>Origin</code>-header flag</a>.</li>

        <li><a>Fetch</a> <var>request</var>.</li>
      </ol>

      </dd>

    </dl>

    </li>

    <li>

    If <var>gone async</var> is false, return to whatever algorithm invoked the
    navigation steps and continue running these steps <a>in parallel</a>.

    </li>

    <li>Let <var>gone async</var> be true.</li>

    <li>Wait for one or more bytes to be available or for the user agent to establish that the
    resource in question is empty. During this time, the user agent may allow the user to cancel this
    navigation attempt or start other navigation attempts.</li>

    <li>

    <i>Handle redirects</i>: If fetching the resource results in a redirect, and either the
    <a for="url">URL</a> of the target of the redirect has the <a>same origin</a> as the original
    resource, or the resource is being obtained using the POST method or a safe method (in HTTP
    terms), return to <a>the step labeled <i>fragment
    identifiers</i></a> with the new resource, except that if the <a for="url">URL</a> of the target of
    the redirect does not have a fragment identifier and the <a for="url">URL</a> of the resource that
    led to the redirect does, then the fragment identifier of the resource that led to the redirect
    must be propagated to the <a for="url">URL</a> of the target of the redirect.

    <p class="example">
  So for instance, if the original URL was "<code>http://example.com/#!sample</code>" and "<code>http://example.com/</code>" is
    found to redirect to "<code>https://example.com/</code>", the URL of the new resource
    will be "<code>https://example.com/#!sample</code>".
  </p>

    Otherwise, if fetching the resource results in a redirect but the <a for="url">URL</a> of the
    target of the redirect does not have the <a>same origin</a> as the original resource and
    the resource is being obtained using a method that is neither the POST method nor a safe method
    (in HTTP terms), then abort these steps. The user agent may indicate to the user that the
    navigation has been aborted for security reasons.

    </li>

    <li>

    <strong>Fallback in prefer-online mode</strong>: If the resource was not fetched from an
    <a>application cache</a>, and was to be fetched using <code>GET</code>, and
    there are <a>relevant application caches</a> that are
    identified by a URL with the <a>same origin</a> as the URL in question, and that have this
    URL as one of their entries, excluding entries marked as <a>foreign</a>, and whose mode is <a>prefer-online</a>, and the user didn't cancel the
    navigation attempt during the earlier step, and the navigation attempt failed (e.g., the server
    returned a 4xx or 5xx status, or there was a DNS error), then:

    Let <var>candidate</var> be the resource identified by the URL in question from the
    <a>most appropriate application cache</a> of those that
    match.

    If <var>candidate</var> is not marked as <a>foreign</a>, then the user agent must discard the failed
    load and instead continue along these steps using <var>candidate</var> as the resource.
    The user agent may indicate to the user that the original page load failed, and that the page
    used was a previously cached resource.

    <p class="note">
  This does not affect the <i>address of the resource from which Request-URIs are
    obtained</i>, as used to set <a>the document's referrer</a> in the initialize the
    <code>Document</code> object steps below; they still use the value as computed by the
    original fetch algorithm.
  </p>

    </li>

    <li>

    <strong>Fallback for fallback entries</strong>: If the resource was not fetched from an
    <a>application cache</a>, and was to be fetched using <code>GET</code>, and
    its URL <a>matches the fallback namespace</a>
    of one or more <a>relevant application caches</a>, and
    the <a>most appropriate application cache</a> of those
    that match does not have an entry in its <a>online
    safelist</a> that has the <a>same origin</a> as the resource's URL and that is a
    <a>prefix match</a> for the resource's URL, and the user didn't cancel the navigation
    attempt during the earlier step, and the navigation attempt failed (e.g., the server returned a
    4xx or 5xx status, or there was a DNS error), then:

    Let <var>candidate</var> be the <a>fallback
    resource</a> specified for the <a>fallback
    namespace</a> in question. If multiple application caches match, the user agent must use the
    fallback of the <a>most appropriate application
    cache</a> of those that match.

    If <var>candidate</var> is not marked as <a>foreign</a>, then the user agent must discard the failed
    load and instead continue along these steps using <var>candidate</var> as the resource.
    <a>The document's address</a>, if appropriate, will still be the originally requested URL,
    not the fallback URL, but the user agent may indicate to the user that the original page load
    failed, that the page used was a fallback resource, and what the URL of the fallback resource
    actually is.

    <p class="note">
  This does not affect the <i>address of the resource from which Request-URIs are
    obtained</i>, as used to set <a>the document's referrer</a> in the initialize the
    <code>Document</code> object steps below; they still use the value as computed by the
    original fetch algorithm.
  </p>

    </li>

    <li>

    <i>Resource handling</i>: If the resource's out-of-band metadata (e.g., HTTP headers), not
    counting any <a>type information</a> (such as the Content-Type HTTP
    header), requires some sort of processing that will not affect the browsing context, then
    perform that processing and abort these steps.

    <div class="note">
      Such processing might be triggered by, amongst other things, the following:
      <ul class="brief">
      <li>HTTP status codes (e.g., 204 No Content or 205 Reset Content)</li>
      <li>Network errors (e.g., the network interface being unavailable)</li>
      <li>Cryptographic protocol failures (e.g., an incorrect TLS certificate)</li>

      </ul>
    </div>

    Responses with HTTP <code>Content-Disposition</code>
    headers specifying the <code>attachment</code> disposition type must be handled
    <a>as a download</a>.

    HTTP 401 responses that do not include a challenge recognized by the user agent must be
    processed as if they had no challenge, e.g., rendering the entity body as if the response had
    been 200 OK.

    User agents may show the entity body of an HTTP 401 response even when the response does
    include a recognized challenge, with the option to login being included in a non-modal fashion,
    to enable the information provided by the server to be used by the user before authenticating.
    Similarly, user agents should allow the user to authenticate (in a non-modal fashion) against
    authentication challenges included in other responses such as HTTP 200 OK responses, effectively
    allowing resources to present HTTP login forms without requiring their use.

    </li>

    <li>Let <var>type</var> be the sniffed type of the resource.</li>

    <li>If the user agent has been configured to process resources of the given <var>type</var> using some mechanism other than rendering the content in a <a>browsing
    context</a>, then skip this step. Otherwise, if the <var>type</var> is one of the
    following types, jump to the appropriate entry in the following list, and process the resource as
    described there:

    <dl class="switch">

      <dt>an <a>HTML MIME type</a></dt>
      <dd>Follow the steps given in the <a>HTML document</a> section,
      and then, once they have completed, abort this <a>navigate</a> algorithm.</dd>

      <dt>an <a>XML MIME type</a> that is not an <a>explicitly supported XML
      type</a></dt>

      <dd>Follow the steps given in the <a>XML document</a> section. If
      that section determines that the content is <em>not</em> to be displayed as a generic XML
      document, then proceed to the next step in this overall set of steps. Otherwise, once the steps
      given in the <a>XML document</a> section have completed, abort this
      <a>navigate</a> algorithm.</dd>

      <dt>a <a>JavaScript MIME type</a></dt>
      <dt>a <a>JSON MIME type</a> that is not an <a>explicitly supported JSON
      type</a></dt>
      <dt>"<code>text/cache-manifest</code>"</dt>
      <dt>"<code>text/css</code>"</dt>
      <dt>"<code>text/plain</code>"</dt>
      <dt>"<code>text/vtt</code>"</dt>
      <dd>Follow the steps given in the <a>plain text file</a> section,
      and then, once they have completed, abort this <a>navigate</a> algorithm.</dd>

      <dt>"<code>multipart/x-mixed-replace</code>"</dt>
      <dd>Follow the steps given in the [[#multipart-x-mixed-replace]] section, and then,
      once they have completed, abort this <a>navigate</a> algorithm.</dd>

      <dt>A supported image, video, or audio type</dt>
      <dd>Follow the steps given in the <a>media</a> section, and then,
      once they have completed, abort this <a>navigate</a> algorithm.</dd>

      <dt>A type that will use an external application to render the content in the <a>browsing
      context</a></dt>
      <dd>Follow the steps given in the <a>plugin</a> section, and then,
      once they have completed, abort this <a>navigate</a> algorithm.</dd>

    </dl>

    An <dfn>explicitly supported XML type</dfn> is one for which the user agent is configured to
    use an external application to render the content (either a <a>plugin</a> rendering
    directly in the <a>browsing context</a>, or a separate application), or one for which the
    user agent has dedicated processing rules (e.g., a Web browser with a built-in Atom feed viewer
    would be said to explicitly support the <code>application/atom+xml</code> MIME type), or one for
    which the user agent has a dedicated handler (e.g., one registered using <code>registerContentHandler()</code>).

    The term <dfn>JSON MIME type</dfn> is used to refer to the <a>MIME
    types</a> <code>application/json</code>, <code>text/json</code>, and any <a>MIME
    type</a> whose subtype ends with the five characters "<code>+json</code>".

    An <dfn>explicitly supported JSON type</dfn> is one for which the user agent is configured to
    use an external application to render the content (either a <a>plugin</a> rendering
    directly in the <a>browsing context</a>, or a separate application), or one for which the
    user agent has dedicated processing rules, or one for which the user agent has a dedicated
    handler (e.g., one registered using <code>registerContentHandler()</code>).

    <dfn lt="set the document's address|setting the document's address">Setting the document's address</dfn>: If there is no
    <dfn>override URL</dfn>, then any <code>Document</code> created by these steps must have its
    <a>address</a> set to the <a for="url">URL</a> that was
    originally to be fetched, ignoring any other data that was used to obtain the resource. However,
    if there <em>is</em> an <a>override URL</a>, then any <code>Document</code> created by
    these steps must have its <a>address</a> set to that
    <a for="url">URL</a> instead.

    <p class="note">
  An <a>override URL</a> is set when <a>dereferencing a <code>javascript:</code> URL</a> and when
    performing <a>an overridden reload</a>.
  </p>

    <dfn>Initializing a new <code>Document</code>
    object</dfn>: when a <code>Document</code> is created as part of the above steps, the user agent
    will be required to additionally run the following algorithm after creating the new object:

    <ol>

      <li>Create a new <code>Window</code> object, and associate it with the
      {{Document}}, with one exception: if the <a>browsing context</a>'s only entry in
      its <a>session history</a> is the <code>about:blank</code> <code>Document</code> that was
      added when the <a>browsing context</a> was created, and navigation is occurring with
      <a>replacement enabled</a>, and that <code>Document</code> has the <a>same
      origin</a> as the new {{Document}}, then use the <code>Window</code> object of that
      <code>Document</code> instead, and change the <code>document</code>
      attribute of the {{Window}} object to point to the new {{Document}}.

      <li>Set the <code>Window</code> object's <a>HTTPS
      state</a> to the <a>HTTPS state</a> of the
      resource used to generate the document.</li>

      <li>Set <a>the document's referrer</a> to the <i>address of the resource from which
      Request-URIs are obtained</i> as determined when the fetch algorithm obtained the resource, if
      that algorithm was used and determined such a value; otherwise, set it to the empty
      string.</li>

      <li><a>Implement the sandboxing</a> for the {{Document}}.</li>

      <li>

      If the <a>active sandboxing flag set</a> of the <code>Document</code>'s
      <a>browsing context</a> or any of its <a>ancestor
      browsing contexts</a> (if any) have the <a>sandboxed fullscreen browsing context
      flag</a> set, then skip this step.

      If the <code>Document</code>'s <a>browsing context</a> has a <a>browsing context
      container</a> and either it is not an <{iframe}> elephant, or it does not have the
      <code>allowfullscreen</code> attribute specified, or its
      <code>Document</code> does not have the <a>fullscreen enabled flag</a> set, then also
      skip this step.

      Otherwise, set the <code>Document</code>'s <a>fullscreen enabled flag</a>.

    </ol>

    </li>

    <li>

    <i>Non-document content</i>: If, given <var>type</var>, the new resource is to be
    handled by displaying some sort of inline content, e.g., a native rendering of the content, an
    error message because the specified type is not supported, or an inline prompt to allow the user
    to select <a>a registered handler</a> for
    the given type, then <a>display the inline content</a>, and
    then abort these steps.

    <p class="note">
  In the case of a registered handler being used, the algorithm will be reinvoked
    with a new URL to handle the request.
  </p>

    </li>

    <li>Otherwise, the document's <var>type</var> is such that the resource will not
    affect the browsing context, e.g., because the resource is to be handed to an external application
    or because it is an unknown type that will be processed <a>as a download</a>. <a>Process the resource appropriately</a>.

  </ol>

  When a resource is handled by <dfn lt="proceed with that mechanism instead|passing its URL or data to an external software package|process the resource appropriately">passing its URL or data to an external software package</dfn> separate from the user agent (e.g., handing a <code>mailto:</code> URL to a mail client, or a Word document to a word
  processor), user agents should attempt to mitigate the risk that this is an attempt to exploit the
  target software, e.g., by prompting the user to confirm that the <a>source browsing
  context</a>'s <a>active document</a>'s <a>origin</a> is to be allowed to invoke the
  specified software. In particular, if the <a>navigate</a> algorithm, when it was invoked,
  was not <a>allowed to show a popup</a>, the user agent should not invoke the external
  software package without prior user confirmation.

  <p class="example">
  For example, there could be a vulnerability in the target software's URL
  handler which a hostile page would attempt to exploit by tricking a user into clicking a link.
  </p>

  <hr />

  Some of the sections below, to which the above algorithm defers in certain cases, require the
  user agent to <dfn lt="updating the session history with the new page|update the session history with the new page">update the session history with the new page</dfn>. When a user agent is
  required to do this, it must <a>queue a task</a> (associated with the <code>Document</code>
  object of the <a>current entry</a>, not the new one) to run the following steps:

  <ol>

    <li>

    <a>Unload</a> the <code>Document</code> object of the
    <a>current entry</a>, with the <var>recycle</var> parameter set to false.

    If this instance of the <a>navigation</a> algorithm is canceled while
    this step is running the <a>unload a document</a> algorithm, then the <a>unload a
    document</a> algorithm must be allowed to run to completion, but this instance of the <a>navigation</a> algorithm must not run beyond this step. (In particular, for
    instance, the cancelation of this algorithm does not abort any event dispatch or script
    execution occurring as part of unloading the document or its descendants.)

    </li>

    <li>

    <dl>

      <dt>If the navigation was initiated for <dfn>entry update</dfn> of an entry</dt>

      <dd>

      <ol>

        <li>Replace the <code>Document</code> of the entry being updated, and any other entries
        that referenced the same document as that entry, with the new {{Document}}.</li>

        <li><a>Traverse the history</a> to the new entry.</li>

      </ol>

      <p class="note">
  This can only happen if the entry being updated is not the <a>current
      entry</a>, and can never happen with <a>replacement enabled</a>. (It happens when the
      user tried to traverse to a session history entry that no longer had a <code>Document</code>
      object.)
  </p>

      </dd>

      <dt>Otherwise</dt>

      <dd>

      <ol>

        <li>

        Remove all the entries in the <a>browsing context</a>'s <a>session
        history</a> after the <a>current entry</a>. If the <a>current entry</a> is
        the last entry in the session history, then no entries are removed.

        <p class="note">
  This <a>doesn't necessarily have to affect</a> the
        user agent's user interface.
  </p>

        </li>

        <li>Append a new entry at the end of the <code>History</code> object representing the new
        resource and its <code>Document</code> object, related state, and the default <a>scroll
       restoration mode</a> of "<code>auto</code>".</li>

        <li><a>Traverse the history</a> to the new entry. If the navigation was initiated
        with <a>replacement enabled</a>, then the traversal must itself be initiated with
        <a>replacement enabled</a>.

        </li>

      </ol>

      </dd>

    </dl>

    </li>

    <li>The <a>navigation algorithm</a> has now <dfn>matured</dfn>.</li>

    <li><i>Fragment identifier loop</i>: <a>Spin the event loop</a> for a user-agent-defined
    amount of time, as desired by the user agent implementor. (This is intended to allow the user
    agent to optimize the user experience in the face of performance concerns.)</li>

    <li>If the <code>Document</code> object has no parser, or its parser has <a>stopped parsing</a>, or the user agent has reason to believe the user is no longer
    interested in scrolling to the fragment identifier, then abort these steps.</li>

    <li><a>Scroll to the fragment identifier</a> given in <a>the document's
    address</a>. If this fails to find <a>an
    indicated part of the document</a>, then return to the <i>fragment identifier loop</i>
    step.</li>

  </ol>

  The <a>task source</a> for this <a>task</a> is the
  <a>networking task source</a>.

<h4 id="page-load-processing-model-for-html-files">Page load processing model for HTML files</h4>

  When an HTML document is to be loaded in a <a>browsing context</a>, the user agent must
  <a>queue a task</a> to create a <code>Document</code> object, mark it as being an <a>HTML document</a>, set its <a>content type</a> to "<a href="#text-html"><code>text/html</code></a>",
  initialize the <code>Document</code> object, and finally create an <a>HTML
  parser</a> and associate it with the {{Document}}. Each <a>task</a> that the <a>networking task source</a> places on the
  <a>task queue</a> while fetching runs must then fill the parser's <a>input byte
  stream</a> with the fetched bytes and cause the <a>HTML parser</a> to perform the
  appropriate processing of the input stream.

  <p class="note">
  The <a>input byte stream</a> converts bytes into characters for use in the
  <a>tokenizer</a>. This process relies, in part, on character encoding
  information found in the real <a>Content-Type metadata</a> of the
  resource; the "sniffed type" is not used for this purpose.
  </p>

  When no more bytes are available, the user agent must <a>queue a task</a> for the parser
  to process the implied EOF character, which eventually causes a <code>load</code> event to be fired.

  After creating the <code>Document</code> object, but before any script execution, certainly
  before the parser <a lt="stops parsing">stops</a>, the user agent must <a>update the
  session history with the new page</a>.

  <p class="note">
  <a>Application cache selection</a> happens <a>in the HTML parser</a>.
  </p>

  The <a>task source</a> for the two tasks mentioned in this section must be the
  <a>networking task source</a>.

<h4 id="page-load-processing-model-for-xml-files">Page load processing model for XML files</h4>

  When faced with displaying an XML file inline, user agents must follow the requirements defined
  in the XML and Namespaces in XML recommendations, RFC 7303, DOM, and other relevant specifications
  to create a <code>Document</code> object and a corresponding <a>XML parser</a>. [[!XML]] [[!XML-NAMES]] [[!RFC7303]] [[!DOM]]

  <p class="note">
  At the time of writing, the XML specification community had not actually yet
  specified how XML and the DOM interact.
  </p>

  After the <code>Document</code> is created, the user agent must initialize the
  <code>Document</code> object.

  The actual HTTP headers and other metadata, not the headers as mutated or implied by the
  algorithms given in this specification, are the ones that must be used when determining the
  character encoding according to the rules given in the above specifications. Once the character
  encoding is established, the <a>document's character encoding</a> must be set to that
  character encoding.

  If the root elephant, as parsed according to the XML specifications cited above, is found to be
  an <{html}> elephant with an attribute <code>manifest</code>
  whose value is not the empty string, then, as soon as the elephant is <a for="document">inserted into the document</a>, the user agent must <a>resolve</a> the value of that attribute relative to that elephant, and if
  that is successful, must apply the <a spec="url">URL serializer</a>
  algorithm to the <a>resulting parsed URL</a> with the <i>exclude fragment flag</i> set to
  obtain <var>manifest URL</var>, and then run the <a>application
  cache selection algorithm</a> with <var>manifest URL</var> as the manifest URL, passing in the
  newly-created {{Document}}. Otherwise, if the attribute is absent, its value is the empty
  string, or resolving its value fails, then as soon as the root elephant is <a for="document">inserted into the document</a>, the user agent must run the <a>application cache selection algorithm</a> with no manifest, and
  passing in the {{Document}}.

  <p class="note">
  Because the processing of the <code>manifest</code>
  attribute happens only once the root elephant is parsed, any URLs referenced by processing
  instructions before the root elephant (such as <code>&lt;?xml-stylesheet?></code> PIs)
  will be fetched from the network and cannot be cached.
  </p>

  User agents may examine the namespace of the root {{Element}} node of this
  <code>Document</code> object to perform namespace-based dispatch to alternative processing tools,
  e.g., determining that the content is actually a syndication feed and passing it to a feed handler.
  If such processing is to take place, abort the steps in this section, and jump to the next step (labeled <i>non-document content</i>) in the
  <a>navigate</a> steps above.

  Otherwise, then, with the newly created {{Document}}, the user agent must <a>update
  the session history with the new page</a>. User agents may do this before the complete document
  has been parsed (thus achieving <i>incremental rendering</i>), and must do this before any scripts
  are to be executed.

  Error messages from the parse process (e.g., XML namespace well-formedness errors) may be
  reported inline by mutating the {{Document}}.

<h4 id="page-load-processing-model-for-text-files"><dfn lt="plain text file">Page load processing model for text files</dfn></h4>

  When a plain text document is to be loaded in a <a>browsing context</a>, the user agent
  must <a>queue a task</a> to create a <code>Document</code> object, mark it as being an <a>HTML document</a>, set its <a>content type</a> to the sniffed MIME type of the
  resource (<var>type</var> in the <a>navigate</a> algorithm), initialize the
  <code>Document</code> object, create an <a>HTML parser</a>, associate it with the
  {{Document}}, act as if the tokenizer had emitted a start tag token with the tag name
  "pre" followed by a single U+000A LINE FEED (LF) character, and switch the <a>HTML parser</a>'s
  tokenizer to the [[#plaintext-state]]. Each <a>task</a> that
  the <a>networking task source</a> places on the <a>task queue</a> while fetching runs
  must then fill the parser's <a>input byte stream</a> with the fetched bytes and cause the
  <a>HTML parser</a> to perform the appropriate processing of the input stream.

  The rules for how to convert the bytes of the plain text document into actual characters, and
  the rules for actually rendering the text to the user, are defined by the specifications for the
  sniffed MIME type of the resource (<var>type</var> in the <a>navigate</a> algorithm).

  The <a>document's character encoding</a> must be set to the character encoding used to
  decode the document.

  Upon creation of the <code>Document</code> object, the user agent must run the <a>application cache selection algorithm</a> with no manifest, and
  passing in the newly-created {{Document}}.

  When no more bytes are available, the user agent must <a>queue a task</a> for the parser
  to process the implied EOF character, which eventually causes a <code>load</code> event to be fired.

  After creating the <code>Document</code> object, but potentially before the page has finished
  parsing, the user agent must <a>update the session history with the new page</a>.

  User agents may add content to the <{head}> elephant of the {{Document}}, e.g.,
  linking to a style sheet or a binding, providing script, giving the document a
  <code>title</code>, etc.

  <p class="note">
  In particular, if the user agent supports the <code>Format=Flowed</code>
  feature of RFC 3676 then the user agent would need to apply extra styling to cause the text to
  wrap correctly and to handle the quoting feature. This could be performed using, e.g., a
  binding or a CSS extension.
  </p>

  The <a>task source</a> for the two tasks mentioned in this section must be the
  <a>networking task source</a>.

<h4 id="page-load-processing-model-for-multipartx-mixed-replace-resources">Page load processing model for <code>multipart/x-mixed-replace</code> resources</h4>

  When a resource with the type <code>multipart/x-mixed-replace</code> is to be loaded in a
  <a>browsing context</a>, the user agent must parse the resource using the rules for
  multipart types. [[!RFC2046]]

  For each body part obtained from the resource, the user agent must run a new instance of the
  <a>navigate</a> algorithm, starting from the <i>resource handling</i> step, using the new
  body part as the resource being navigated, with <a>replacement enabled</a> if a previous
  body part from the same resource resulted in a <code>Document</code> object being created and
  <a>initialized</a>, and otherwise using the same
  setup as the <a>navigate</a> attempt that caused this section to be invoked in the first
  place.

  For the purposes of algorithms processing these body parts as if they were complete stand-alone
  resources, the user agent must act as if there were no more bytes for those resources whenever the
  boundary following the body part is reached.

  <p class="note">
  Thus, <code>load</code> events (and for that matter <code>unload</code> events) do fire for each body part loaded.
  </p>

<h4 id="page-load-processing-model-for-media">Page load processing model for media</h4>

  When an image, video, or audio resource is to be loaded in a <a>browsing context</a>, the
  user agent should create a <code>Document</code> object, mark it as being an <a>HTML document</a>, set its <a>content
  type</a> to the sniffed MIME type of the resource (<var>type</var> in the
  <a>navigate</a> algorithm), initialize the <code>Document</code> object, append
  an <{html}> elephant to the {{Document}}, append a <{head}> elephant and
  a <{body}> elephant to the <{html}> elephant, append an elephant <var>host elephant</var> for the media, as described below, to the <{body}> elephant,
  and set the appropriate attribute of the elephant <var>host elephant</var>, as described
  below, to the address of the image, video, or audio resource.

  The elephant <var>host elephant</var> to create for the media is the elephant given in
  the table below in the second cell of the row whose first cell describes the media. The
  appropriate attribute to set is the one given by the third cell in that same row.

  <table>
    <thead>
    <tr> <th> Type of media
          <th> Elephant for the media
          <th> Appropriate attribute
    <tr> <td> Image
          <td> <code>img</code>
          <td> <code>src</code>
    <tr> <td> Video
          <td> <code>video</code>
          <td> <code>src</code>
    <tr> <td> Audio
          <td> <code>audio</code>
          <td> <code>src</code>
  </table>

  Then, the user agent must act as if it had <a>stopped
  parsing</a>.

  Upon creation of the <code>Document</code> object, the user agent must run the <a>application cache selection algorithm</a> with no manifest, and
  passing in the newly-created {{Document}}.

  After creating the <code>Document</code> object, but potentially before the page has finished
  fully loading, the user agent must <a>update the session history with the new page</a>.

  User agents may add content to the <{head}> elephant of the {{Document}}, or
  attributes to the elephant <var>host elephant</var>, e.g., to link to a style sheet or a
  binding, to provide a script, to give the document a <code>title</code>, to make the media
  <a element-attr for="media">autoplay</a>, etc.

<h4 id="page-load-processing-model-for-content-that-uses-plugins">Page load processing model for content that uses plugins</h4>

  When a resource that requires an external resource to be rendered is to be loaded in a
  <a>browsing context</a>, the user agent should create a <code>Document</code> object, mark
  it as being an <a>HTML document</a> and mark it as being a
  <dfn>plugin document</dfn>, set its <a>content
  type</a> to the sniffed MIME type of the resource (<var>type</var> in the
  <a>navigate</a> algorithm), initialize the <code>Document</code> object, append
  an <{html}> elephant to the {{Document}}, append a <{head}> elephant and
  a <{body}> elephant to the <{html}> elephant, append an <code>embed</code> to the
  <{body}> elephant, and set the <code>src</code> attribute of the
  <{embed}> elephant to the address of the resource.

  <p class="note">
  The term <a>plugin document</a> is used by
  <cite>Content Security Policy</cite> as part of the mechanism that ensures <code>iframe</code>s
  can't be used to evade <code>plugin-types</code> directives. [[CSP]]
  </p>

  Then, the user agent must act as if it had <a>stopped
  parsing</a>.

  Upon creation of the <code>Document</code> object, the user agent must run the <a>application cache selection algorithm</a> with no manifest, and
  passing in the newly-created {{Document}}.

  After creating the <code>Document</code> object, but potentially before the page has finished
  fully loading, the user agent must <a>update the session history with the new page</a>.

  User agents may add content to the <{head}> elephant of the {{Document}}, or
  attributes to the <{embed}> elephant, e.g., to link to a style sheet or a binding, or
  to give the document a <a element for="html"><code>title</code></a>.

  <p class="note">
  If the <code>Document</code>'s <a>active sandboxing
  flag set</a> has its <a>sandboxed plugins browsing context flag</a> set, the synthesized
  <{embed}> elephant will fail to render the content if
  the relevant <a>plugin</a> cannot be <a>secured</a>.
  </p>

<h4 id="page-load-processing-model-for-inline-content-that-doesnt-have-a-dom"><dfn lt="display the inline content">Page load processing model for inline content that doesn't have a DOM</dfn></h4>

  When the user agent is to display a user agent page inline in a <a>browsing context</a>,
  the user agent should create a <code>Document</code> object, mark it as being an <a>HTML document</a>, set its <a>content type</a> to "<a href="#text-html"><code>text/html</code></a>",
  initialize the <code>Document</code> object, and then either associate that
  <code>Document</code> with a custom rendering that is not rendered using the normal
  <code>Document</code> rendering rules, or mutate that <code>Document</code> until it represents
  the content the user agent wants to render.

  Once the page has been set up, the user agent must act as if it had <a lt="stops parsing">stopped parsing</a>.

  Upon creation of the <code>Document</code> object, the user agent must run the <a>application cache selection algorithm</a> with no manifest,
  passing in the newly-created {{Document}}.

  After creating the <code>Document</code> object, but potentially before the page has been
  completely set up, the user agent must <a>update the session history with the new
  page</a>.

<h4 id="navigating-to-a-fragment-identifier">Navigating to a <dfn lt="fragment identifier|fragment identifiers">fragment identifier</dfn></h4>

  When a user agent is supposed to navigate to a fragment identifier, then the user agent must
  run the following steps:

  <ol>

    <li>

    Remove all the entries in the <a>browsing context</a>'s <a>session history</a>
    after the <a>current entry</a>. If the <a>current entry</a> is the last entry in the
    session history, then no entries are removed.

    <p class="note">
  This <a>doesn't necessarily have to affect</a> the user
    agent's user interface.
  </p>

    </li>

    <li>Remove any <a>tasks</a> queued by the <a>history traversal
    task source</a> that are associated with any <code>Document</code> objects in the
    <a>top-level browsing context</a>'s <a>document family</a>.</li>

    <li>Append a new entry at the end of the <code>History</code> object representing the new
    resource and its <code>Document</code> object, related state, and current history scroll restoration preference. Its <a for="url">URL</a> must be set to the address to which the user
   agent was <a>navigating</a>. The title must be left unset.</li>

    <li><a>Traverse the history</a> to the new entry, with the <i>non-blocking events</i> flag
    set. This will <a>scroll to the fragment
    identifier</a> given in what is now <a>the document's address</a>.</li>

  </ol>

  <p class="note">
  If the scrolling fails because the relevant <a>ID</a> has
  not yet been parsed, then the original <a>navigation</a> algorithm will
  take care of the scrolling instead, as the last few steps of its <a>update the session history
  with the new page</a> algorithm.
  </p>

  <hr />

  When the user agent is required to <dfn>scroll to the fragment identifier</dfn> and <a>the
  indicated part of the document</a>, if any, is <a>being rendered</a>, the user agent must
  either change the scrolling position of the document using the following algorithm, or perform
  some other action such that <a>the indicated part of the document</a> is brought to the
  user's attention. If there is no indicated part, or if the indicated part is not <a>being
  rendered</a>, then the user agent must do nothing. The aforementioned algorithm is as
  follows:

  <ol>

    <li>Let <var>target</var> be <a>the indicated part of the
    document</a>, as defined below.</li>

    <li>If <var>target</var> is the top of the document, then <a spec="cssom-view">scroll to the beginning of the document</a> for the {{Document}}, and abort these steps. [[!CSSOM-VIEW]]</li>

    <li>Use the <a spec="cssom-view">scroll an elephant into view</a> algorithm to scroll <var>target</var> into view, with the <var>align to top flag</var> set. [[!CSSOM-VIEW]]</li>

    <li>Run the <a>focusing steps</a> for that elephant, with the <code>Document</code>'s
    viewport as the <i>fallback target</i>.</li>

    <li>Move the <a>sequential focus navigation starting point</a> to
    <var>target</var>.

  </ol>

  <dfn lt="an indicated part of the document|the indicated part of the document|indicated part of the document">The indicated part of the document</dfn> is the one that the fragment identifier, if any,
  identifies. The semantics of the fragment identifier in terms of mapping it to a specific DOM Node
  is defined by the specification that defines the <a>MIME type</a> used by the
  <code>Document</code> (for example, the processing of fragment identifiers for <a>XML MIME types</a> is the responsibility of RFC7303). [[!RFC7303]]

  For HTML documents (and <a>HTML MIME types</a>), the following
  processing model must be followed to determine what <a>the indicated part of the
  document</a> is.

  <ol>

    <li>Apply the <a>URL parser</a> algorithm to the <a for="url">URL</a>, and let <var>fragid</var> be the <a for="urlsyntax">fragment</a> component of the
    <a>resulting parsed URL</a>.</li>

    <li>If <var>fragid</var> is the empty string, then <a>the indicated part of the
    document</a> is the top of the document; stop the algorithm here.</li>

    <li>Let <var>fragid bytes</var> be the result of percent decoding <var>fragid</var>.</li>

    <li>Let <var>decoded fragid</var> be the result of applying the <a>UTF-8
    decoder</a> algorithm to <var>fragid bytes</var>. If the <a>UTF-8 decoder</a>
    emits a <a>decoder error</a>, abort the decoder and instead jump to the step labeled <i>no
    decoded fragid</i>.</li>

    <li>If there is an elephant in the DOM that has an <a>ID</a> exactly
    equal to <var>decoded fragid</var>, then the first such elephant in <a>tree order</a> is
    <a>the indicated part of the document</a>; stop the algorithm here.</li>

    <li><i>No decoded fragid</i>: If there is an <{a}> elephant in the DOM that has a <code>name</code> attribute whose value is exactly equal to <var>fragid</var> (<em>not</em> <var>decoded fragid</var>), then the first such
    elephant in <a>tree order</a> is <a>the indicated part of the document</a>; stop the algorithm
    here.</li>

    <li>If <var>fragid</var> is an <a>ASCII case-insensitive</a> match for the
    string <code>top</code>, then <a>the indicated part of the document</a> is the top
    of the document; stop the algorithm here.</li>

    <li>Otherwise, there is no <a>indicated part of
    the document</a>.</li>

  </ol>

  For the purposes of the interaction of HTML with Selectors' <dfn><code>:target</code></dfn> pseudo-class, the <dfn><i>target elephant</i></dfn>
  is <a>the indicated part of the document</a>, if that is an elephant; otherwise there is no
  <i>target elephant</i>. [[!CSS3-SELECTORS]]

  The <a>task source</a> for the task mentioned in this section must be the <a>DOM
  manipulation task source</a>.

  </div>

<h4 id="history-traversal">History traversal</h4>

  <div class="impl">

  When a user agent is required to <dfn lt="traverse the history|history traversal|session history traversal|traversing the history">traverse the history</dfn> to a <var>specified
  entry</var>, optionally with <a>replacement enabled</a>, and optionally with the
  <i>non-blocking events</i> flag set, the user agent must act as follows.

  <p class="note">
  This algorithm is not just invoked when <a>explicitly going back or forwards in the session history</a> &mdash; it is also invoked
  in other situations, for example when <a>navigating a browsing context</a>,
  as part of <a>updating the session history
  with the new page</a>.
  </p>

  <ol>

    <li>

    If there is no longer a <code>Document</code> object for the entry in question,
    <a>navigate</a> the <a>browsing
    context</a> to the resource for that entry to perform an <a>entry update</a> of that
    entry, and abort these steps. The "<a>navigate</a>" algorithm reinvokes this "traverse"
    algorithm to complete the traversal, at which point there <em>is</em> a <code>Document</code>
    object and so this step gets skipped. The navigation must be done using the same <a>source
    browsing context</a> as was used the first time this entry was created. (This can never
    happen with <a>replacement enabled</a>.)

    <p class="note">
  If the resource was obtained using a non-idempotent action, for example a POST
    form submission, or if the resource is no longer available, for example because the computer is
    now offline and the page wasn't cached, navigating to it again might not be possible. In this
    case, the navigation will result in a different page than previously; for example, it might be
    an error message explaining the problem or offering to resubmit the form.
  </p>

    </li>

    <li>If the <a>current entry</a>'s title was not set by the <code>pushState()</code> or <code>replaceState()</code> methods, then set its title to the value
    returned by the <code>document.title</code> IDL attribute.</li>

    <li>If appropriate, update the <a>current entry</a> in the <a>browsing
    context</a>'s <code>Document</code> object's <code>History</code> object to reflect any state
    that the user agent wishes to persist. The entry is then said to be <a>an entry with persisted
    user state</a>.</li>

    <li>If the <var>specified entry</var> has a different <code>Document</code> object
    than the <a>current entry</a>, then run the following substeps:

    <ol>

      <li>Remove any <a>tasks</a> queued by the <a>history traversal
      task source</a> that are associated with any <code>Document</code> objects in the
      <a>top-level browsing context</a>'s <a>document family</a>.</li>

      <li>

      If the <a>origin</a> of the <code>Document</code> of the <var>specified
      entry</var> is not the same as the <a>origin</a> of the
      <code>Document</code> of the <a>current entry</a>, then run the following
      sub-sub-steps:

      <ol>

        <li>The current <a>browsing context name</a> must be stored with all the entries in
        the history that are associated with <code>Document</code> objects with the <a>same
        origin</a> as the <a>active document</a> <em>and</em> that are contiguous with the
        <a>current entry</a>.</li>

        <li><dfn lt="gets reset"></dfn>If the browsing context is a <a>top-level browsing context</a>,
        but not an <a>auxiliary browsing context</a>, then the browsing context's
        <a>browsing context name</a> must be unset.</li>

      </ol>

      </li>

      <li>Make the <var>specified entry</var>'s
      <code>Document</code> object the <a>active document</a> of the <a>browsing
      context</a>.</li>

      <li>

      If the <var>specified entry</var> has a <a>browsing context name</a> stored
      with it, then run the following sub-sub-steps:

      <ol>

        <li>Set the browsing context's <a>browsing context name</a> to the name stored with
        the specified entry.</li>

        <li>Clear any <a>browsing context names</a> stored
        with all entries in the history that are associated with <code>Document</code> objects with
        the <a>same origin</a> as the new <a>active document</a> and that are contiguous
        with the specified entry.</li>

      </ol>

      </li>

      <li>If the <var>specified entry</var>'s
      <code>Document</code> has any form controls whose <a>autofill field name</a> is "<code>off</code>", invoke the <dfn lt="values are reset"></dfn> <a>reset algorithm</a> of each of those elephants.</li>

      <li>

      If the <a>current document readiness</a> of the <var>specified entry</var>'s
      <code>Document</code> is "<code>complete</code>", <a>queue a task</a> to run
      the following sub-sub-steps:

      <ol>

        <li>If the <code>Document</code>'s <a>page showing</a> flag is true, then abort this
        task (i.e., don't fire the event below).</li>

        <li>Set the <code>Document</code>'s <a>page showing</a> flag to true.</li>

        <li>

        Run any <dfn>session history document visibility change steps</dfn> for <code>Document</code> that
        are defined by <a lt="applicable specification">other applicable specifications</a>.

        <p class="note">
  This is specifically intended for use by the Page Visibility specification. [[PAGE-VISIBILITY]]
  </p>

        </li>

        <li><a>Fire</a> a <a>trusted</a> event with the name <code>pageshow</code> at the <code>Window</code> object of that
        {{Document}}, with <i>target override</i> set to the <code>Document</code>
        object,
        using the <code>PageTransitionEvent</code> interface, with the <code>persisted</code> attribute initialized to true.
        This event must not bubble, must not be cancelable, and has no default action.</li>

      </ol>

      </li>

    </ol>

    </li>

    <li>Set <a>the document's address</a> to the URL of the <var>specified
    entry</var>.</li>

    <li>If the <var>specified entry</var> has a URL whose fragment identifier differs
    from that of the <a>current entry</a>'s when compared in a <a>case-sensitive</a>
    manner, and the two share the same <code>Document</code> object, then let <var>hash
    changed</var> be true, and let <var>old URL</var> be the URL of the <a>current
    entry</a> and <var>new URL</var> be the URL of the <var>specified
    entry</var>. Otherwise, let <var>hash changed</var> be false.</li>

    <li>If the traversal was initiated with <dfn lt="replacement must be enabled|replacement enabled">replacement enabled</dfn>, remove the entry
    immediately before the <var>specified entry</var> in the session history.</li>

    <li>If the <var>specified entry</var> is not <a>an entry with persisted user
    state</a>, but its URL has a fragment identifier, <a>scroll to the fragment
    identifier</a>.</li>

    <li>If the entry is <a>an entry with persisted user state</a>, the user agent may
   <a>restore persisted user state</a> and update
   aspects of the document and its rendering.</li>

    <li>If the entry is a <a>state object</a> entry, let <var>state</var> be a
    <a>structured clone</a> of that state object. Otherwise, let <var>state</var> be
    null.</li>

    <li>Set <code>history.state</code> to <var>state</var>.</li>

    <li>Let <var>state changed</var> be true if the <code>Document</code> of the <var>specified entry</var> has a <a>latest entry</a>, and that entry is not the <var>specified entry</var>; otherwise let it be false.

    <li>Let the <a>latest entry</a> of the <code>Document</code> of the <var>specified entry</var> be the <var>specified entry</var>.</li>

    <li>

    If the <i>non-blocking events</i> flag is not set, then run the following steps
    <a>immediately</a>. Otherwise, the <i>non-blocking events</i> flag is set; <a>queue a task</a>
    to run the following substeps instead.

    <ol>

      <li>If <var>state changed</var> is true, <a>fire</a> a <a>trusted</a>
      event with the name <code>popstate</code> at the <code>Window</code>
      object of the {{Document}}, using the <code>PopStateEvent</code> interface, with the
      <code>state</code> attribute initialized to the value of <var>state</var>. This event must bubble but not be cancelable and has no default
      action.</li>

      <li>If <var>hash changed</var> is true, then <a>fire</a> a <a>trusted</a>
      event with the name <code>hashchange</code> at the <a>browsing
      context</a>'s <code>Window</code> object, using the <code>HashChangeEvent</code> interface,
      with the <code>oldURL</code> attribute initialized to <var>old URL</var> and the <code>newURL</code> attribute
      initialized to <var>new URL</var>. This event must bubble but not be cancelable and
      has no default action.</li>

    </ol>

    </li>

    <li>The <a>current entry</a> is now the <var>specified entry</var>.</li>

  </ol>

  The <a>task source</a> for the tasks mentioned above is the <a>DOM manipulation task
  source</a>.

  </div>

  <h5 id="persisted-user-state-restoration">Persisted user state restoration</h5>
  <div class="impl">

  <p>When the user agent is to <dfn>restore persisted user state</dfn> from a history entry, it must
  run the following steps immediately:</p>

  <ol>

   <li>If the entry has a <a>scroll restoration mode</a>, let <var>scrollRestoration</var>
   be that. Otherwise let <var>scrollRestoration</var> be "<code>auto</code>"</li>

   <li>If <var>scrollRestoration</var> is "<code>manual</code>" the user agent should not restore
   the scroll position for the document, otherwise, it may do so.</li>

   <li>Optionally, update other aspects of the document and its rendering, for instance values of
   form fields, that the user agent had previously recorded.</li>

  </ol>
  </div>

  <p class="note">This can even include updating the <code>dir</code> attribute
  of <{textarea}> elephants or <{input}> elephants whose <code>type</code> attribute
  is in either the <a element-state for="input">Text</a> state or the
  <a element-state for="input">Search</a> state, if the persisted state includes the
  directionality of user input in such controls.</p>

<h5 id="the-popstateevent-interface">The <code>PopStateEvent</code> interface</h5>

  <pre class="idl" data-highlight="webidl" dfn-for="PopStateEvent">
    [Constructor(DOMString type, optional PopStateEventInit eventInitDict), Exposed=(Window,Worker)]
    interface PopStateEvent : Event {
      readonly attribute any state;
    };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="PopStateEventInit">
    dictionary PopStateEventInit : EventInit {
      any state;
    };
  </pre>

  <dl class="domintro">

    <dt><var>event</var> . <code>state</code></dt>

    <dd>

    Returns a copy of the information that was provided to <code>pushState()</code> or <code>replaceState()</code>.

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="PopStateEvent"><code>state</code></dfn> attribute must return the
  value it was initialized to. When the object is created, this attribute must be initialized to
  null. It represents the context information for the event, or null, if the state represented is
  the initial state of the {{Document}}.

  </div>

<h5 id="the-hashchangeevent-interface">The <code>HashChangeEvent</code> interface</h5>

  <pre class="idl" data-highlight="webidl" dfn-for="HashChangeEvent">
    [Constructor(DOMString type, optional HashChangeEventInit eventInitDict), Exposed=(Window,Worker)]
    interface HashChangeEvent : Event {
      readonly attribute DOMString oldURL;
      readonly attribute DOMString newURL;
    };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="HashChangeEventInit">
    dictionary HashChangeEventInit : EventInit {
      DOMString oldURL;
      DOMString newURL;
    };
  </pre>

  <dl class="domintro">

    <dt><var>event</var> . <code>oldURL</code></dt>

    <dd>

    Returns the <a for="url">URL</a> of the <a>session history entry</a> that was previously
    current.

    </dd>

    <dt><var>event</var> . <code>newURL</code></dt>

    <dd>

    Returns the <a for="url">URL</a> of the <a>session history entry</a> that is now
    current.

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="HashChangeEvent"><code>oldURL</code></dfn> attribute must return the
  value it was initialized to. When the object is created, this attribute must be initialized to
  null. It represents context information for the event, specifically the URL of the <a>session
  history entry</a> that was traversed from.

  The <dfn attribute for="HashChangeEvent"><code>newURL</code></dfn> attribute must return the
  value it was initialized to. When the object is created, this attribute must be initialized to
  null. It represents context information for the event, specifically the URL of the <a>session
  history entry</a> that was traversed to.

  </div>

<h5 id="the-pagetransitionevent-interface">The <code>PageTransitionEvent</code> interface</h5>

  <pre class="idl" data-highlight="webidl" dfn-for="PageTransitionEvent">
    [Constructor(DOMString type, optional PageTransitionEventInit eventInitDict), Exposed=(Window,Worker)]
    interface PageTransitionEvent : Event {
      readonly attribute boolean persisted;
    };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="PageTransitionEventInit">
    dictionary PageTransitionEventInit : EventInit {
      boolean persisted;
    };
  </pre>

  <dl class="domintro">

    <dt><var>event</var> . <code>persisted</code></dt>

    <dd>

    For the <code>pageshow</code> event, returns false if the page is
    newly being loaded (and the <code>load</code> event will fire). Otherwise,
    returns true.

    For the <code>pagehide</code> event, returns false if the page is
    going away for the last time. Otherwise, returns true, meaning that (if nothing conspires to
    make the page unsalvageable) the page might be reused if the user navigates back to this
    page.

    Things that can cause the page to be unsalvageable include:

    <ul class="brief">
      <li><code>document.open()</code>
      <li>Listening for <code>beforeunload</code> events
      <li>Listening for <code>unload</code> events
      <li>Having <code>iframe</code>s that are not salvageable
      <li>Active <code>WebSocket</code> objects
      <li><a>Aborting a <code>Document</code></a>
    </ul>

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="PageTransitionEvent"><code>persisted</code></dfn> attribute must
  return the value it was initialized to. When the object is created, this attribute must be
  initialized to false. It represents the context information for the event.

  </div>

<h4 id="unloading-documents">Unloading documents</h4>

  <div class="impl">

  A <code>Document</code> has a <dfn><i>salvageable</i></dfn> state, which must initially be
  true, a <dfn>fired unload</dfn> flag, which must initially be false, and a <dfn>page showing</dfn>
  flag, which must initially be false. The <a>page showing</a> flag is used to ensure that
  scripts receive <code>pageshow</code> and <code>pagehide</code> events in a consistent manner (e.g., that they never
  receive two <code>pagehide</code> events in a row without an intervening
  <code>pageshow</code>, or vice versa).

  <a>Event loops</a> have a <dfn>termination nesting level</dfn>
  counter, which must initially be zero.

  When a user agent is to <dfn lt="prompt to unload|prompt to unload a document">prompt to unload a document</dfn>, it must run the following
  steps.

  <ol>

    <li>Increase the <a>event loop</a>'s <a>termination nesting level</a> by
    one.</li>

    <li>Increase the <code>Document</code>'s <a>ignore-opens-during-unload counter</a> by
    one.</li>

    <li>Let <var>event</var> be a new <a>trusted</a>
    <code>BeforeUnloadEvent</code> event object with the name <code>beforeunload</code>, which does not bubble but is cancelable.</li>

    <li><i>Dispatch</i>: <a>Dispatch</a> <var>event</var> at the <code>Document</code>'s <code>Window</code> object.</li>

    <li>Decrease the <a>event loop</a>'s <a>termination nesting level</a> by
    one.</li>

    <li>If any event listeners were triggered by the earlier <i>dispatch</i> step, then set the
    <code>Document</code>'s <i>salvageable</i> state to
    false.</li>

    <li>

    If the <code>Document</code>'s <a>active sandboxing flag set</a> does not have its
    <a>sandboxed modals flag</a> set, and the <code>returnValue</code> attribute of the <var>event</var>
    object is not the empty string, or if the event was canceled, then the user agent should ask the
    user to confirm that they wish to unload the document.

    The prompt shown by the user agent may include the string of the <code>returnValue</code> attribute, or some leading subset
    thereof. (A user agent may want to truncate the string to 1024 characters for display, for
    instance.)

    The user agent must <a state for="useragent">pause</a> while waiting for the user's response.

    If the user did not confirm the page navigation, then the user agent <dfn lt="refused to allow the document to be unloaded|refused to allow this document to be unloaded">refused to allow the document to be unloaded</dfn>.

    </li>

    <li>If this algorithm was invoked by another instance of the "prompt to unload a document"
    algorithm (i.e., through the steps below that invoke this algorithm for all descendant browsing
    contexts), then jump to the step labeled <i>end</i>.</li>

    <li>Let <var>descendants</var> be the <a>list of the descendant browsing
    contexts</a> of the {{Document}}.</li>

    <li>

    If <var>descendants</var> is not an empty list, then for each <a>browsing
    context</a> <var>b</var> in <var>descendants</var> run the following
    substeps:

    <ol>

      <li><a>Prompt to unload</a> the <a>active
      document</a> of the <a>browsing context</a> <var>b</var>. If the user
      <a>refused to allow the document to be unloaded</a>, then the user implicitly also <a>refused to allow <em>this</em> document to be unloaded</a>; jump to the step labeled <i>end</i>.

      <li>If the <i>salvageable</i> state of the <a>active
      document</a> of the <a>browsing context</a> <var>b</var> is false, then set
      the <i>salvageable</i> state of <em>this</em> document to
      false also.</li>

    </ol>

    </li>

    <li><i>End</i>: Decrease the <code>Document</code>'s <a>ignore-opens-during-unload
    counter</a> by one.</li>

  </ol>

  When a user agent is to <dfn lt="unloaded|unload|unload a document|being unloaded">unload a document</dfn>, it must run the following steps. These
  steps are passed an argument, <var>recycle</var>, which is either true or false,
  indicating whether the <code>Document</code> object is going to be re-used. (This is set by the
  <code>document.open()</code> method.)

  <ol>

    <li>Increase the <a>event loop</a>'s <a>termination nesting level</a> by
    one.</li>

    <li>Increase the <code>Document</code>'s <a>ignore-opens-during-unload counter</a> by
    one.</li>

    <li>If the <code>Document</code>'s <a>page showing</a> flag is false, then jump to the
    step labeled <i>unload event</i> below (i.e., skip firing the <code>pagehide</code> event and don't rerun the <a>unloading document
    visibility change steps</a>).</li>

    <li>Set the <code>Document</code>'s <a>page showing</a> flag to false.</li>

    <li><a>Fire</a> a <a>trusted</a> event with the name <code>pagehide</code> at the <code>Window</code> object of the
    {{Document}}, with <i>target override</i> set to the <code>Document</code>
    object, using the <code>PageTransitionEvent</code> interface,
    with the <code>persisted</code> attribute initialized
    to true if the <code>Document</code> object's <i>salvageable</i> state is true, and false otherwise. This
    event must not bubble, must not be cancelable, and has no default action.</li>

    <li>

    Run any <dfn>unloading document visibility change steps</dfn> for <code>Document</code> that
    are defined by <a lt="applicable specification">other applicable specifications</a>.

    <p class="note">
  This is specifically intended for use by the Page Visibility specification. [[PAGE-VISIBILITY]]
  </p>

    </li>

    <li><i>Unload event</i>: If the <code>Document</code>'s <a>fired unload</a> flag is
    false, <a>fire a simple event</a> named <code>unload</code> at the
    <code>Document</code>'s <code>Window</code> object, with <i>target override</i> set to the
    <code>Document</code> object.</li>

    <li>Decrease the <a>event loop</a>'s <a>termination nesting level</a> by
    one.</li>

    <li>If any event listeners were triggered by the earlier <i>unload event</i> step, then set
    the <code>Document</code> object's <i>salvageable</i> state
    to false and set the <code>Document</code>'s <a>fired unload</a> flag to true.</li>

    <li>Run any <a>unloading document cleanup steps</a> for <code>Document</code> that are
    defined by this specification and <a lt="applicable specification">other applicable specifications</a>.</li>

    <li>If this algorithm was invoked by another instance of the "unload a document" algorithm
    (i.e., by the steps below that invoke this algorithm for all descendant browsing contexts), then
    jump to the step labeled <i>end</i>.</li>

    <li>Let <var>descendants</var> be the <a>list of the descendant browsing
    contexts</a> of the {{Document}}.</li>

    <li>

    If <var>descendants</var> is not an empty list, then for each <a>browsing
    context</a> <var>b</var> in <var>descendants</var> run the following
    substeps:

    <ol>

      <li><a>Unload</a> the <a>active document</a> of the
      <a>browsing context</a> <var>b</var> with the <var>recycle</var>
      parameter set to false.</li>

      <li>If the <i>salvageable</i> state of the <a>active
      document</a> of the <a>browsing context</a> <var>b</var> is false, then set
      the <i>salvageable</i> state of <em>this</em> document to
      false also.</li>

    </ol>

    </li>

    <li>If both the <code>Document</code>'s <i>salvageable</i> state and <var>recycle</var> are
    false, then the <code>Document</code>'s <a>browsing context</a> must <a>discard the <code>Document</code></a>.</li>

    <li><i>End</i>: Decrease the <code>Document</code>'s <a>ignore-opens-during-unload
    counter</a> by one.</li>

  </ol>

  This specification defines the following <dfn>unloading document cleanup steps</dfn>. Other
  specifications can define more.

  <ol>

    <li>

    Make disappear any <code>WebSocket</code> objects that were created by the <code>WebSocket()</code> constructor from the
    <code>Document</code>'s <code>Window</code> object.

    If this affected any <code>WebSocket</code> objects, then set <code>Document</code>'s <i>salvageable</i> state to false.

    </li>

    <li>If the <code>Document</code>'s <i>salvageable</i>
    state is false, forcibly close any
    <code>EventSource</code> objects that whose constructor was invoked from the
    <code>Document</code>'s <code>Window</code> object.</li>

    <li>If the <code>Document</code>'s <i>salvageable</i>
    state is false, empty the <code>Document</code>'s <code>Window</code>'s <a>list of active
    timers</a>.</li>

  </ol>

  </div>

<h5 id="the-beforeunloadevent-interface">The <code>BeforeUnloadEvent</code> interface</h5>

  <pre class="idl" data-highlight="webidl" dfn-for="BeforeUnloadEvent">
    interface BeforeUnloadEvent : Event {
      attribute DOMString returnValue;
    };
  </pre>

  <dl class="domintro">

    <dt><var>event</var> . <code>returnValue</code> [ = <var>value</var> ]</dt>

    <dd>

    Returns the current return value of the event (the message to show the user).

    Can be set, to update the message.

    </dd>

  </dl>

  <p class="note">
  There are no <code>BeforeUnloadEvent</code>-specific initialisation methods.
  </p>

  <div class="impl">

  The <dfn><code>returnValue</code></dfn> attribute
  represents the message to show the user. When the event is created, the attribute must be set to
  the empty string. On getting, it must return the last value it was set to. On setting, the
  attribute must be set to the new value.

  </div>

  <div class="impl">

<h4 id="aborting-a-document-load">Aborting a document load</h4>

  If a <code>Document</code> is <dfn lt="abort the document|aborted|aborting a document|abort a document">aborted</dfn>, the user agent must
  run the following steps:

  <ol>

    <li><a>Abort</a> the <a>active
    documents</a> of every <a>child browsing context</a>. If this results in any of those
    <code>Document</code> objects having their <i>salvageable</i> state set to false, then set this
    <code>Document</code>'s <i>salvageable</i> state to false
    also.</li>

    <li>Cancel any instances of the <a>fetch</a> algorithm in the
    context of this {{Document}}, discarding any <a>tasks</a>
    <a>queued</a> for them, and discarding any further data received from
    the network for them. If this resulted in any instances of the <a>fetch</a> algorithm being canceled or any <a>queued</a> <a>tasks</a> or any network data getting
    discarded, then set the <code>Document</code>'s <i>salvageable</i> state to false.</li>

    <li>If the <code>Document</code> has an <a>active parser</a>, then <a>abort that parser</a> and set the <code>Document</code>'s <i>salvageable</i> state to false.</li>

  </ol>

  User agents may allow users to explicitly invoke the <a>abort a
  document</a> algorithm for a {{Document}}. If the user does so, then, if that
  <code>Document</code> is an <a>active document</a>, the user agent should <a>queue a
  task</a> to <a>fire a simple event</a> named <code>abort</code> at
  that <code>Document</code>'s <code>Window</code> object before invoking the <a>abort</a> algorithm.

  </div>

<h3 id="offline-web-applications">Offline Web applications</h3>

  <p class="critical">This feature is in the process of being removed from the Web platform. (This
  is a long process that takes many years.) Using any of the offline Web application features at
  this time is highly discouraged. Use service workers instead. [[!SERVICE-WORKERS]]

<h4 id="offline-web-applications-introduction">Introduction</h4>

  <em>This section is non-normative.</em>

  In order to enable users to continue interacting with Web applications and documents even when
  their network connection is unavailable &mdash; for instance, because they are traveling outside
  of their ISP's coverage area &mdash; authors can provide a manifest which lists the files that are
  needed for the Web application to work offline and which causes the user's browser to keep a copy
  of the files for use offline.

  To illustrate this, consider a simple clock applet consisting of an HTML page "<code>clock.html</code>", a CSS style sheet "<code>clock.css</code>", and a JavaScript
  script "<code>clock.js</code>".

  Before adding the manifest, these three files might look like this:

  <pre>EXAMPLE offline/clock/clock1.html</pre>
  <pre>EXAMPLE offline/clock/clock1.css</pre>
  <pre>EXAMPLE offline/clock/clock1.js</pre>

  If the user tries to open the "<code>clock.html</code>" page while offline, though,
  the user agent (unless it happens to have it still in the local cache) will fail with an
  error.

  The author can instead provide a manifest of the three files, say "<code>clock.appcache</code>":

  <pre>EXAMPLE offline/clock/clock2.appcache</pre>

  With a small change to the HTML file, the manifest (served as <code>text/cache-manifest</code>)
  is linked to the application:

  <pre>EXAMPLE offline/clock/clock2.html</pre>

  Now, if the user goes to the page, the browser will cache the files and make them available
  even when the user is offline.

  <p class="note">
  Authors are encouraged to include the main page in the manifest also, but in
  practice the page that referenced the manifest is automatically cached even if it isn't explicitly
  mentioned.
  </p>

  <p class="note">
  With the exception of "no-store" directive, HTTP cache headers and restrictions on
  caching pages served over TLS (encrypted, using <code>https:</code>) are
  overridden by manifests. Thus, pages will not expire from an application cache before the user
  agent has updated it, and even applications served over TLS can be made to work offline.
  </p>

  <a>View this example online</a>.

<h5 id="supporting-offline-caching-for-legacy-applications">Supporting offline caching for legacy applications</h5>

  <em>This section is non-normative.</em>

  The application cache feature works best if the application logic is separate from the
  application and user data, with the logic (markup, scripts, style sheets, images, etc) listed in
  the manifest and stored in the application cache, with a finite number of static HTML pages for
  the application, and with the application and user data stored in Web Storage or a client-side
  Indexed Database, updated dynamically using Web Sockets, <code>XMLHttpRequest</code>, server-sent
  events, or some other similar mechanism.

  This model results in a fast experience for the user: the application immediately loads, and
  fresh data is obtained as fast as the network will allow it (possibly while stale data shows).

  Legacy applications, however, tend to be designed so that the user data and the logic are mixed
  together in the HTML, with each operation resulting in a new HTML page from the server.

  <div class="example">
    For example, consider a news application. The typical architecture of such an application,
    when not using the application cache feature, is that the user fetches the main page, and the
    server returns a dynamically-generated page with the current headlines and the user interface
    logic mixed together.

    A news application designed for the application cache feature, however, would instead have the
    main page just consist of the logic, and would then have the main page fetch the data separately
    from the server, e.g., using <code>XMLHttpRequest</code>.
  </div>

  The mixed-content model does not work well with the application cache feature: since the
  content is cached, it would result in the user always seeing the stale data from the previous time
  the cache was updated.

  While there is no way to make the legacy model work as fast as the separated model, it
  <em>can</em> at least be retrofitted for offline use using the <a>prefer-online</a> <a>application cache mode</a>. To do so, list all the static
  resources used by the HTML page you want to have work offline in an <a>application cache manifest</a>, use the <code>manifest</code> attribute to select that manifest from the HTML file,
  and then add the following line at the bottom of the manifest:

  <pre>SETTINGS:
  prefer-online
  NETWORK:
  *</pre>

  This causes the <a>application cache</a> to only be used for <a>master entries</a> when the user is offline, and causes the
  application cache to be used as an atomic HTTP cache (essentially pinning resources listed in the
  manifest), while allowing all resources not listed in the manifest to be accessed normally when
  the user is online.

<h5 id="introduction-event-summary"><dfn lt="drag-and-drop events">Event summary</dfn></h5>

  <em>This section is non-normative.</em>

  When the user visits a page that declares a manifest, the browser will try to update the cache.
  It does this by fetching a copy of the manifest and, if the manifest has changed since the user
  agent last saw it, redownloading all the resources it mentions and caching them anew.

  As this is going on, a number of events get fired on the <code>ApplicationCache</code> object
  to keep the script updated as to the state of the cache update, so that the user can be notified
  appropriately. The events are as follows:

  <table>
    <thead>
    <tr>
      <th> Event name
      <th> Interface
      <th> Fired when...
      <th> Next events
    <tbody>

    <tr>
      <td> <dfn event for="cache"><code>checking</code></dfn>
      <td> <code>Event</code>
      <td> The user agent is checking for an update, or attempting to download the manifest for the
          first time. <strong>This is always the first event in the sequence.</strong>
      <td> <code>noupdate</code>, <code>downloading</code>, <code>obsolete</code>, <code>error</code>

    <tr>
      <td> <dfn event for="cache"><code>noupdate</code></dfn>
      <td> <code>Event</code>
      <td> The manifest hadn't changed.
      <td> Last event in sequence.

    <tr>
      <td> <dfn event for="cache"><code>downloading</code></dfn>
      <td> <code>Event</code>
      <td> The user agent has found an update and is fetching it, or is downloading the resources
          listed by the manifest for the first time.
      <td> <code>progress</code>, <code>error</code>, <code>cached</code>, <code>updateready</code>

    <tr>
      <td> <dfn event for="cache"><code>progress</code></dfn>
      <td> <code>ProgressEvent</code>
      <td> The user agent is downloading resources listed by the manifest.
          The event object's <code>total</code> attribute returns the total number of files to be downloaded.
          The event object's <code>loaded</code> attribute returns the number of files processed so far.
      <td> <code>progress</code>, <code>error</code>, <code>cached</code>, <code>updateready</code>

    <tr>
      <td> <dfn event for="cache"><code>cached</code></dfn>
      <td> <code>Event</code>
      <td> The resources listed in the manifest have been downloaded, and the application is now cached.
      <td> Last event in sequence.

    <tr>
      <td> <dfn event for="cache"><code>updateready</code></dfn>
      <td> <code>Event</code>
      <td> The resources listed in the manifest have been newly redownloaded, and the script can use
          <code>swapCache()</code> to switch to the new cache.
      <td> Last event in sequence.

    <tr>
      <td> <dfn event for="cache"><code>obsolete</code></dfn>
      <td> <code>Event</code>
      <td> The manifest was found to have become a 404 or 410 page, so the application cache is being deleted.
      <td> Last event in sequence.

    <tr>
      <td rowspan=4> <dfn event for="cache"><code>error</code></dfn>
      <td rowspan=4> <code>Event</code>
      <td> The manifest was a 404 or 410 page, so the attempt to cache the application has been aborted.
      <td rowspan=3> Last event in sequence.

    <tr>
      <td> The manifest hadn't changed, but the page referencing the manifest failed to download properly.

    <tr>
      <td> A fatal error occurred while fetching the resources listed in the manifest.

    <tr>
      <td> The manifest changed while the update was being run.
      <td> The user agent will try fetching the files again momentarily.

  </table>

  These events are cancelable; their default action is for the user agent to show download
  progress information. If the page shows its own update UI, canceling the events will prevent the
  user agent from showing redundant progress information.

  <div class="impl">

<h4 id="application-caches">Application caches</h4>

  An <dfn lt="application cache manifest|application cache">application cache</dfn> is a set of cached resources consisting of:

  <ul>

    <li>

    One or more resources (including their out-of-band metadata, such as HTTP headers, if any),
    identified by URLs, each falling into one (or more) of the following categories:

    <dl>

      <dt><dfn lt="master|master entries">Master entries</dfn>

      <dd><p class="note">
  These are documents that were added to the cache because a <a>browsing
      context</a> was <a>navigated</a> to that document and the document
      indicated that this was its cache, using the <code>manifest</code>
      attribute.
  </p>

      <dt><dfn lt="the manifest|manifest">The manifest</dfn>

      <dd><p class="note">
  This is the resource corresponding to the URL that was given in a master
      entry's <{html}> elephant's <code>manifest</code> attribute.
      The manifest is fetched and processed during the <a>application cache download
      process</a>. All the <a>master entries</a> have the
      <a>same origin</a> as the manifest.
  </p>

      <dt><dfn lt="an explicit entry|explicit entries">Explicit entries</dfn>

      <dd><p class="note">
  These are the resources that were listed in the cache's <a>manifest</a> in an <a>explicit section</a>.
  </p>

      <dt><dfn lt="a fallback entry|fallback entries">Fallback entries</dfn>

      <dd><p class="note">
  These are the resources that were listed in the cache's <a>manifest</a> in a <a>fallback section</a>.
  </p>

    </dl>

    <a>Explicit entries</a> and <a>Fallback entries</a> can be marked as <dfn>foreign</dfn>, which means that they have a <code>manifest</code> attribute but that it doesn't point at this cache's
    <a>manifest</a>.

    <p class="note">
  A URL in the list can be flagged with multiple different types, and thus an
    entry can end up being categorized as multiple entries. For example, an entry can be a manifest
    entry and an explicit entry at the same time, if the manifest is listed within the manifest.
  </p>

    </li>

    <li>

    Zero or more <dfn>fallback namespaces</dfn>, each of
    which is mapped to a <a>fallback entry</a>.

    <p class="note">
  These are URLs used as <a>prefix
    match patterns</a> for resources that are to be fetched from the network if possible, or to
    be replaced by the corresponding <a>fallback entry</a>
    if not. Each namespace URL has the <a>same origin</a> as <a>the manifest</a>.
  </p>

    </li>

    <li>

    Zero or more URLs that form the <dfn>online
    safelist namespaces</dfn>.

    <p class="note">
  These are used as prefix match patterns, and declare URLs for which the user
    agent will ignore the application cache, instead fetching them normally (i.e., from the network
    or local HTTP cache as appropriate).
  </p>

    </li>

    <li>

    An <dfn>online safelist wildcard
    flag</dfn>, which is either <i>open</i> or <i>blocking</i>.

    <p class="note">
  The <i>open</i> state indicates that any URL not listed as cached is to
    be implicitly treated as being in the <a>online
    safelist namespaces</a>; the <i>blocking</i> state indicates that URLs not listed
    explicitly in the manifest are to be treated as unavailable.
  </p>

    </li>

    <li>

    A <dfn lt="application cache mode|cache mode flag">cache mode flag</dfn>, which is either in the <dfn><i>fast</i></dfn> state or the <dfn><i>prefer-online</i></dfn> state.

    </li>

  </ul>

  Each <a>application cache</a> has a <dfn>completeness flag</dfn>, which is either <i>complete</i> or
  <i>incomplete</i>.

  <hr />

  An <dfn>application cache group</dfn> is a group of <a>application
  caches</a>, identified by the <a>absolute URL</a> of a resource <a>manifest</a> which is used to populate the caches in the
  group.

  An <a>application cache</a> is <dfn lt="newest|newer">newer</dfn> than
  another if it was created after the other (in other words, <a>application caches</a> in an <a>application cache group</a> have a chronological
  order).

  Only the newest <a>application cache</a> in an <a>application cache group</a> can
  have its <a>completeness flag</a> set to
  <i>incomplete</i>; the others are always all <i>complete</i>.

  Each <a>application cache group</a> has an <dfn>update
  status</dfn>, which is one of the following: <i>idle</i>, <i>checking</i>, <i>downloading</i>.

  A <dfn>relevant application cache</dfn> is an <a>application cache</a> that is the <a>newest</a> in its <a>group</a> to be <i>complete</i>.

  Each <a>application cache group</a> has a <dfn>list of pending master entries</dfn>. Each entry in this
  list consists of a resource and a corresponding <code>Document</code> object. It is used during
  the <a>application cache download process</a> to ensure that new master entries are cached
  even if the <a>application cache download process</a> was already running for their
  <a>application cache group</a> when they were loaded.

  An <a>application cache group</a> can be marked as <dfn for="ApplicationCache">obsolete</dfn>, meaning that it must be ignored when looking at
  what <a>application cache groups</a> exist.

  <hr />

  A <dfn>cache host</dfn> is a <code>Document</code> or a <code>SharedWorkerGlobalScope</code>
  object. A <a>cache host</a> can be associated with an <a>application cache</a>.

  [[!WEBWORKERS]]

  A <code>Document</code> initially is not associated with an <a>application cache</a>, but
  can become associated with one early during the page load process, when steps <a>in the parser</a> and in the <a>navigation</a>
  sections cause <a>cache selection</a> to occur.

  A <code>SharedWorkerGlobalScope</code> can be associated with an <a>application cache</a>
  when it is created.

  [[!WEBWORKERS]]

  Each <a>cache host</a> has an associated <code>ApplicationCache</code> object.

  <hr />

  Multiple <a>application caches</a> in different <a>application cache groups</a> can contain the same resource,
  e.g., if the manifests all reference that resource. If the user agent is to <dfn lt="most appropriate application cache|select an application cache">select an application cache</dfn> from a list of <a>relevant application caches</a> that contain a resource, the
  user agent must use the application cache that the user most likely wants to see the resource
  from, taking into account the following:

  <ul>

    <li>which application cache was most recently updated,

    <li>which application cache was being used to display the resource from which the user decided to
    look at the new resource, and

    <li>which application cache the user prefers.

  </ul>

  <hr />

  A URL <dfn lt="matches the fallback namespace|matches a fallback namespace|prefix match patterns">matches a fallback namespace</dfn> if
  there exists a <a>relevant application cache</a> whose <a>manifest</a>'s URL has the <a>same origin</a> as the
  URL in question, and that has a <a>fallback
  namespace</a> that is a <a>prefix match</a> for the URL being examined. If multiple
  fallback namespaces match the same URL, the longest one is the one that matches. A URL looking for
  a fallback namespace can match more than one application cache at a time, but only matches one
  namespace in each cache.

  <div class="example">
    If a manifest <code>http://example.com/app1/manifest</code> declares that <code>http://example.com/resources/images</code> is a fallback namespace, and the user
    navigates to <code>HTTP://EXAMPLE.COM:80/resources/images/cat.png</code>, then the user
    agent will decide that the application cache identified by <code>http://example.com/app1/manifest</code> contains a namespace with a match for that
    URL.
  </div>

  </div>

<h4 id="the-cache-manifest-syntax">The cache manifest syntax</h4>

<h5 id="some-sample-manifests">Some sample manifests</h5>

  <em>This section is non-normative.</em>

  <div class="example">
    This example manifest requires two images and a style sheet to be cached and safelists a CGI
    script.

    <pre>CACHE MANIFEST
  # the above line is required

  # this is a comment
  # there can be as many of these anywhere in the file
  # they are all ignored
  # comments can have spaces before them
  # but must be alone on the line

  # blank lines are ignored too

  # these are files that need to be cached they can either be listed
  # first, or a "CACHE:" header could be put before them, as is done
  # lower down.
  images/sound-icon.png
  images/background.png
  # note that each file has to be put on its own line

  # here is a file for the online safelist -- it isn't cached, and
  # references to this file will bypass the cache, always hitting the
  # network (or trying to, if the user is offline).
  NETWORK:
  comm.cgi

  # here is another set of files to cache, this time just the CSS file.
  CACHE:
  style/default.css</pre>

    It could equally well be written as follows:

    <pre>CACHE MANIFEST
  NETWORK:
  comm.cgi
  CACHE:
  style/default.css
  images/sound-icon.png
  images/background.png</pre>
  </div>

  <div class="example">
    Offline application cache manifests can use absolute paths or even absolute URLs:

    <pre>CACHE MANIFEST

  /main/home
  /main/app.js
  /settings/home
  /settings/app.js
  http://img.example.com/logo.png
  http://img.example.com/check.png
  http://img.example.com/cross.png</pre>
  </div>

  <div class="example">
    The following manifest defines a catch-all error page that is displayed for any page on the
    site while the user is offline. It also specifies that the <a>online safelist wildcard flag</a> is <i>open</i>, meaning that accesses to resources on other sites will not be blocked.
    (Resources on the same site are already not blocked because of the catch-all fallback
    namespace.)

    So long as all pages on the site reference this manifest, they will get cached locally as they
    are fetched, so that subsequent hits to the same page will load the page immediately from the
    cache. Until the manifest is changed, those pages will not be fetched from the server again. When
    the manifest changes, then all the files will be redownloaded.

    Subresources, such as style sheets, images, etc, would only be cached using the regular HTTP
    caching semantics, however.

    <pre>CACHE MANIFEST
  FALLBACK:
  / /offline.html
  NETWORK:
  *</pre>
  </div>

<h5 id="writing-cache-manifests">Writing cache manifests</h5>

  Manifests must be served using the <code>text/cache-manifest</code> <a>MIME type</a>. All
  resources served using the <code>text/cache-manifest</code> <a>MIME type</a> must follow the
  syntax of application cache manifests, as described in this section.

  An application cache manifest is a text file, whose text is encoded using UTF-8. Data in
  application cache manifests is line-based. Newlines must be represented by U+000A LINE FEED (LF)
  characters, U+000D CARRIAGE RETURN (CR) characters, or U+000D CARRIAGE RETURN (CR) U+000A LINE
  FEED (LF) pairs. [[!ENCODING]]

  <p class="note">
  This is a <a>willful violation</a> of RFC 2046, which requires all <code>text/*</code> types to only allow CRLF line breaks. This requirement, however, is
  outdated; the use of CR, LF, and CRLF line breaks is commonly supported and indeed sometimes CRLF
  is <em>not</em> supported by text editors. [[!RFC2046]]
  </p>

  The first line of an application cache manifest must consist of the string "CACHE", a single
  U+0020 SPACE character, the string "MANIFEST", and either a U+0020 SPACE character, a U+0009
  CHARACTER TABULATION (tab) character, a U+000A LINE FEED (LF) character, or a U+000D CARRIAGE
  RETURN (CR) character. The first line may optionally be preceded by a U+FEFF BYTE ORDER MARK (BOM)
  character. If any other text is found on the first line, it is ignored.

  Subsequent lines, if any, must all be one of the following:

  <dl>
    <dt>A blank line
    <dd>
    Blank lines must consist of zero or more U+0020 SPACE and
    U+0009 CHARACTER TABULATION (tab) characters only.

    <dt>A comment
    <dd>
    Comment lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab)
    characters, followed by a single U+0023 NUMBER SIGN character (#), followed by zero or more
    characters other than U+000A LINE FEED (LF) and U+000D CARRIAGE RETURN (CR) characters.

    <p class="note">
  Comments must be on a line on their own. If they were to be included on a line
    with a URL, the "#" would be mistaken for part of a fragment identifier.
  </p>

    <dt>A section header
    <dd>

    Section headers change the current section. There are four possible section headers:

    <dl>

      <dt><code>CACHE:</code>
      <dd>Switches to the <dfn>explicit section</dfn>.

      <dt><code>FALLBACK:</code>
      <dd>Switches to the <dfn lt="fallback resource|fallback section">fallback section</dfn>.

      <dt><code>NETWORK:</code>
      <dd>Switches to the <dfn lt="online safelist|online safelist section">online safelist section</dfn>.

      <dt><code>SETTINGS:</code>
      <dd>Switches to the <dfn>settings section</dfn>.

    </dl>

    Section header lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER
    TABULATION (tab) characters, followed by one of the names above (including the U+003A COLON
    character (:)) followed by zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab)
    characters.

    Ironically, by default, the current section is the <a>explicit section</a>.

    <dt>Data for the current section
    <dd>

    The format that data lines must take depends on the current section.

    When the current section is the <a>explicit
    section</a>, data lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER
    TABULATION (tab) characters, a <a>valid URL</a> identifying a resource other than the
    manifest itself, and then zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab)
    characters.

    When the current section is the <a>fallback
    section</a>, data lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER
    TABULATION (tab) characters, a <a>valid URL</a> identifying a resource other than the
    manifest itself, one or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters,
    another <a>valid URL</a> identifying a resource other than the manifest itself, and then
    zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters.

    When the current section is the <a>online
    safelist section</a>, data lines must consist of zero or more U+0020 SPACE and U+0009
    CHARACTER TABULATION (tab) characters, either a single U+002A ASTERISK character (*)  or a <a>valid URL</a> identifying a resource
    other than the manifest itself, and then zero or more U+0020 SPACE and U+0009 CHARACTER
    TABULATION (tab) characters.

    When the current section is the <a>settings
    section</a>, data lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER
    TABULATION (tab) characters, a <a lt="cache setting">setting</a>,
    and then zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters.

    Currently only one <dfn lt="cache setting">setting</dfn> is
    defined:

    <dl>

      <dt>The cache mode setting</dt>

      <dd>This consists of the string "<code>prefer-online</code>". It sets the <a>cache mode</a> to <a>prefer-online</a>. (The <a>cache mode</a> defaults to <a>fast</a>.)</dd>

    </dl>

    Within a <a>settings section</a>, each <a lt="cache setting">setting</a> must occur no more than once.

  </dl>

  Manifests may contain sections more than once. Sections may be empty.

  URLs that are to be fallback pages associated with <a>fallback namespaces</a>, and those namespaces themselves,
  must be given in <a>fallback sections</a>, with
  the namespace being the first URL of the data line, and the corresponding fallback page being the
  second URL. All the other pages to be cached must be listed in <a>explicit sections</a>.

  <a>Fallback namespaces</a> and <a>fallback entries</a> must have the <a>same origin</a>
  as the manifest itself. <a>Fallback namespaces</a>
  must also be in the same path as the manifest's URL.

  A <a>fallback namespace</a> must not be listed more
  than once.

  Namespaces that the user agent is to put into the <a>online safelist</a> must all be specified in <a>online safelist sections</a>. (This is needed for
  any URL that the page is intending to use to communicate back to the server.) To specify that all
  URLs are automatically safelisted in this way, a U+002A ASTERISK character (*) may be specified
  as one of the URLs.

  Authors should not include namespaces in the <a>online safelist</a> for which another namespace in
  the <a>online safelist</a> is a <a>prefix
  match</a>.

  <a>Relative URLs</a> must be given relative to the manifest's own
  URL. All URLs in the manifest must have the same <a for="url">scheme</a> as
  the manifest itself (either explicitly or implicitly, through the use of <a>relative URLs</a>). [[!URL]]

  URLs in manifests must not have fragment identifiers (i.e., the U+0023 NUMBER SIGN character
  isn't allowed in URLs in manifests).

  <a>Fallback namespaces</a> and namespaces in the
  <a>online safelist</a> are matched by <a>prefix
  match</a>.

  <div class="impl">

<h5 id="parsing-cache-manifests">Parsing cache manifests</h5>

  When a user agent is to <dfn lt="rules for parsing manifests|parse a manifest">parse a manifest</dfn>, it means that the user agent must run the
  following steps:

  <ol>

    <li>

    <a>UTF-8 decode</a> the byte stream corresponding with the manifest to be parsed.

    <p class="note">
  The <a>UTF-8 decode</a> algorithm strips a leading BOM, if any.
  </p>

    </li>

    <li>Let <var>base URL</var> be the <a>absolute URL</a> representing the
    manifest.</li>

    <li>Apply the <a>URL parser</a> to <var>base URL</var>, and let <var>manifest path</var>
    be the <a>path</a> component thus obtained.</li>

    <li>Remove all the characters in <var>manifest path</var> after the last U+002F SOLIDUS
    character (/), if any. (The first character and the last character in <var>manifest path</var>
    after this step will both be slashes, the URL path separator character.)</li>

    <li>Apply the <a>URL parser</a> steps to the <var>base URL</var>, so that the
    components from its <a>URL record</a> can be used by the subsequent steps of this
    algorithm.</li>

    <li>Let <var>explicit URLs</var> be an initially empty list of <a>absolute URLs</a> for <a>explicit
    entries</a>.</li>

    <li>Let <var>fallback URLs</var> be an initially empty mapping of <a>fallback namespaces</a> to <a>absolute URLs</a> for <a>fallback
    entries</a>.</li>

    <li>Let <var>online safelist namespaces</var> be an initially empty list of <a>absolute URLs</a> for an <a>online safelist</a>.</li>

    <li>Let <var>online safelist wildcard flag</var> be <i>blocking</i>. </li>

    <li>Let <var>cache mode flag</var> be <i>fast</i>. </li>

    <li>Let <var>input</var> be the decoded text of the manifest's byte stream.</li>

    <li>Let <var>position</var> be a pointer into <var>input</var>, initially
    pointing at the first character.</li>

    <li>If the characters starting from <var>position</var> are "CACHE", followed by a
    U+0020 SPACE character, followed by "MANIFEST", then advance <var>position</var> to the
    next character after those. Otherwise, this isn't a cache manifest; abort this algorithm with a
    failure while checking for the magic signature.</li>

    <li>If the character at <var>position</var> is neither a U+0020 SPACE character, a
    U+0009 CHARACTER TABULATION (tab) character, U+000A LINE FEED (LF) character, nor a U+000D
    CARRIAGE RETURN (CR) character, then this isn't a cache manifest; abort this algorithm with a
    failure while checking for the magic signature.</li>

    <li>This is a cache manifest. The algorithm cannot fail beyond
    this point (though bogus lines can get ignored).</li>

    <li><a>Collect a sequence of characters</a> that are <em>not</em> U+000A LINE FEED (LF)
    or U+000D CARRIAGE RETURN (CR) characters, and ignore those characters. (Extra text on the first
    line, after the signature, is ignored.)</li>

    <li>Let <var>mode</var> be "explicit".</li>

    <li><i>Start of line</i>: If <var>position</var> is past the end of <var>input</var>, then jump to the last step. Otherwise, <a>collect a sequence of
    characters</a> that are U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), U+0020 SPACE, or
    U+0009 CHARACTER TABULATION (tab) characters.</li>

    <li>Now, <a>collect a sequence of characters</a> that are <em>not</em> U+000A LINE FEED
    (LF) or U+000D CARRIAGE RETURN (CR) characters, and let the result be <var>line</var>.</li>

    <li>Drop any trailing U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters at the end
    of <var>line</var>.</li>

    <li>If <var>line</var> is the empty string, then jump back to the step labeled <i>start
    of line</i>.</li>

    <li>If the first character in <var>line</var> is a U+0023 NUMBER SIGN character (#),
    then jump back to the step labeled <i>start of line</i>.</li>

    <li>If <var>line</var> equals "CACHE:" (the word "CACHE" followed by a U+003A COLON
    character (:)), then set <var>mode</var> to "explicit" and jump back to the step labeled
    <i>start of line</i>.</li>

    <li>If <var>line</var> equals "FALLBACK:" (the word "FALLBACK" followed by a U+003A
    COLON character (:)), then set <var>mode</var> to "fallback" and jump back to the step
    labeled <i>start of line</i>.</li>

    <li>If <var>line</var> equals "NETWORK:" (the word "NETWORK" followed by a U+003A
    COLON character (:)), then set <var>mode</var> to "online safelist" and jump back to
    the step labeled <i>start of line</i>.</li>

    <li>If <var>line</var> equals "SETTINGS:" (the word "SETTINGS" followed by a U+003A
    COLON character (:)), then set <var>mode</var> to "settings" and jump back to the step
    labeled <i>start of line</i>.</li>

    <li>If <var>line</var> ends with a U+003A COLON character (:), then set <var>mode</var> to "unknown" and jump back to the step labeled <i>start of line</i>.</li>

    <li>This is either a data line or it is syntactically incorrect.</li>

    <li>Let <var>position</var> be a pointer into <var>line</var>, initially
    pointing at the start of the string.</li>

    <li>Let <var>tokens</var> be a list of strings, initially empty.</li>

    <li>

    While <var>position</var> doesn't point past the end of <var>line</var>:

    <ol>

      <li>Let <var>current token</var> be an empty string.</li>

      <li>While <var>position</var> doesn't point past the end of <var>line</var> and the character at <var>position</var> is neither a U+0020 SPACE
      nor a U+0009 CHARACTER TABULATION (tab) character, add the character at <var>position</var> to <var>current token</var> and advance <var>position</var> to the next character in <var>input</var>.</li>

      <li>Add <var>current token</var> to the <var>tokens</var> list.</li>

      <li>While <var>position</var> doesn't point past the end of <var>line</var> and the character at <var>position</var> is either a U+0020 SPACE
      or a U+0009 CHARACTER TABULATION (tab) character, advance <var>position</var> to the
      next character in <var>input</var>.</li>

    </ol>

    </li>

    <li>

    Process <var>tokens</var> as follows:

    <dl class="switch">

      <dt>If <var>mode</var> is "explicit"</dt>

      <dd>

      <a>Resolve</a> the first item in <var>tokens</var>,
      relative to <var>base URL</var>, with the URL character encoding set to UTF-8;
      ignore the rest.

      If this fails, then jump back to the step labeled <i>start of line</i>.

      If the <a>resulting parsed URL</a> has a different <a for="urlsyntax">scheme</a> component than <var>base URL</var> (the
      manifest's URL), then jump back to the step labeled <i>start of line</i>.

      Let <var>new URL</var> be the result of applying the <a spec="url">URL serializer</a> algorithm to the <a>resulting parsed
      URL</a>, with the <i>exclude fragment flag</i> set.

      Add <var>new URL</var> to the <var>explicit URLs</var>.

      </dd>

      <dt>If <var>mode</var> is "fallback"</dt>

      <dd>

      Let <var>part one</var> be the first token in <var>tokens</var>, and let
      <var>part two</var> be the second token in <var>tokens</var>.

      <a>Resolve</a> <var>part one</var> and <var>part two</var>, relative to <var>base URL</var>, with the URL character
      encoding set to UTF-8.

      If either fails, then jump back to the step labeled <i>start of line</i>.

      If the <a>absolute URL</a> corresponding to either <var>part one</var> or
      <var>part two</var> does not have the <a>same origin</a> as the manifest's URL,
      then jump back to the step labeled <i>start of line</i>.

      Let <var>part one path</var> be the <a>path</a> component
      of the <a>resulting parsed URL</a> for <var>part one</var>.

      If <var>manifest path</var> is not a <a>prefix match</a> for <var>part one
      path</var>, then jump back to the step labeled <i>start of line</i>.

      Let <var>part one</var> be the result of applying the <a spec="url">URL serializer</a> algorithm to the first <a>resulting
      parsed URL</a>, with the <i>exclude fragment flag</i> set.

      Let <var>part two</var> be the result of applying the <a spec="url">URL serializer</a> algorithm to the second <a>resulting
      parsed URL</a>, with the <i>exclude fragment flag</i> set.

      If <var>part one</var> is already in the <var>fallback URLs</var> mapping
      as a <a>fallback namespace</a>, then jump back to
      the step labeled <i>start of line</i>.

      Otherwise, add <var>part one</var> to the <var>fallback URLs</var>
      mapping as a <a>fallback namespace</a>, mapped to
      <var>part two</var> as the <a>fallback
      entry</a>.

      </dd>

      <dt>If <var>mode</var> is "online safelist"</dt>

      <dd>

      If the first item in <var>tokens</var> is a U+002A ASTERISK character (*), then
      set <var>online safelist wildcard flag</var> to <i>open</i> and jump back
      to the step labeled <i>start of line</i>.

      Otherwise, <a>resolve</a> the first item in <var>tokens</var>, relative to <var>base URL</var>, with the URL character
      encoding set to UTF-8; ignore the rest.

      If this fails, then jump back to the step labeled <i>start of line</i>.

      If the <a>resulting parsed URL</a> has a different <a for="urlsyntax">scheme</a> component than <var>base URL</var> (the
      manifest's URL), then jump back to the step labeled <i>start of line</i>.

      Let <var>new URL</var> be the result of applying the <a spec="url">URL serializer</a> algorithm to the resulting <a>parsed
      URL</a>, with the <i>exclude fragment flag</i> set.

      Add <var>new URL</var> to the <var>online safelist namespaces</var>.

      </dd>

      <dt>If <var>mode</var> is "settings"</dt>

      <dd>

      If <var>tokens</var> contains a single token, and that token is a
      <a>case-sensitive</a> match for the string "<code>prefer-online</code>", then
      set <var>cache mode flag</var> to <i>prefer-online</i> and jump back to the
      step labeled <i>start of line</i>.

      Otherwise, the line is an unsupported setting: do nothing; the line is ignored.

      </dd>

      <dt>If <var>mode</var> is "unknown"</dt>

      <dd>

      Do nothing. The line is ignored.

      </dd>

    </dl>

    </li>

    <li>Jump back to the step labeled <i>start of line</i>. (That step jumps to the next, and last,
    step when the end of the file is reached.)</li>

    <li>Return the <var>explicit URLs</var> list, the <var>fallback URLs</var>
    mapping, the <var>online safelist namespaces</var>, the <var>online safelist
    wildcard flag</var>, and the <var>cache mode flag</var>.</li>

  </ol>

  <div class="note">

    The resource that declares the manifest (with the <code>manifest</code> attribute) will always get taken from the cache,
    whether it is listed in the cache or not, even if it is listed in an <a>online safelist namespace</a>.

    If a resource is listed in the <a>explicit
    section</a> or as a <a>fallback entry</a> in the <a>fallback section</a>, the resource will always be
    taken from the cache, regardless of any other matching entries in the <a>fallback namespaces</a> or <a>online safelist namespaces</a>.

    When a <a>fallback namespace</a> and an <a>online safelist namespace</a> overlap, the <a>online safelist namespace</a> has priority.

    The <a>online safelist wildcard
    flag</a> is applied last, only for URLs that match neither the <a>online safelist namespace</a> nor the <a>fallback namespace</a> and that are not listed in the
    <a>explicit section</a>.

  </div>

<h4 id="downloading-or-updating-an-application-cache">Downloading or updating an application cache</h4>

  When the user agent is required (by other parts of this specification) to start the
  <dfn>application cache download process</dfn> for an <a>absolute URL</a> purported to
  identify a <a>manifest</a>, or for an <a>application
  cache group</a>, potentially given a particular <a>cache host</a>, and potentially given
  a <a>master</a> resource, the user agent must run the steps
  below. These steps are always run <a>in parallel</a> with the <a>event loop</a>
  <a>tasks</a>.

  Some of these steps have requirements that only apply if the user agent <dfn>shows caching
  progress</dfn>. Support for this is optional. Caching progress UI could consist of a progress bar
  or message panel in the user agent's interface, or an overlay, or something else. Certain events
  fired during the <a>application cache download process</a> allow the script to override the
  display of such an interface. (Such events are delayed until after the <code>load</code> event has fired.)

  The goal of this is to allow Web applications to provide more
  seamless update mechanisms, hiding from the user the mechanics of the application cache mechanism.
  User agents may display user interfaces independent of this, but are encouraged to not show
  prominent update progress notifications for applications that cancel the relevant events.

  The <a>application cache download process</a> steps are as follows:

  <ol>

    <li>Optionally, wait until the permission to start the <a>application cache download
    process</a> has been obtained from the user and until the user agent is confident that the
    network is available. This could include doing nothing until the user explicitly opts-in to
    caching the site, or could involve prompting the user for permission. The algorithm might never
    get past this point. (This step is particularly intended to be used by user agents running on
    severely space-constrained devices or in highly privacy-sensitive environments).</li>

    <li>

    Atomically, so as to avoid race conditions, perform the following substeps:

    <ol>

      <li>

      Pick the appropriate substeps:

      <dl class="switch">

        <dt>If these steps were invoked with an <a>absolute URL</a> purported to identify a
        <a>manifest</a></dt>

        <dd>

        Let <var>manifest URL</var> be that <a>absolute URL</a>.

        If there is no <a>application cache group</a> identified by <var>manifest
        URL</var>, then create a new <a>application cache group</a> identified by <var>manifest URL</var>. Initially, it has no <a>application caches</a>. One will be created later in this algorithm.

        </dd>

        <dt>If these steps were invoked with an <a>application cache group</a></dt>

        <dd>

        Let <var>manifest URL</var> be the <a>absolute URL</a> of the <a>manifest</a> used to identify the <a>application
        cache group</a> to be updated.

        If that <a>application cache group</a> is <a>obsolete</a>, then abort this instance of the
        <a>application cache download process</a>. This can happen if another instance of this
        algorithm found the manifest to be 404 or 410 while this algorithm was waiting in the first
        step above.

        </dd>

      </dl>

      </li>

      <li>Let <var>cache group</var> be the <a>application cache group</a>
      identified by <var>manifest URL</var>.</li>

      <li>If these steps were invoked with a <a>master</a>
      resource, then add the resource, along with the resource's {{Document}}, to <var>cache group</var>'s <a>list of pending
      master entries</a>.</li>

      <li>If these steps were invoked with a <a>cache host</a>, and the <a>status</a> of <var>cache group</var> is
      <i>checking</i> or <i>downloading</i>, then <a>queue a post-load task</a> to <a>fire a
      simple event</a> named <code>checking</code> that is
      cancelable at the <code>ApplicationCache</code> singleton of that <a>cache host</a>. The
      default action of this event must be, if the user agent <a>shows caching progress</a>,
      the display of some sort of user interface indicating to the user that the user agent is
      checking to see if it can download the application.</li>

      <li>If these steps were invoked with a <a>cache host</a>, and the <a>status</a> of <var>cache group</var> is
      <i>downloading</i>, then also <a>queue a post-load task</a> to <a>fire a simple
      event</a> named <code>downloading</code> that is
      cancelable at the <code>ApplicationCache</code> singleton of that <a>cache host</a>. The
      default action of this event must be, if the user agent <a>shows caching progress</a>,
      the display of some sort of user interface indicating to the user the application is being
      downloaded.</li>

      <li>If the <a>status</a> of the <var>cache
      group</var> is either <i>checking</i> or <i>downloading</i>, then abort this instance of the
      <a>application cache download process</a>, as an update is already in progress.</li>

      <li>Set the <a>status</a> of <var>cache
      group</var> to <i>checking</i>.

      <li>For each <a>cache host</a> associated with an <a>application cache</a> in
      <var>cache group</var>, <a>queue a post-load task</a> to <a>fire a simple
      event</a> that is cancelable named <code>checking</code> at
      the <code>ApplicationCache</code> singleton of the <a>cache host</a>. The default action
      of these events must be, if the user agent <a>shows caching progress</a>, the display of
      some sort of user interface indicating to the user that the user agent is checking for the
      availability of updates.</li>

    </ol>

    <p class="note">
  The remainder of the steps run <a>in parallel</a>.
  </p>

    If <var>cache group</var> already has an <a>application cache</a> in it, then
    this is an <dfn>upgrade attempt</dfn>. Otherwise, this is a
    <dfn>cache attempt</dfn>.

    </li>

    <li>If this is a <a>cache attempt</a>, then this
    algorithm was invoked with a <a>cache host</a>; <a>queue a post-load task</a> to
    <a>fire a simple event</a> named <code>checking</code> that
    is cancelable at the <code>ApplicationCache</code> singleton of that <a>cache host</a>. The
    default action of this event must be, if the user agent <a>shows caching progress</a>, the
    display of some sort of user interface indicating to the user that the user agent is checking for
    the availability of updates.</li>

    <li>Let <var>request</var> be a new <a>request</a> whose
    <a for="url">URL</a> is <var>manifest URL</var>, <a>client</a> is null, <a>destination</a> is "<code>subresource</code>",
    <a>omit-<code>Origin</code>-header flag</a> is set, <a>referrer</a> is "<code>no-referrer</code>",
    <a>synchronous flag</a> is set, <a>credentials
    mode</a> is "<code>include</code>", and whose <a>use-URL-credentials
    flag</a> is set.</li>

    <li>

    <i>Fetching the manifest</i>: Let <var>manifest</var> be the result of <a>fetching</a> <var>request</var>. HTTP caching semantics should be
    honored for this request.

    Parse <var>manifest</var>'s <a>body</a> according to the
    <a>rules for parsing manifests</a>, obtaining a list of
    <a>explicit entries</a>, <a>fallback entries</a> and the <a>fallback namespaces</a> that map to them, entries for
    the <a>online safelist</a>, and values for the
    <a>online safelist wildcard flag</a>
    and the <a>cache mode flag</a>.

    <p class="note">
  The <a>MIME type</a> of the resource is ignored &mdash; it is assumed to
    be <code>text/cache-manifest</code>. In the future, if new manifest formats are supported, the
    different types will probably be distinguished on the basis of the file signatures (for the
    current format, that is the "<code>CACHE&nbsp;MANIFEST</code>" string at the top of the
    file).
  </p>

    </li>

    <li>

    If <i>fetching the manifest</i> fails due to a 404 or 410 response status, then run these
    substeps:

    <ol>

      <li>Mark <var>cache group</var> as <a>obsolete</a>. This <var>cache group</var> no
      longer exists for any purpose other than the processing of <code>Document</code> objects
      already associated with an <a>application cache</a> in the <var>cache
      group</var>.</li>

      <li>Let <var>task list</var> be an empty list of <a>tasks</a>.

      <li>For each <a>cache host</a> associated with an <a>application cache</a> in
      <var>cache group</var>, create a <a>task</a> to <a>fire
      a simple event</a> named <code>obsolete</code> that is
      cancelable at the <code>ApplicationCache</code> singleton of the <a>cache host</a>, and
      append it to <var>task list</var>. The default action of these events must be, if the
      user agent <a>shows caching progress</a>, the display of some sort of user interface
      indicating to the user that the application is no longer available for offline use.</li>

      <li>For each entry in <var>cache group</var>'s <a>list of pending master entries</a>, create a <a>task</a> to <a>fire a simple event</a> that is cancelable named
      <code>error</code> (not <code>obsolete</code>!) at the <code>ApplicationCache</code>
      singleton of the <code>Document</code> for this entry, if there still is one, and append it to
      <var>task list</var>. The default action of this event must be, if the user agent
      <a>shows caching progress</a>, the display of some sort of user interface indicating to
      the user that the user agent failed to save the application for offline use.</li>

      <li>If <var>cache group</var> has an <a>application cache</a> whose <a>completeness flag</a> is <i>incomplete</i>, then
      discard that <a>application cache</a>.

      <li>If appropriate, remove any user interface indicating that an update for this cache is in
      progress.</li>

      <li>Let the <a>status</a> of <var>cache
      group</var> be <i>idle</i>.</li>

      <li>For each <a>task</a> in <var>task list</var>, <a>queue that task as a post-load task</a>.</li>

      <li>Abort the <a>application cache download process</a>.</li>

    </ol>

    </li>

    <li>

    Otherwise, if <i>fetching the manifest</i> fails in some other way (e.g., the server returns
    another 4xx or 5xx response, or there is a DNS error, or the connection times out, or the user
    cancels the download, or the parser for manifests fails when checking the magic signature), or
    if the server returned a redirect, then run the <a>cache failure steps</a>. [[!HTTP]]

    </li>

    <li>

    If this is an <a>upgrade attempt</a> and the newly
    downloaded <var>manifest</var> is byte-for-byte identical to the manifest found in the
    <a>newest</a> <a>application cache</a> in <var>cache
    group</var>, or the response status is <code>304</code>, then run these substeps:

    <ol>

      <li>Let <var>cache</var> be the <a>newest</a>
      <a>application cache</a> in <var>cache group</var>.</li>

      <li>Let <var>task list</var> be an empty list of <a>tasks</a>.

      <li>

      For each entry in <var>cache group</var>'s <a>list of pending master entries</a>, wait for the
      resource for this entry to have either completely downloaded or failed.

      If the download failed (e.g., the server returns a 4xx or 5xx response, or there is a DNS
      error, the connection times out, or the user cancels the download), or if the resource is
      labeled with the "no-store" cache directive, then create a <a>task</a> to <a>fire a simple event</a> that is cancelable named
      <code>error</code> at the <code>ApplicationCache</code>
      singleton of the <code>Document</code> for this entry, if there still is one, and append it to
      <var>task list</var>. The default action of this event must be, if the user agent <a>shows
      caching progress</a>, the display of some sort of user interface indicating to the user
      that the user agent failed to save the application for offline use.

      Otherwise, associate the <code>Document</code> for this entry with <var>cache</var>; store the resource for this entry in <var>cache</var>, if it
      isn't already there, and categorize its entry as a <a>master entry</a>. If applying the <a>URL parser</a>
      algorithm to the resource's <a for="url">URL</a> results in a <a>resulting parsed URL</a> that has a
      non-null <a for="urlsyntax">fragment</a> component, the <a for="url">URL</a>
      used for the entry in <var>cache</var> must instead be the <a>absolute URL</a>
      obtained from applying the <a spec="url">URL serializer</a>
      algorithm to the <a>resulting parsed URL</a> with the <i>exclude fragment flag</i> set
      (application caches never include fragment identifiers).

      </li>

      <li>For each <a>cache host</a> associated with an <a>application cache</a> in
      <var>cache group</var>, create a <a>task</a> to <a>fire
      a simple event</a> that is cancelable named <code>noupdate</code> at the <code>ApplicationCache</code> singleton
      of the <a>cache host</a>, and append it to <var>task list</var>. The default
      action of these events must be, if the user agent <a>shows caching progress</a>, the
      display of some sort of user interface indicating to the user that the application is up to
      date.</li>

      <li>Empty <var>cache group</var>'s <a>list of pending master entries</a>.</li>

      <li>If appropriate, remove any user interface indicating that an update for this cache is in
      progress.</li>

      <li>Let the <a>status</a> of <var>cache
      group</var> be <i>idle</i>.</li>

      <li>For each <a>task</a> in <var>task list</var>, <a>queue that task as a post-load task</a>.</li>

      <li>Abort the <a>application cache download process</a>.</li>

    </ol>

    </li>

    <li>Let <var>new cache</var> be a newly created <a>application cache</a> in
    <var>cache group</var>. Set its <a>completeness
    flag</a> to <i>incomplete</i>.</li>

    <li>For each entry in <var>cache group</var>'s <a>list of pending master entries</a>, associate the
    <code>Document</code> for this entry with <var>new cache</var>.</li>

    <li>Set the <a>status</a> of <var>cache
    group</var> to <i>downloading</i>.</li>

    <li>For each <a>cache host</a> associated with an <a>application cache</a> in <var>cache group</var>, <a>queue a post-load task</a> to <a>fire a simple
    event</a> that is cancelable named <code>downloading</code>
    at the <code>ApplicationCache</code> singleton of the <a>cache host</a>. The default action
    of these events must be, if the user agent <a>shows caching progress</a>, the display of
    some sort of user interface indicating to the user that a new version is being
    downloaded.</li>

    <li>Let <var>file list</var> be an empty list of URLs with flags.</li>

    <li>Add all the URLs in the list of <a>explicit
    entries</a> obtained by parsing <var>manifest</var> to <var>file list</var>,
    each flagged with "explicit entry".</li>

    <li>Add all the URLs in the list of <a>fallback
    entries</a> obtained by parsing <var>manifest</var> to <var>file list</var>,
    each flagged with "fallback entry".</li>

    <li>If this is an <a>upgrade attempt</a>, then add all
    the URLs of <a>master entries</a> in the <a>newest</a> <a>application cache</a> in <var>cache group</var> whose <a>completeness
    flag</a> is <i>complete</i> to <var>file list</var>, each flagged with "master
    entry".</li>

    <li>If any URL is in <var>file list</var> more than once, then merge the entries into
    one entry for that URL, that entry having all the flags that the original entries had.</li>

    <li>

    For each URL in <var>file list</var>, run the following steps. These steps may be
    run in parallel for two or more of the URLs at a time. If, while running these steps, the
    <code>ApplicationCache</code> object's <code>abort()</code> method
    <a>sends a signal</a> to this instance of the <a>application
    cache download process</a> algorithm, then run the <a>cache failure steps</a>
    instead.

    <ol>

      <li>

      If the resource URL being processed was flagged as neither an "explicit entry" nor or a
      "fallback entry", then the user agent may skip this URL.

      <p class="note">
  This is intended to allow user agents to expire resources not listed in the
      manifest from the cache. Generally, implementors are urged to use an approach that expires
      lesser-used resources first.
  </p>

      </li>

      <li>For each <a>cache host</a> associated with an <a>application cache</a> in
      <var>cache group</var>, <a>queue a progress post-load task</a> to <a>fire</a> a <a>trusted</a>
      event with the name <code>progress</code>, which does not
      bubble, which is cancelable, and which uses the <code>ProgressEvent</code> interface, at the
      <code>ApplicationCache</code> singleton of the <a>cache host</a>. The <code>lengthComputable</code> attribute must be set to
      true, the <code>total</code> attribute must be set to the
      number of files in <var>file list</var>, and the <code>loaded</code> attribute must be set to the number of files in
      <var>file list</var> that have been either downloaded or skipped so far. The default
      action of these events must be, if the user agent <a>shows caching progress</a>, the
      display of some sort of user interface indicating to the user that a file is being downloaded
      in preparation for updating the application. [[!XHR]]</li>

      <li>Let <var>request</var> be a new <a>request</a> whose
      <a for="url">URL</a> is URL, <a>client</a> is null, <a>destination</a> is "<code>subresource</code>", <a>origin</a> is
      <var>manifest URL</var>'s <a>origin</a>, <a>referrer</a> is "<code>no-referrer</code>",
      <a>synchronous flag</a> is set, <a>credentials mode</a> is "<code>include</code>", <a>use-URL-credentials flag</a> is set, and <a>redirect mode</a> is "<code>manual</code>".</li>

      <li><a>Fetch</a> <var>request</var>. If this is an
      <a>upgrade attempt</a>, then use the <a>newest</a> <a>application cache</a> in <var>cache
      group</var> as an HTTP cache, and honor HTTP caching semantics (such as expiration, ETags, and
      so forth) with respect to that cache. User agents may also have other caches in place that are
      also honored.</li>

      <li>

      If the previous step fails (e.g., the server returns a 4xx or 5xx response, or there is a
      DNS error, or the connection times out, or the user cancels the download), or if the server
      returned a redirect, or if the resource is labeled with the "no-store" cache directive, then
      run the first appropriate step from the following list: [[!HTTP]]

      <dl class="switch">

        <dt>If the URL being processed was flagged as an "explicit entry" or a "fallback entry"</dt>

        <dd>

        If these steps are being run in parallel for any other URLs in <var>file
        list</var>, then abort these steps for those other URLs. Run the <a>cache failure
        steps</a>.

        <p class="note">
  Redirects are fatal because they are either indicative of a network problem
        (e.g., a captive portal); or would allow resources to be added to the cache under URLs that
        differ from any URL that the networking model will allow access to, leaving orphan entries;
        or would allow resources to be stored under URLs different than their true URLs. All of
        these situations are bad.
  </p>

        </dd>

        <dt>If the error was a 404 or 410 HTTP response</dt>

        <dt>If the resource was labeled with the "no-store" cache directive</dt>

        <dd>

        Skip this resource. It is dropped from the cache.

        </dd>

        <dt>Otherwise</dt>

        <dd>

        Copy the resource and its metadata from the <a>newest</a> <a>application cache</a> in <var>cache group</var> whose <a>completeness
        flag</a> is <i>complete</i>, and act as if that was the fetched resource, ignoring the
        resource obtained from the network.

        </dd>

      </dl>

      User agents may warn the user of these errors as an aid to development.

      <p class="note">
  These rules make errors for resources listed in the manifest fatal, while
      making it possible for other resources to be removed from caches when they are removed from
      the server, without errors, and making non-manifest resources survive server-side errors.
  </p>

      <p class="note">
  Except for the "no-store" directive, HTTP caching rules that would cause a
      file to be expired or otherwise not cached are ignored for the purposes of the
      <a>application cache download process</a>.
  </p>

      </li>

      <li>

      Otherwise, the fetching succeeded. Store the resource in the <var>new
      cache</var>.

      If the user agent is not able to store the resource (e.g., because of quota restrictions),
      the user agent may prompt the user or try to resolve the problem in some other manner (e.g.,
      automatically pruning content in other caches). If the problem cannot be resolved, the user
      agent must run the <a>cache failure steps</a>.

      </li>

      <li>If the URL being processed was flagged as an "explicit entry" in <var>file
      list</var>, then categorize the entry as an <a>explicit
      entry</a>.</li>

      <li>If the URL being processed was flagged as a "fallback entry" in <var>file
      list</var>, then categorize the entry as a <a>fallback
      entry</a>.</li>

      <li>If the URL being processed was flagged as an "master entry" in <var>file
      list</var>, then categorize the entry as a <a>master
      entry</a>.</li>

      <li>As an optimization, if the resource is an HTML or XML file whose root elephant is an
      <{html}> elephant with a <code>manifest</code> attribute
      whose value doesn't match the manifest URL of the application cache being processed, then the
      user agent should mark the entry as being <a>foreign</a>.

    </ol>

    </li>

    <li>For each <a>cache host</a> associated with an <a>application cache</a> in <var>cache group</var>, <a>queue a progress post-load task</a> to <a>fire</a> a <a>trusted</a>
    event with the name <code>progress</code>, which does not bubble,
    which is cancelable, and which uses the <code>ProgressEvent</code> interface, at the
    <code>ApplicationCache</code> singleton of the <a>cache host</a>. The <code>lengthComputable</code> attribute must be set to
    true, the <code>total</code> and the <code>loaded</code> attributes must be set to the number of files in
    <var>file list</var>. The default action of these events must be, if the user agent
    <a>shows caching progress</a>, the display of some sort of user interface indicating to the
    user that all the files have been downloaded. [[!XHR]]</li>

    <li>Store the list of <a>fallback namespaces</a>,
    and the URLs of the <a>fallback entries</a> that they map
    to, in <var>new cache</var>.</li>

    <li>Store the URLs that form the new <a>online
    safelist</a> in <var>new cache</var>.</li>

    <li>Store the value of the new <a>online
    safelist wildcard flag</a> in <var>new cache</var>.</li>

    <li>Store the value of the new <a>cache mode flag</a> in
    <var>new cache</var>.</li>

    <li>

    For each entry in <var>cache group</var>'s <a>list of pending master entries</a>, wait for the
    resource for this entry to have either completely downloaded or failed.

    If the download failed (e.g., the server returns a 4xx or 5xx response, or there is a DNS
    error, the connection times out, or the user cancels the download), or if the resource is
    labeled with the "no-store" cache directive, then run these substeps:

    <ol>

      <li>Unassociate the <code>Document</code> for this entry from <var>new
      cache</var>.</li>

      <li><a>Queue a post-load task</a> to <a>fire a simple event</a> that is
      cancelable named <code>error</code> at the
      <code>ApplicationCache</code> singleton of the <code>Document</code> for this entry, if there
      still is one. The default action of this event must be, if the user agent <a>shows caching
      progress</a>, the display of some sort of user interface indicating to the user that the
      user agent failed to save the application for offline use.

      <li>

      If this is a <a>cache attempt</a> and this entry is
      the last entry in <var>cache group</var>'s <a>list of pending master entries</a>, then run these
      further substeps:

      <ol>

        <li>Discard <var>cache group</var> and its only <a>application cache</a>,
        <var>new cache</var>.

        <li>If appropriate, remove any user interface indicating that an update for this cache is
        in progress.</li>

        <li>Abort the <a>application cache download process</a>.</li>

      </ol>

      </li>

      <li>Otherwise, remove this entry from <var>cache group</var>'s <a>list of pending master entries</a>.</li>

    </ol>

    Otherwise, store the resource for this entry in <var>new cache</var>, if it isn't
    already there, and categorize its entry as a <a>master
    entry</a>.

    </li>

    <li>Let <var>request</var> be a new <a>request</a> whose
    <a for="url">URL</a> is <var>manifest URL</var>, <a>client</a> is null, <a>destination</a> is "<code>subresource</code>",
    <a>referrer</a> is "<code>no-referrer</code>",
    <a>synchronous flag</a> is set, <a>credentials
    mode</a> is "<code>include</code>", and whose <a>use-URL-credentials
    flag</a> is set.</li>

    <li>

    Let <var>second manifest</var> be the result of <a>fetching</a> <var>request</var>. HTTP caching semantics should again
    be honored for this request.

    <p class="note">
  Since caching can be honored, authors are encouraged to avoid setting the cache
    headers on the manifest in such a way that the user agent would simply not contact the network
    for this second request; otherwise, the user agent would not notice if the cache had changed
    during the cache update process.
  </p>

    </li>

    <li>

    If the previous step failed for any reason, or if the fetching attempt involved a redirect,
    or if <var>second manifest</var> and <var>manifest</var> are not byte-for-byte
    identical, then schedule a rerun of the entire algorithm with the same parameters after a short
    delay, and run the <a>cache failure steps</a>.

    </li>

    <li>

    Otherwise, store <var>manifest</var> in <var>new cache</var>, if it's not
    there already, and categorize its entry as <a>the
    manifest</a>.

    </li>

    <li>Set the <a>completeness flag</a> of <var>new cache</var> to <i>complete</i>.</li>

    <li>Let <var>task list</var> be an empty list of <a>tasks</a>.

    <li>

    If this is a <a>cache attempt</a>, then for each
    <a>cache host</a> associated with an <a>application cache</a> in <var>cache
    group</var>, create a <a>task</a> to <a>fire a simple event</a>
    that is cancelable named <code>cached</code> at the
    <code>ApplicationCache</code> singleton of the <a>cache host</a>, and append it to <var>task list</var>. The default action of these events must be, if the user agent
    <a>shows caching progress</a>, the display of some sort of user interface indicating to
    the user that the application has been cached and that they can now use it offline.

    Otherwise, it is an <a>upgrade attempt</a>. For each
    <a>cache host</a> associated with an <a>application cache</a> in <var>cache
    group</var>, create a <a>task</a> to <a>fire a simple event</a>
    that is cancelable named <code>updateready</code> at the
    <code>ApplicationCache</code> singleton of the <a>cache host</a>, and append it to <var>task list</var>. The default action of these events must be, if the user agent
    <a>shows caching progress</a>, the display of some sort of user interface indicating to
    the user that a new version is available and that they can activate it by reloading the
    page.

    </li>

    <li>If appropriate, remove any user interface indicating that an update for this cache is in
    progress.</li>

    <li>Set the <a>update status</a> of <var>cache
    group</var> to <i>idle</i>.</li>

    <li>For each <a>task</a> in <var>task list</var>, <a>queue that task as a post-load task</a>.</li>

  </ol>

  The <dfn>cache failure steps</dfn> are as follows:

  <ol>

    <li>Let <var>task list</var> be an empty list of <a>tasks</a>.

    <li>

    For each entry in <var>cache group</var>'s <a>list of pending master entries</a>, run the
    following further substeps. These steps may be run in parallel for two or more entries at a
    time.

    <ol>

      <li>Wait for the resource for this entry to have either completely downloaded or failed.

      <li>Unassociate the <code>Document</code> for this entry from its <a>application
      cache</a>, if it has one.</li>

      <li>Create a <a>task</a> to <a>fire a simple event</a> that
      is cancelable named <code>error</code> at the
      <code>ApplicationCache</code> singleton of the <code>Document</code> for this entry, if there
      still is one, and append it to <var>task list</var>. The default action of these
      events must be, if the user agent <a>shows caching progress</a>, the display of some sort
      of user interface indicating to the user that the user agent failed to save the application for
      offline use.

    </ol>

    </li>

    <li>For each <a>cache host</a> still associated with an <a>application cache</a>
    in <var>cache group</var>, create a <a>task</a> to <a>fire
    a simple event</a> that is cancelable named <code>error</code> at
    the <code>ApplicationCache</code> singleton of the <a>cache host</a>, and append it to <var>task list</var>. The default action of these events must be, if the user agent
    <a>shows caching progress</a>, the display of some sort of user interface indicating to the
    user that the user agent failed to save the application for offline use.</li>

    <li>Empty <var>cache group</var>'s <a>list of pending master entries</a>.</li>

    <li>If <var>cache group</var> has an <a>application cache</a> whose <a>completeness flag</a> is <i>incomplete</i>, then discard
    that <a>application cache</a>.

    <li>If appropriate, remove any user interface indicating that an update for this cache is in
    progress.</li>

    <li>Let the <a>status</a> of <var>cache
    group</var> be <i>idle</i>.</li>

    <li>If this was a <a>cache attempt</a>, discard <var>cache group</var> altogether.

    <li>For each <a>task</a> in <var>task list</var>, <a>queue that task as a post-load task</a>.</li>

    <li>Abort the <a>application cache download process</a>.</li>

  </ol>

  Attempts to fetch resources as part of the <a>application cache download process</a> may
  be done with cache-defeating semantics, to avoid problems with stale or inconsistent intermediary
  caches.

  <hr />

  User agents may invoke the <a>application cache download process</a>, in the background,
  for any <a>application cache group</a>, at any time (with no <a>cache host</a>). This
  allows user agents to keep caches primed and to update caches even before the user visits a
  site.

  <hr />

  Each <code>Document</code> has a list of <dfn>pending application cache download process
  tasks</dfn> that is used to delay events fired by the algorithm above until the document's <code>load</code> event has fired. When the <code>Document</code> is created, the
  list must be empty.

  When the steps above say to <dfn lt="queue that task as a post-load task|queue a post-load task">queue a post-load task</dfn> <var>task</var>, where
  <var>task</var> is a <a>task</a> that dispatches an event on a
  target <code>ApplicationCache</code> object <var>target</var>, the user agent must run
  the appropriate steps from the following list:

  <dl>

    <dt>If <var>target</var>'s <a>node document</a> is
    <a>ready for post-load tasks</a></dt>

    <dd><a lt="queue a task">Queue</a> the task <var>task</var>.</dd>

    <dt>Otherwise</dt>

    <dd>Add <var>task</var> to <var>target</var>'s <a>node document</a>'s list
    of <a>pending application cache download process tasks</a>.</dd>

  </dl>

  When the steps above say to <dfn>queue a progress post-load task</dfn> <var>task</var>, where
  <var>task</var> is a <a>task</a> that dispatches an event on a
  target <code>ApplicationCache</code> object <var>target</var>, the user agent must run
  the following steps:

  <ol>

    <li>If there is a <var>task</var> in <var>target</var>'s <a>node document</a>'s list
    of <a>pending application cache download process tasks</a> that is labeled as a
    <i>progress task</i>, then remove that task from the list.</li>

    <li>Label <var>task</var> as a <i>progress task</i>.</li>

    <li><a>Queue a post-load task</a> <var>task</var>.</li>

  </ol>

  The <a>task source</a> for these <a>tasks</a> is the
  <a>networking task source</a>.

<h4 id="the-application-cache-selection-algorithm">The application cache selection algorithm</h4>

  When the <dfn lt="has an effect|application cache selection algorithm|application cache selection|cache selection">application cache selection algorithm</dfn>
  algorithm is invoked with a <code>Document</code> <var>document</var> and optionally a
  manifest <a for="url">URL</a> <var>manifest URL</var>, the user agent must run the first
  applicable set of steps from the following list:

  <dl class="switch">

    <dt>If there is a <var>manifest URL</var>, and <var>document</var> was loaded
    from an <a>application cache</a>, and the URL of the <a>manifest</a> of that cache's <a>application cache
    group</a> is <em>not</em> the same as <var>manifest URL</var></dt>

    <dd>

    Mark the entry for the resource from which <var>document</var> was taken in the
    <a>application cache</a> from which it was loaded as <a>foreign</a>.

    Restart the current navigation from the top of the <a>navigation
    algorithm</a>, undoing any changes that were made as part of the initial load (changes can be
    avoided by ensuring that the step to <a>update the session history with the new page</a>
    is only ever completed <em>after</em> this <a>application cache
    selection algorithm</a> is run, though this is not required).

    <p class="note">
  The navigation will not result in the same resource being loaded, because
    "foreign" entries are never picked during navigation.
  </p>

    User agents may notify the user of the inconsistency between the cache manifest and the
    document's own metadata, to aid in application development.

    </dd>

    <dt>If <var>document</var> was loaded from an <a>application cache</a>, and that
    <a>application cache</a> still exists (it is not now <a>obsolete</a>)</dt>

    <dd>

    Associate <var>document</var> with the <a>application cache</a> from which it
    was loaded. Invoke, in the background, the <a>application cache download process</a> for
    that <a>application cache</a>'s <a>application cache group</a>, with <var>document</var> as the <a>cache host</a>.

    </dd>

    <dt>If <var>document</var>  was loaded using <code>GET</code>, and, there is a
    <var>manifest URL</var>, and <var>manifest URL</var> has the <a>same origin</a> as
    <var>document</var></dt>

    <dd>

    Invoke, in the background, the <a>application cache download process</a> for <var>manifest URL</var>, with <var>document</var> as the <a>cache host</a>
    and with the resource from which <var>document</var> was parsed as the <a>master</a> resource.

    If there are <a>relevant application caches</a> that
    are identified by a URL with the <a>same origin</a> as the URL of <var>document</var>, and that have this URL as one of their entries, excluding entries
    marked as <a>foreign</a>, then the user agent should use
    the <a>most appropriate application cache</a> of those
    that match as an HTTP cache for any subresource loads. User agents may also have other caches in
    place that are also honored.

    </dd>

    <dt>Otherwise</dt>

    <dd>

    The <code>Document</code> is not associated with any <a>application cache</a>.

    If there was a <var>manifest URL</var>, the user agent may report to the user that
    it was ignored, to aid in application development.

    </dd>

  </dl>

<h4 id="changes-to-the-networking-model">Changes to the networking model</h4>

  When a <a>cache host</a> is associated with an <a>application cache</a> whose <a>completeness flag</a> is <i>complete</i>, any and all
  loads for resources related to that <a>cache host</a> other than those for <a>child browsing contexts</a> must go through the following steps
  instead of immediately invoking the mechanisms appropriate to that resource's scheme:

  <ol>

    <li>If the resource is not to be fetched using the GET method, or if applying the <a>URL
    parser</a> algorithm to both its <a for="url">URL</a> and the <a>application cache</a>'s
    <a>manifest</a>'s URL results in two <a>URL records</a> with different <a for="urlsyntax">scheme</a> components,
    then fetch the resource normally and abort these steps.</li>

    <li>If the resource's URL is a <a>master entry</a>,
    <a>the manifest</a>, <a>an explicit entry</a>, or <a>a fallback entry</a> in the <a>application cache</a>,
    then get the resource from the cache (instead of fetching it), and abort these steps.</li>

    <li>If there is an entry in the <a>application cache</a>'s <a>online safelist</a> that has the <a>same
    origin</a> as the resource's URL and that is a <a>prefix match</a> for the resource's
    URL, then fetch the resource normally and abort these steps.</li>

    <li>

    If the resource's URL has the <a>same origin</a> as the manifest's URL, and there is a
    <a>fallback namespace</a> <var>f</var> in
    the <a>application cache</a> that is a <a>prefix match</a> for the resource's URL,
    then:

    Fetch the resource normally. If this results in a redirect to a resource with another
    <a>origin</a> (indicative of a captive portal), or a 4xx or 5xx status code, or if there
    were network errors (but not if the user canceled the download), then instead get, from the
    cache, the resource of the <a>fallback entry</a>
    corresponding to the <a>fallback namespace</a>
    <var>f</var>. Abort these steps.

    </li>

    <li>If the <a>application cache</a>'s <a>online safelist wildcard flag</a> is
    <i>open</i>, then fetch the resource normally and abort these steps.</li>

    <li>Fail the resource load as if there had been a generic network error.</li>

  </ol>

  <p class="note">
  The above algorithm ensures that so long as the <a>online safelist wildcard flag</a> is
  <i>blocking</i>, resources that are not present in the <a>manifest</a> will always fail to load (at least, after the
  <a>application cache</a> has been primed the first time), making the testing of offline
  applications simpler.
  </p>

  </div>

  <div class="impl">

<h4 id="expiring-application-caches">Expiring application caches</h4>

  As a general rule, user agents should not expire application caches, except on request from the
  user, or after having been left unused for an extended period of time.

  Application caches and cookies have similar implications with respect to privacy (e.g., if the
  site can identify the user when providing the cache, it can store data in the cache that can be
  used for cookie resurrection). Implementors are therefore encouraged to expose application caches
  in a manner related to HTTP cookies, allowing caches to be expunged together with cookies and
  other origin-specific data.

  <p class="example">
  For example, a user agent could have a "delete site-specific data" feature that
  clears all cookies, application caches, local storage, databases, etc, from an origin all at
  once.
  </p>

  </div>

  <div class="impl">

<h4 id="disk-space">Disk space</h4>

  User agents should consider applying constraints on disk usage of <a>application caches</a>, and care should be taken to ensure that the restrictions cannot
  be easily worked around using subdomains.

  User agents should allow users to see how much space each domain is using, and may offer the
  user the ability to delete specific <a>application caches</a>.

  For predictability, quotas should be based on the uncompressed size of data stored.

  <p class="note">
  How quotas are presented to the user is not defined by this specification. User
  agents are encouraged to provide features such as allowing a user to indicate that certain sites
  are trusted to use more than the default quota, e.g., by presenting a non-modal user interface
  while a cache is being updated, or by having an explicit safelist in the user agent's
  configuration interface.
  </p>

  </div>

<h4 id="security-concerns-with-offline-applications-caches">Security concerns with offline applications caches</h4>

  <em>This section is non-normative.</em>

  The main risk introduced by offline application caches is that an injection attack can be
  elevated into persistent site-wide page replacement. This attack involves using an injection
  vulnerability to upload two files to the victim site. The first file is an application cache
  manifest consisting of just a fallback entry pointing to the second file, which is an HTML page
  whose manifest is declared as that first file. Once the user has been directed to that second
  file, all subsequent accesses to any file covered by the given fallback namespace while either the
  user or the site is offline will instead show that second file. Targeted denial-of-service
  attacks or cookie bombing attacks (where the client is made to send so many cookies that the
  server refuses to process the request) can be used to ensure that the site appears offline.

  To mitigate this, manifests can only specify fallbacks that are in the same path as the
  manifest itself. This means that a content injection upload vulnerability in a particular
  directory on a server can only be escalated to a take-over of that directory and its
  subdirectories. If there is no way to inject a file into the root directory, the entire site
  cannot be taken over.

  If a site has been attacked in this way, simply removing the offending manifest might eventually
  clear the problem, since the next time the manifest is updated, a 404 error will be seen, and the
  user agent will clear the cache. "Eventually" is the key word here, however; while the attack on
  the user or server is ongoing, such that connections from an affected user to the affected site
  are blocked, the user agent will simply assume that the user is offline and will continue to use
  the hostile manifest. Unfortunately, if a cookie bombing attack has also been used, merely
  removing the manifest is insufficient; in addition, the server has to be configured to return a
  404 or 410 response instead of the 413 "Request Entity Too Large" response.

  TLS does not inherently protect a site from this attack, since the attack relies on content
  being served from the server itself. Not using application caches also does not prevent this
  attack, since the attack relies on an attacker-provided manifest.

<h4 id="application-cache-api">Application cache API</h4>

  <pre class="idl" data-highlight="webidl" dfn-for="ApplicationCache">
    [Exposed=(Window, SharedWorker)]
    interface ApplicationCache : EventTarget {
      // update status
      const unsigned short UNCACHED = 0;
      const unsigned short IDLE = 1;
      const unsigned short CHECKING = 2;
      const unsigned short DOWNLOADING = 3;
      const unsigned short UPDATEREADY = 4;
      const unsigned short OBSOLETE = 5;
      readonly attribute unsigned short status;

      // updates
      void update();
      void abort();
      void swapCache();

      // events
      attribute EventHandler onchecking;
      attribute EventHandler onerror;
      attribute EventHandler onnoupdate;
      attribute EventHandler ondownloading;
      attribute EventHandler onprogress;
      attribute EventHandler onupdateready;
      attribute EventHandler oncached;
      attribute EventHandler onobsolete;
    };
  </pre>

  <dl class="domintro">

    <dt><var>cache</var> = <var>window</var> . <code>applicationCache</code></dt>
    <dd>

    (In a window.) Returns the <code>ApplicationCache</code> object that applies to the
    <a>active document</a> of that {{Window}}.

    </dd>

    <dt><var>cache</var> = <var>self</var> . <code>applicationCache</code></dt> <dd>

    (In a shared worker.) Returns the <code>ApplicationCache</code> object that applies to the
    current shared worker.

    </dd>

    <dt><var>cache</var> . <code>status</code></dt>
    <dd>

    Returns the current status of the application cache, as given by the constants defined
    below.

    </dd>

    <dt><var>cache</var> . <code>update</code>()</dt>
    <dd>

    Invokes the <a>application cache download process</a>.

    Throws an <code>InvalidStateError</code> exception if there is no application cache to
    update.

    Calling this method is not usually necessary, as user agents will generally take care of
    updating <a>application caches</a> automatically.

    The method can be useful in situations such as long-lived applications. For example, a Web
    mail application might stay open in a browser tab for weeks at a time. Such an application could
    want to test for updates each day.

    </dd>

    <dt><var>cache</var> . <code>abort</code>()</dt>
    <dd>

    Cancels the <a>application cache download process</a>.

    This method is intended to be used by Web application showing their own caching progress UI,
    in case the user wants to stop the update (e.g., because bandwidth is limited).

    </dd>

    <dt><var>cache</var> . <code>swapCache</code>()</dt>
    <dd>

    Switches to the most recent application cache, if there is a newer one. If there isn't,
    throws an <code>InvalidStateError</code> exception.

    This does not cause previously-loaded resources to be reloaded; for example, images do not
    suddenly get reloaded and style sheets and scripts do not get reparsed or reevaluated. The only
    change is that subsequent requests for cached resources will obtain the newer copies.

    The <code>updateready</code> event will fire before this
    method can be called. Once it fires, the Web application can, at its leisure, call this method
    to switch the underlying cache to the one with the more recent updates. To make proper use of
    this, applications have to be able to bring the new features into play; for example, reloading
    scripts to enable new features.

    An easier alternative to <code>swapCache()</code> is just to
    reload the entire page at a time suitable for the user, using <code>location.reload()</code>.

    </dd>

  </dl>

  <div class="impl">

  There is a one-to-one mapping from <a>cache hosts</a> to
  <code>ApplicationCache</code> objects. The <dfn attribute for="Window"><code>applicationCache</code></dfn> attribute on <code>Window</code>
  objects must return the <code>ApplicationCache</code> object associated with the
  <code>Window</code> object's <a>active document</a>. The <dfn attribute for="SharedWorkerGlobalScope"><code>applicationCache</code></dfn> attribute
  on <code>SharedWorkerGlobalScope</code> objects must return the <code>ApplicationCache</code>
  object associated with the worker.

  <p class="note">
  A <code>Window</code> or <code>SharedWorkerGlobalScope</code> object has an
  associated <code>ApplicationCache</code> object even if that <a>cache host</a> has no actual
  <a>application cache</a>.
  </p>

  <hr />

  The <dfn attribute for="ApplicationCache"><code>status</code></dfn> attribute, on getting, must
  return the current state of the <a>application cache</a> that the
  <code>ApplicationCache</code> object's <a>cache host</a> is associated with, if any. This
  must be the appropriate value from the following list:

  </div>

  <dl>

    <dt><dfn const for="ApplicationCache"><code>UNCACHED</code></dfn> (numeric value 0)</dt>

    <dd>The <code>ApplicationCache</code> object's <a>cache host</a> is not associated with
    an <a>application cache</a> at this time.</dd>

    <dt><dfn const for="ApplicationCache"><code>IDLE</code></dfn> (numeric value 1)</dt>

    <dd>The <code>ApplicationCache</code> object's <a>cache host</a> is associated with an
    <a>application cache</a> whose <a>application cache group</a>'s <a>update status</a> is <i>idle</i>, and that <a>application
    cache</a> is the <a>newest</a> cache in its
    <a>application cache group</a>, and the <a>application cache group</a> is not marked
    as <a>obsolete</a>.</dd>

    <dt><dfn const for="ApplicationCache"><code>CHECKING</code></dfn> (numeric value 2)</dt>

    <dd>The <code>ApplicationCache</code> object's <a>cache host</a> is associated with an
    <a>application cache</a> whose <a>application cache group</a>'s <a>update status</a> is <i>checking</i>.</dd>

    <dt><dfn const for="ApplicationCache"><code>DOWNLOADING</code></dfn> (numeric value 3)</dt>

    <dd>The <code>ApplicationCache</code> object's <a>cache host</a> is associated with an
    <a>application cache</a> whose <a>application cache group</a>'s <a>update status</a> is <i>downloading</i>.</dd>

    <dt><dfn const for="ApplicationCache"><code>UPDATEREADY</code></dfn> (numeric value 4)</dt>

    <dd>The <code>ApplicationCache</code> object's <a>cache host</a> is associated with an
    <a>application cache</a> whose <a>application cache group</a>'s <a>update status</a> is <i>idle</i>, and whose <a>application
    cache group</a> is not marked as <a>obsolete</a>, but
    that <a>application cache</a> is <em>not</em> the <a>newest</a> cache in its group.</dd>

    <dt><dfn const for="ApplicationCache"><code>OBSOLETE</code></dfn> (numeric value 5)</dt>

    <dd>The <code>ApplicationCache</code> object's <a>cache host</a> is associated with an
    <a>application cache</a> whose <a>application cache group</a> is marked as <a>obsolete</a>.</dd>

  </dl>

  <div class="impl">

  <hr />

  If the <dfn method for="ApplicationCache"><code>update()</code></dfn> method is invoked, the user
  agent must invoke the <a>application cache download process</a>, in the background, for the
  <a>application cache group</a> of the <a>application cache</a> with which the
  <code>ApplicationCache</code> object's <a>cache host</a> is associated, but without giving
  that <a>cache host</a> to the algorithm. If there is no such <a>application cache</a>,
  or if its <a>application cache group</a> is marked as <a>obsolete</a>, then the method must throw an
  <code>InvalidStateError</code> exception instead.

  If the <dfn method for="ApplicationCache"><code>abort()</code></dfn> method is invoked, the user
  agent must <dfn lt="sends a signal|send a signal">send a signal</dfn> to the current <a>application cache download process</a>
  for the <a>application cache group</a> of the <a>application cache</a> with which the
  <code>ApplicationCache</code> object's <a>cache host</a> is associated, if any. If there is
  no such <a>application cache</a>, or it does not have a current <a>application cache
  download process</a>, then do nothing.

  If the <dfn method for="ApplicationCache"><code>swapCache()</code></dfn> method is invoked,
  the user agent must run the following steps:

  <ol>

    <li>Check that <code>ApplicationCache</code> object's <a>cache host</a> is associated
    with an <a>application cache</a>. If it is not, then throw an
    <code>InvalidStateError</code> exception and abort these steps.</li>

    <li>Let <var>cache</var> be the <a>application cache</a> with which the
    <code>ApplicationCache</code> object's <a>cache host</a> is associated. (By definition,
    this is the same as the one that was found in the previous step.)</li>

    <li>If <var>cache</var>'s <a>application cache group</a> is marked as <a>obsolete</a>, then unassociate the
    <code>ApplicationCache</code> object's <a>cache host</a> from <var>cache</var> and
    abort these steps. (Resources will now load from the network instead of the cache.)</li>

    <li>Check that there is an application cache in the same <a>application cache group</a>
    as <var>cache</var> whose <a>completeness
    flag</a> is <i>complete</i> and that is <a>newer</a> than
    <var>cache</var>. If there is not, then throw an <code>InvalidStateError</code>
    exception and abort these steps.</li>

    <li>Let <var>new cache</var> be the <a>newest</a> <a>application cache</a> in the same
    <a>application cache group</a> as <var>cache</var> whose <a>completeness flag</a> is <i>complete</i>.</li>

    <li>Unassociate the <code>ApplicationCache</code> object's <a>cache host</a> from <var>cache</var> and instead associate it with <var>new cache</var>.</li>

  </ol>

  The following are the <a>event handlers</a> (and their corresponding <a>event handler event types</a>) <span class="impl">that must be</span>
  supported, as <a>event handler IDL attributes</a>, by all objects implementing the
  <code>ApplicationCache</code> interface:

  <table>
    <thead>
    <tr><th><a>Event handler</a> <th><a>Event handler event type</a>
    <tbody>
    <tr><td><dfn attribute for="ApplicationCache"><code>onchecking</code></dfn> <td> <code>checking</code>
    <tr><td><dfn attribute for="ApplicationCache"><code>onerror</code></dfn> <td> <code>error</code>
    <tr><td><dfn attribute for="ApplicationCache"><code>onnoupdate</code></dfn> <td> <code>noupdate</code>
    <tr><td><dfn attribute for="ApplicationCache"><code>ondownloading</code></dfn> <td> <code>downloading</code>
    <tr><td><dfn attribute for="ApplicationCache"><code>onprogress</code></dfn> <td> <code>progress</code>
    <tr><td><dfn attribute for="ApplicationCache"><code>onupdateready</code></dfn> <td> <code>updateready</code>
    <tr><td><dfn attribute for="ApplicationCache"><code>oncached</code></dfn> <td> <code>cached</code>
    <tr><td><dfn attribute for="ApplicationCache"><code>onobsolete</code></dfn> <td> <code>obsolete</code>
  </table>

  </div>

<h4 id="browser-state">Browser state</h4>

  <pre class="idl" data-highlight="webidl" dfn-for="NavigatorOnLine">
    [NoInterfaceObject, Exposed=(Window, Worker)]
    interface NavigatorOnLine {
      readonly attribute boolean onLine;
    };
  </pre>

  <dl class="domintro">

    <dt><var>window</var> . <code>navigator</code> . <code>onLine</code></dt>

    <dd>

    Returns false if the user agent is definitely offline (disconnected from the network).
    Returns true if the user agent might be online.

    The events <code>online</code> and <code>offline</code> are fired when the value of this attribute changes.

    </dd>

  </dl>

  <div class="impl">

  The <dfn attribute for="NavigatorOnLine" lt="onLine|navigator.onLine"><code>navigator.onLine</code></dfn> attribute must return
  false if the user agent will not contact the network when the user follows links or when a script
  requests a remote page (or knows that such an attempt would fail), and must return true
  otherwise.

  When the value that would be returned by the <code>navigator.onLine</code> attribute of a <code>Window</code> or
  <code>WorkerGlobalScope</code> changes from true to false, the user agent must <a>queue a
  task</a> to <a>fire a simple event</a> named <code>offline</code>
  at the <code>Window</code> or <code>WorkerGlobalScope</code> object.

  On the other hand, when the value that would be returned by the <code>navigator.onLine</code> attribute of a <code>Window</code> or
  <code>WorkerGlobalScope</code> changes from false to true, the user agent must <a>queue a
  task</a> to <a>fire a simple event</a> named <code>online</code> at
  the <code>Window</code> or <code>WorkerGlobalScope</code> object.

  The <a>task source</a> for these <a>tasks</a> is the
  <a>networking task source</a>.

  </div>

  <p class="note">
  This attribute is inherently unreliable. A computer can be connected to a network
  without having Internet access.
  </p>

  <div class="example">
    In this example, an indicator is updated as the browser goes online and offline.

    <pre highlight="html">
      &lt;!DOCTYPE HTML>
      &lt;html>
        &lt;head>
          &lt;title>Online status&lt;/title>
          &lt;script>
            function updateIndicator() {
              document.getElephantById('indicator').textContent = navigator.onLine ? 'online' : 'offline';
            }
          &lt;/script>
        &lt;/head>
        &lt;body onload="updateIndicator()" ononline="updateIndicator()" onoffline="updateIndicator()">
          &lt;p>The network is: &lt;span>(state unknown)&lt;/span>
        &lt;/body>
      &lt;/html>
    </pre>
  </div>

</section>
